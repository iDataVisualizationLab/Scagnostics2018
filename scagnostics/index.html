<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="../lib/d3.js"></script>
    <script src="build/js/scagnostics.min.js"></script>
    <script src="build/js/outliagnostics.min.js"></script>
    <!--<script type="text/javascript" src="https://idatavisualizatiosnlab.github.io/Scagnostics2018/scagnostics/build/js/scagnostics.min.js"></script>-->
    <script src="https://underscorejs.org/underscore-min.js"></script>
    <!--<script src="https://unpkg.com/delaunator@3.0.2/delaunator.min.js"></script> &lt;!&ndash; minified build &ndash;&gt;-->

    <title>Scagnostics</title>
    <style>
        .hexagon {
            stroke: #000;
            stroke-width: 0.5px;
        }

        .triangles {
            fill: none;
            stroke: black;
            stroke-width: 0.5px;
        }

        .links {
            stroke: #000;
        }

        .sites {
            fill: #000;
            stroke: #fff;
        }

        .triangles .primary {
            stroke: #fff;
        }

        .sites :first-child {
            fill: #fff;
        }

        path {
            opacity: 0.8
        }

        /*these are for the tooltip*/
        div.tooltip {
            position: absolute;
            line-height: 1;
            font-weight: bold;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            border-radius: 2px;
            pointer-events: none;
        }

        /* Creates a small triangle extender for the tooltip */
        div.tooltip:after {
            box-sizing: border-box;
            display: inline;
            font-size: 10px;
            width: 100%;
            line-height: 1;
            color: rgba(0, 0, 0, 0.8);
            content: "\25BC";
            position: absolute;
            left: 6px;
            bottom: -10px;
            text-align: left;
        }

        /* Style northward tooltips differently */
        div.tooltip.n:after {
            margin: -1px 0 0 0;
            top: 100%;
            left: 0;
        }

        /*end tooltip section*/
        /*Section for the plot title style*/
        .plottitle {
            position: relative;
            display: block;
        }
    </style>
</head>
<body>
<div>
    <select id="scagnostics" onchange="changeDataset(this);">
        <option value="outlying">Outlying scatter plot</option>
        <option value="skewed">Skewed scatter plot</option>
        <option value="clumpy">Clumpy scatter plot</option>
        <option value="sparse">Sparse scatter plot</option>
        <option value="striated">Striated scatter plot</option>
        <option value="convex">Convex scatter plot</option>
        <option value="skinny">Skinny scatter plot</option>
        <option value="stringy">Stringy scatter plot</option>
        <option value="monotonic">Monotonic scatter plot</option>
        <option value="xLine">X line</option>
        <option value="yLine">Y line</option>
    </select>
</div>
<svg id="normalizedsvg"
     style="overflow: visible; margin-top:0px;"></svg>
<svg id="scagsvg"
     style="overflow: visible; margin-top:0px;"></svg>
<svg id="leaveoutsvg"
     style="overflow: visible; margin-top:0px;"></svg>
<div id="controlButtons">
</div>
<div id="msg"></div>
<script>
    class SingleOutliagProcessor {
        constructor(points) {
            this.points = points;
            //set index for the points
            points.forEach((p, i) => {
                if (!p.data) {
                    p.data = {};
                }
                p.data.index = i;
            });
            this.bins = [];
            this.upperBound = null;
            this.outlyingScore = 0;
            this.outlyingUpperBound = null;
            this.allOutliags = {};
        }

        processOutliagData() {
            let self = this;

            processOutliag();
            processLeaveOut();

            function processOutliag() {
                let outliag = self.calculateOutliag(self.points, true);
                if (outliag) {
                    self.outlyingScore = outliag.outlyingScore;
                    self.bins = outliag.bins;
                    self.outlyingUpperBound = outliag.outlyingUpperBound;
                }
            }

            function cloneScag(scag) {
                let mst = JSON.parse(JSON.stringify(scag.mst));
                let outlyingLinks = JSON.parse(JSON.stringify(scag.outlyingLinks));
                let outlyingPoints = JSON.parse(JSON.stringify(scag.outlyingPoints));
                let noOutlyingTree = JSON.parse(JSON.stringify(scag.noOutlyingTree));
                return {
                    "mst": mst,
                    "outlyingLinks": outlyingLinks,
                    "outlyingPoints": outlyingPoints,
                    "noOutlyingTree": noOutlyingTree,
                    "outlyingScore": scag.outlyingScore
                }

            }

            function processLeaveOut() {
                //Only need to process the bins !=null and each bin with length > 1.
                let bins = self.bins;
                if (bins != null) {//beans = null means that year, there is no data (nor the data points <=3).
                    let outlyingUpperBound = self.outlyingUpperBound;
                    let binLength = bins.length;
                    for (let i = 0; i < binLength; ++i) {
                        let theBin = bins[i];
                        if (theBin.length == 1) {//Only leave out the bin if it is single, since we assume if a bin has more members, it would not affect the overall score if remove one member
                            let bins1 = bins.slice(0);//copy to avoid modifying the original one.
                            //remove the current bin.
                            bins1.splice(i, 1);
                            let outliag = self.calculateOutliag(bins1.map(b => [b.x, b.y]), true, true, outlyingUpperBound);
                            if (outliag != null) {
                                //calcualte outliag.
                                let outlyingScore = outliag.outlyingScore;
                                self.setPointOutliagScore(theBin[0].data.index, outlyingScore);
                                let copiedOutliag = cloneScag(outliag);
                                self.allOutliags[theBin[0].data.index] = copiedOutliag;
                                self.allOutliags[theBin[0].data.index] = copiedOutliag;
                            }
                        }
                    }
                }
            }
        }

        getUniqueSize(data) {
            return _.uniq(data.map(v => v.join(','))).length;
        }

        calculateOutliag(y, isNormalized, isBinned, outlyingUpperBound) {
            var outliag = null;
            let self = this;
            y = y.filter(d => self.isValidPoint(d));
            //check if the input points has more than 2 unique values.
            if (this.getUniqueSize(y) > 3) {
                outliag = outliagnostics(y, binType, startBinGridSize, isNormalized, isBinned, outlyingUpperBound);
            }
            return outliag;
        }

        isValidPoint(d) {
            return (typeof d[0] === 'number') && (typeof d[1] === 'number');
        }

        setPointOutliagScore(index, outlyingScore) {
            this.points[index].outliagScore = this.outlyingScore - outlyingScore;
            if (isNaN(this.points[index].outliagScore)) {
                debugger
            }
        }
    }
</script>
<script>
    let binType = "leader";
    var startBinGridSize = 20;
    let animateTime = 20;
    /*This is for the tooltip*/
    var div = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);
    /*End tooltip section*/

    //<editor-fold desc="section for display options">
    let optionsBinLeader = ["origPoints", "bins", "triangulations", "mst", "outlyingLinks", "outlyingPoints", "noOutlyingTree", "noOutlyingPoints", "v2Corners", "obtuseV2Corners",
        // "noOutlyingTriangulations",
        "convexHull", "concaveHull", "v1s"];

    function createControlButtons(theContainer, theOptions) {
        let controlButtons = d3.select("#" + theContainer);
        theOptions.forEach(option => {
            controlButtons.append("button")
                .attr("onclick", `toggleDisplay(${option})`)
                .html("Toggle " + option);

        });
    }

    createControlButtons("controlButtons", optionsBinLeader);
    //Display variables
    let dataPointRadius = 6;
    let pointColor = 'steelblue';
    let dataPointOpacity = 0.9;
    let binOpacity = 0.8;
    let origPoints = null;
    let bins = null;
    let triangulations = null;//path
    let mst = null;//path
    let outlyingLinks = null;//path
    let outlyingPoints = null;//circle
    let noOutlyingTree = null;//path
    let noOutlyingPoints = null;//circle
    let runtGraph = null;
    let v2Corners = null;//circle
    let obtuseV2Corners = null;//path
    // let noOutlyingTriangulations = null;//path
    let convexHull = null;//path
    let concaveHull = null;//path
    let v1s = null;//circle

    let svgWidth = 500;
    let svgHeight = 520;
    let scagsvg = d3.select("#scagsvg").attr("width", svgWidth).attr("height", svgHeight),
        normalizedsvg = d3.select("#normalizedsvg").attr("width", svgWidth).attr("height", svgHeight),
        // leaveoutsvg = d3.select("#leaveoutsvg").attr("width", svgWidth).attr("height", svgHeight),
        margins = {left: 20, top: 40, right: 20, bottom: 20},
        padding = 10,
        contentWidth = +scagsvg.attr("width") - margins.left - margins.right - 2 * padding,
        contentHeight = +scagsvg.attr("height") - margins.top - margins.bottom - 2 * padding,
        scaleX = d3.scaleLinear().domain([0, 1]).range([0, contentWidth - 2 * padding]),
        scaleY = d3.scaleLinear().domain([0, 1]).range([0, contentHeight - 2 * padding]);


    // scaleY = d3.scaleLinear().domain([0, 1]).range([0, contentHeight]);
    //</editor-fold>

    const datasets = [];
    const random = Math.random;
    const pi = Math.PI;
    const cos = Math.cos;
    const sin = Math.sin;

    /***********OUTLYING DATA*******************/
    outlyingScatterPlot();

    function outlyingScatterPlot() {
        let randomX = d3.randomNormal(svgWidth / 2, 50),
            randomY = d3.randomNormal(svgHeight / 2, 50),
            points = d3.range(300).map(function () {
                return [randomX(), randomY()];
            });
        //Push 3 more outlying points.
        points.push([svgWidth / 2 + 5 * 50, svgHeight / 2 + 5 * 50]);
        points.push([svgWidth / 2 - 5 * 50, svgHeight / 2 + 5 * 50]);
        points.push([svgWidth / 2 + 5 * 50, svgHeight / 2 - 5 * 50]);
        datasets.push(points);
    }

    /***********SKWED DATA*******************/
    skewedScatterPlot();

    function skewedScatterPlot() {
        let points = [];
        for (let i = 0; i < svgWidth; i = i + svgWidth / 5) {
            for (let j = 0; j < svgHeight; j = j + svgHeight / 5) {
                const randomX = d3.randomNormal(i, svgWidth / 60),
                    randomY = d3.randomNormal(j, svgHeight / 60);
                d3.range(20).forEach(d => {
                    points.push([randomX(), randomY()]);
                });
            }
        }
        datasets.push(points);
    }

    /***********CLUMPY DATA*******************/
    clumpyScatterPlot();

    function clumpyScatterPlot() {
        // let points = [];
        // //Top CENTER points
        // let randomX = d3.randomNormal(svgWidth / 2, 10),
        //     randomY = d3.randomNormal(svgHeight / 4, 10);
        // d3.range(30).map(function () {
        //     points.push([randomX(), randomY()]);
        // });
        //
        // //Bottom left
        // randomX = d3.randomNormal(svgWidth / 4, 15);
        // randomY = d3.randomNormal(3 * svgHeight / 4, 15);
        // d3.range(40).map(function () {
        //     points.push([randomX(), randomY()]);
        // });
        //
        // //Bottom right
        // randomX = d3.randomNormal(3 * svgWidth / 4, 20);
        // randomY = d3.randomNormal(3 * svgHeight / 4, 20);
        // d3.range(100).map(function () {
        //     points.push([randomX(), randomY()]);
        // });
        // datasets.push(points);

        let points = [];
        //Bottom left points
        let randomX = d3.randomNormal(svgWidth / 4, 10),
            randomY = d3.randomNormal(svgHeight / 4, 10);
        d3.range(100).map(function () {
            points.push([10 * randomX(), 10 * randomY()]);
        });

        //Top right
        randomX = d3.randomNormal(3 * svgWidth / 4, 20);
        randomY = d3.randomNormal(3 * svgHeight / 4, 20);
        d3.range(50).map(function () {
            points.push([randomX(), randomY()]);
        });
        datasets.push(points);
    }

    /***********SPARSED DATA*******************/
    sparsedScatterPlot();

    function sparsedScatterPlot() {
        let points = [];
        //Top left points
        let randomX = d3.randomNormal(svgWidth / 4, 3),
            randomY = d3.randomNormal(svgHeight / 4, 3);
        d3.range(20).map(function () {
            points.push([randomX(), randomY()]);
        });
        //Top right
        randomX = d3.randomNormal(3 * svgWidth / 4, 3),
            randomY = d3.randomNormal(svgHeight / 4, 3);
        d3.range(20).map(function () {
            points.push([randomX(), randomY()]);
        });
        //Bottom left
        randomX = d3.randomNormal(svgWidth / 4, 3);
        randomY = d3.randomNormal(3 * svgHeight / 4, 3);
        d3.range(20).map(function () {
            points.push([randomX(), randomY()]);
        });

        //Bottom right
        randomX = d3.randomNormal(3 * svgWidth / 4, 3);
        randomY = d3.randomNormal(3 * svgHeight / 4, 3);
        d3.range(20).map(function () {
            points.push([randomX(), randomY()]);
        });
        datasets.push(points);
    }

    /***********STRIATED DATA*******************/
    striatedScatterPlot();

    function striatedScatterPlot() {
        let points = [];
        for (let i = 0; i < 4; i++) {
            let randomX = d3.randomNormal(i * svgWidth / 4, 0.01),
                randomY = d3.randomUniform(0, svgHeight);
            d3.range(100).map(function () {
                points.push([randomX(), randomY()]);
            });
        }
        datasets.push(points);
    }

    /***********CONVEX DATA*******************/
    convexScatterPlot();

    function convexScatterPlot() {
        let randomX = d3.randomNormal(svgWidth / 2, 50),
            randomY = d3.randomNormal(svgHeight / 2, 50),
            points = d3.range(2000).map(function () {
                return [randomX(), randomY()];
            });
        datasets.push(points);
    }


    /***********SKINNY DATA*******************/
    skinnyScatterPlot();

    function skinnyScatterPlot() {
        let points = [];
        let deg_to_rad = Math.PI / 180.0;
        let depth = 5;
        let branchAngle = 30;
        generateTree(300, 500, -90, depth);
        generateTree(300, 500, 0, depth);
        generateTree(300, 500, 90, depth);
        generateTree(300, 500, 180, depth);

        function generateTree(x1, y1, angle, depth) {
            if (depth !== 0) {
                let x2 = x1 + (Math.cos(angle * deg_to_rad) * depth * 10.0);
                let y2 = y1 + (Math.sin(angle * deg_to_rad) * depth * 10.0);
                points = points.concat(generatePointsOnLine(x1, y1, x2, y2, 4));
                generateTree(x2, y2, angle - branchAngle, depth - 1);
                generateTree(x2, y2, angle + branchAngle, depth - 1);
            }
        }

        function generatePointsOnLine(x1, y1, x2, y2, nPoints) {
            let pointsOL = [];
            if (x1 === x2) {
                let deltaY = (y2 - y1) / nPoints;
                for (let i = 0; i < nPoints; i++) {
                    pointsOL.push([x1 + random(), y1 + i * deltaY + random()])
                }
            } else {
                let a = (y2 - y1) / (x2 - x1);
                let b = -a * x1 + y1;
                let deltaX = (x2 - x1) / nPoints;
                for (let i = 0; i < nPoints; i++) {
                    let x = x1 + i * deltaX;
                    let y = a * x + b;
                    pointsOL.push([x + random(), y + random()]);
                }
            }
            return pointsOL;
        }

        datasets.push(points);
    }

    /***********STRINGY DATA*******************/
    stringyScatterPlot();

    function stringyScatterPlot() {
        let points = [];
        for (let i = 0; i < 100; i++) {
            let x = i * (3 * pi / 100);
            let y = sin(x);
            points.push([x + random() / 100, y + random() / 100]);
        }
        datasets.push(points);
    }

    /***********MONOTONIC DATA*******************/
    monotonicScatterPlot();

    function monotonicScatterPlot() {
        let randomX = d3.randomUniform(0, svgWidth);
        let points = [];
        d3.range(100).forEach(() => {
            const val = randomX();
            points.push([val + random(), val + random()]);
        });
        datasets.push(points);
    }

    /***********X LINE*******************/
    xLineScatterPlot();

    function xLineScatterPlot() {
        let randomY = d3.randomUniform(0, svgWidth);
        let points = [];
        d3.range(100).forEach(() => {
            const val = randomY();
            points.push([1, val]);
        });
        datasets.push(points);
    }

    /***********Y LINE*******************/
    yLineScatterPlot();

    function yLineScatterPlot() {
        let randomX = d3.randomUniform(0, svgWidth);
        let points = [];
        d3.range(100).forEach(() => {
            const val = randomX();
            points.push([val, 1]);
        });
        datasets.push(points);
    }

    let outliagProcessor = null;
    changeDataset(document.getElementById("scagnostics"));
    //Toggle some displays
    toggleDisplay(bins);
    toggleDisplay(triangulations);
    toggleDisplay(obtuseV2Corners);
    // toggleDisplay(noOutlyingTriangulations);
    toggleDisplay(convexHull);
    toggleDisplay(concaveHull);

    function changeDataset(evt) {
        let points = datasets[evt.selectedIndex];
        let options = {
            binType: binType,
            startBinGridSize: startBinGridSize,
            minBins: 4
        }
        // //process outliag score
        // outliagProcessor = new SingleOutliagProcessor(scag.normalizedPoints);
        // outliagProcessor.processOutliagData();
        let scag = scagnostics(points, options);
        update(scag);
    }

    function update(scag) {
        //Clean
        normalizedsvg.selectAll("*").remove();
        scagsvg.selectAll("*").remove();
        // leaveoutsvg.selectAll("*").remove();

        //Drawing results
        drawTitle(normalizedsvg, "Original scatter plot");
        drawTitle(scagsvg, "Bins on original");
        // drawTitle(leaveoutsvg, "Bins on leave-one-out");
        drawContentBound(normalizedsvg);
        drawContentBound(scagsvg);
        // drawContentBound(leaveoutsvg);

        drawNormalizedData(scag);
        draw(scag);
    }

    function drawNormalizedDataSvg(scag, theSvg, opacity) {
        //Add outliag scores as 0 for those doesn't have it
        scag.normalizedPoints.forEach(p => {
            if (!p.outliagScore) {
                p.outliagScore = 0;
            }
        });
        let outlierColor = d3.scaleSequential(d3.interpolateLab("#000", "red"))
            .domain(d3.extent(scag.normalizedPoints.map(p => (p.outliagScore > 0 ? p.outliagScore : 0))));
        let inlierColor = d3.scaleSequential(d3.interpolateLab("green", "#000"))
            .domain(d3.extent(scag.normalizedPoints.map(p => (p.outliagScore < 0 ? p.outliagScore : 0))));

        //Main container
        let g = theSvg.append("g").attr("transform", `translate(${margins.left + 2 * padding}, ${margins.top + padding})`);

        g.append("g").selectAll("circle")
            .data(scag.normalizedPoints)
            .enter()
            .append("circle")
            .attr("cx", d => scaleX(d[0]))
            .attr("cy", d => scaleY(d[1]))
            .attr("r", dataPointRadius)
            .attr("fill", pointColor)
            // .attr("fill", d => {
            //     return d.outliagScore < 0 ? inlierColor(d.outliagScore) : outlierColor(d.outliagScore);
            // })
            .attr("stroke", "none")
            .attr("opacity", opacity)
            /*This is for the tooltip section*/
            .on("mouseover", function (d) {
                div.transition()
                    .duration(200)
                    .style("opacity", .9);
                div.html((d.data ? (d.data.index ? d.data.index : d.data) + ': ' : '') + `[${(d.data ? (d.data.originalPoint ? d.data.originalPoint[0] : d[0]) : d[0]).toFixed(3)}, ${(d.data ? (d.data.originalPoint ? d.data.originalPoint[1] : d[1]) : d[1]).toFixed(3)}]`)
                    .style("left", (d3.event.pageX - 10) + "px")
                    .style("top", (d3.event.pageY - 52) + "px");
            })
            .on("mouseout", function (d) {
                div.transition()
                    .duration(500)
                    .style("opacity", 0);
            });
        // .on("click", d => {
        //     let outliag = outliagProcessor.allOutliags[d.data.index];
        //     drawLeaveOut(outliag);
        // });
        /*End of tooltip section*/
        return g;
    }

    function drawNormalizedData(scag) {
        drawNormalizedDataSvg(scag, normalizedsvg, dataPointOpacity);
    }

    //This method is called in string (creating the button using JS) so though it is displayed as unused => it is used.
    function toggleDisplay(g) {
        if (+d3.select(g.node()).style("opacity") != 10e-6) {
            g.transition().duration(1000).style("opacity", 10e-6).style("display", "none");
        } else {
            animateNodes(g, animateTime, 10e-6, .99);
            g.style("display", "inline");
        }
    }


    function displayScagScores(scag, msgContainer) {
        let msg = "Scagnostics";
        //Binning
        msg += "<br/>0. Bin size: " + scag.binSize + "x" + scag.binSize + " bins" + ", num of bins: " + scag.bins.length;
        //Outlying
        msg += "<br/>1. Outlying score: " + scag.outlyingScore + ", outlying edge cut point: " + scag.outlyingUpperBound;
        //Skewed
        msg += "<br/>2. Skewed score: " + scag.skewedScore;
        //Sparse
        msg += "<br/>3. Sparse score: " + scag.sparseScore;
        //Clumpy
        msg += "<br/>4. Clumpy score: " + scag.clumpyScore;
        //Striated
        msg += "<br/>5. Striated score: " + scag.striatedScore;
        //Convex
        msg += "<br/>6. Convex score: " + scag.convexScore;
        //Skinny
        msg += "<br/>7. Skinny score: " + scag.skinnyScore;
        //Stringy
        msg += "<br/>8. Stringy score: " + scag.stringyScore;
        //Monotonic
        msg += "<br/>9. Monotonic score: " + scag.monotonicScore;
        //Set the scagnostics message
        d3.select("#" + msgContainer).html(msg);
    }

    function animateNodes(selection, time, fromOpacity, toOpacity, onEnd) {
        recurseDisplay(selection, 0, time, fromOpacity, toOpacity, onEnd);

        function recurseDisplay(selection, i, time, fromOpacity, toOpacity) {
            let nodes = selection.nodes();
            let length = nodes.length;
            if (i < length) {
                d3.select(nodes[i]).style("opacity", fromOpacity).transition().duration(time).style("opacity", toOpacity);
                i = i + 1;
                //recurse
                setTimeout(() => {
                    recurseDisplay(selection, i, time, fromOpacity, toOpacity, onEnd);
                }, time);
            } else {
                if (onEnd) {
                    onEnd();
                }
            }
        }
    }


    function drawMst(g, scag) {
        let mstLinks = scag.mst.links.sort((a, b) => a.weight - b.weight);
        let mst = g.append("g").selectAll("path")
            .data(mstLinks)
            .enter()
            .append("line")
            .attr("x1", d => scaleX(d.source[0]))
            .attr("y1", d => scaleY(d.source[1]))
            .attr("x2", d => scaleX(d.target[0]))
            .attr("y2", d => scaleY(d.target[1]))
            .attr("stroke", "green")
            .attr("stroke-width", 2)
            .attr("opacity", 10e-6)
            .style("display", "none");
        return mst;
    }

    function drawOutlyingLinks(g, scag) {
        return g.append("g").selectAll("path")
            .data(scag.outlyingLinks)
            .enter()
            .append("line")
            .attr("x1", d => scaleX(d.source[0]))
            .attr("y1", d => scaleY(d.source[1]))
            .attr("x2", d => scaleX(d.target[0]))
            .attr("y2", d => scaleY(d.target[1]))
            .attr("stroke", "red")
            .attr("stroke-width", 2)
            .attr("opacity", 10e-6)
            .style("display", "none");
    }

    function drawOutlyingPoints(g, scag) {
        return g.append("g").selectAll("circle")
            .data(scag.outlyingPoints)
            .enter()
            .append("circle")
            .attr("cx", d => scaleX(d[0]))
            .attr("cy", d => scaleY(d[1]))
            .attr("r", dataPointRadius)
            .attr("fill", "black")
            .attr("stroke-width", 2)
            .attr("stroke", "red")
            .attr("opacity", 10e-6)
            .style("display", "none");
    }

    function drawNoOutlyingPoints(g, scag) {
        return g.append("g").selectAll("circle")
            .data(scag.noOutlyingTree.nodes.map(n => n.id))
            .enter()
            .append("circle")
            .attr("cx", d => scaleX(d[0]))
            .attr("cy", d => scaleY(d[1]))
            .attr("r", 3)
            .attr("fill", "black")
            .attr("fill-opacity", dataPointOpacity)
            .attr("stroke", "none")
            .attr("opacity", 10e-6)
            .style("display", "none");
    }

    function drawScores(g, scag) {
        return g.append("g").selectAll("text")
            .data([{type: 'Outlying score', score: scag.outlyingScore}])
            .enter()
            .append("text")
            .text(d => d.type + ": " + d.score.toFixed(3))
            .attr("x", 10)
            .attr("y", 10);
    }

    function draw(scag) {
        //Main container
        let g = scagsvg.append("g").attr("transform", `translate(${margins.left + 2 * padding}, ${margins.top + padding})`);
        //Original points
        origPoints = drawNormalizedDataSvg(scag, scagsvg, 0.9);
        // drawScores(g, scag);
        var color = d3.scaleSequential(d3.interpolateLab("#EEEEEE", "#000"))
            .domain(d3.extent(scag.bins.map(b => b.length)));

        if (scag.binner) {
            if (binType === "hexagon") {
                bins = g.append("g")
                    .attr("class", "hexagon")
                    .selectAll("path")
                    .data(scag.bins)
                    .enter().append("path")
                    .attr("d", scag.binner.hexagon(scaleX(scag.binRadius)))
                    .attr("transform", function (d) {
                        return "translate(" + scaleX(d.x) + "," + scaleY(d.y) + ")";
                    })
                    .attr("fill-opacity", 1)
                    .attr("fill", d => color(d.length));
            } else {
                //sort the scag bins by x first then by y
                let scagBins = scag.bins.sort((a, b) => (a.x - b.x != 0) ? a.x - b.x : a.y - b.y);
                bins = g.append("g")
                    .attr("class", "leader")
                    .selectAll("circle")
                    .data(scagBins)
                    .enter().append("circle")
                    // .attr("r", scaleX(scag.binRadius))
                    .attr("r", d => {
                        let distances = d.map(p => distance([d.x, d.y], p));
                        let radius = d3.max(distances);
                        return radius === 0 ? dataPointRadius : scaleX(radius);
                    })
                    .attr("cx", d => scaleX(d.x))
                    .attr("cy", d => scaleY(d.y))
                    .attr("fill", d => color(d.length))
                    // .attr("fill", "none")
                    .attr("stroke", "black")
                    .attr("opacity", binOpacity)
                    .attr("display", "none")
                    .attr("stroke-width", 0.5);

                function distance(a, b) {
                    let dx = a[0] - b[0],
                        dy = a[1] - b[1];
                    //For computer storage issue, some coordinates of the same distance may return different distances if we use long floating point
                    //So take only 10 digits after the floating points=> this is precise enough and still have the same values for two different lines of the same distance
                    return Math.round(Math.sqrt((dx * dx) + (dy * dy)) * Math.pow(10, 10)) / Math.pow(10, 10);
                }
            }
        }
        //Triangulating
        triangulations = g.append("g")
            .attr("class", "triangles")
            .selectAll("path")
            .data(scag.triangleCoordinates)
            .enter()
            .append("path")
            .attr("opacity", 10e-6)
            .style("display", "none")
            .call(drawTriangle);

        function drawTriangle(triangle) {
            triangle.attr("d", d => "M" + d.map(p => [scaleX(p[0]), scaleY(p[1])]).join("L") + "Z");
        }

        //Minimum spanning tree.
        mst = drawMst(g, scag);

        //Minimum spanning tree.
        //Outlying links
        outlyingLinks = drawOutlyingLinks(g, scag);
        //Outlying points
        outlyingPoints = drawOutlyingPoints(g, scag);
        //No outlying tree
        noOutlyingTree = g.append("g").selectAll("path")
            .data(scag.noOutlyingTree.links)
            .enter()
            .append("line")
            .attr("x1", d => scaleX(d.source[0]))
            .attr("y1", d => scaleY(d.source[1]))
            .attr("x2", d => scaleX(d.target[0]))
            .attr("y2", d => scaleY(d.target[1]))
            .attr("stroke", "green")
            .attr("stroke-width", 4).on("click", l => {
                if (runtGraph) runtGraph.remove();
                let rg = scag.clumpy.runtGraph(l);
                runtGraph = g.append("g").selectAll("path")
                    .data(rg)
                    .enter()
                    .append("line")
                    .attr("x1", d => scaleX(d.source[0]))
                    .attr("y1", d => scaleY(d.source[1]))
                    .attr("x2", d => scaleX(d.target[0]))
                    .attr("y2", d => scaleY(d.target[1]))
                    .attr("stroke", "red")
                    .attr("stroke-width", 2);
            })
            .attr("opacity", 10e-6)
            .style("display", "none");
        noOutlyingPoints = drawNoOutlyingPoints(g, scag);
        //Striated
        //ObtuseV2Corners
        obtuseV2Corners = g.append("g").selectAll("path")
            .data(scag.obtuseV2Corners)
            .enter()
            .append("path")
            .attr("d", d => {
                //Clone the data to avoid changing it
                let d1 = d.splice(0);
                //swap since we need to start drawing from the point which is not the vertex of the corner (first point).
                let temp = d1[0];
                d1[0] = d1[1];
                d1[1] = temp;
                d1 = d1.map(d => [scaleX(d[0]), scaleY(d[1])]);
                return "M" + d1.join("L");
            })
            .attr("fill", "none")
            .attr("stroke", "orange")
            .attr("stroke-width", 2)
            .attr("opacity", 10e-6)
            .style("display", "none");

        //V2 corners
        v2Corners = g.append("g").selectAll("circle")
            .data(scag.v2Corners)
            .enter()
            .append("circle")
            .attr("cx", d => scaleX(d[0][0]))
            .attr("cy", d => scaleY(d[0][1]))
            .attr("r", 3)
            .attr("stroke", "none")
            .attr("fill", "violet")
            .attr("opacity", 10e-6)
            .style("display", "none");


        // //Triangulating
        // noOutlyingTriangulations = g.append("g")
        //     .attr("class", "triangles")
        //     .selectAll("path")
        //     .data(scag.noOutlyingTriangleCoordinates)
        //     .enter()
        //     .append("path")
        //     .call(drawTriangle)
        //     .attr("opacity", 10e-6)
        //     .style("display", "none");

        //Convex hull
        convexHull = g.append("g").selectAll("path")
            .data([scag.convexHull.map(d => [scaleX(d[0]), scaleY(d[1])])])
            .enter()
            .append("path")
            .attr("d", d => "M" + d.join("L") + "Z")
            .attr("stroke-width", 3)
            .attr("stroke", "blue")
            .attr("fill", "none")
            .attr("opacity", 10e-6)
            .style("display", "none");

        //Concave hull
        concaveHull = g.append("g")
            .selectAll("path")
            .data(scag.concaveHull)
            .enter()
            .append("path")
            .attr("d", d => "M" + d.map(p => [scaleX(p[0]), scaleY(p[1])]).join("L") + "Z")
            .attr("stroke-width", 2)
            .attr("stroke", "green")
            .attr("fill", "none")
            .attr("opacity", 10e-6)
            .style("display", "none");

        //Stringy => single degree vertices
        v1s = g.append("g")
            .selectAll("circle")
            .data(scag.v1s)
            .enter()
            .append("circle")
            .attr("cx", d => scaleX(d[0]))
            .attr("cy", d => scaleY(d[1]))
            .attr("r", 3)
            .attr("stroke", "none")
            .attr("fill", "yellow")
            .attr("opacity", 10e-6)
            .style("display", "none");
        //Scagnostics messages
        let msgContainer = "msg";
        displayScagScores(scag, msgContainer);
    }

    function drawLeaveOut(outliag) {
        leaveoutsvg.selectAll("*").remove();
        drawTitle(leaveoutsvg);
        drawAxis(leaveoutsvg, ["one", "two"]);
        drawContentBound(leaveoutsvg);
        //Main container
        let g = leaveoutsvg.append("g").attr("class", "leaveoutg").attr("transform", `translate(${margins.left + padding}, ${margins.top + padding})`);
        if (!outliag) {
            g.append("text").text("Skipped this calculation, please see the MST on the left").attr("x", 10).attr("y", 10);
        } else {
            let mst = drawMst(g, outliag);
            let outlyingLinks = drawOutlyingLinks(g, outliag);
            let outlyingPoints = drawOutlyingPoints(g, outliag);
            let noOutlyingPoints = drawNoOutlyingPoints(g, outliag);
            drawScores(g, outliag);
            mst.style("display", "inline");
            outlyingLinks.style("display", "inline");
            outlyingPoints.style("display", "inline");
            noOutlyingPoints.style("display", "inline");

            animateNodes(mst, animateTime, 10e-6, .8, () => {
                animateNodes(outlyingLinks, animateTime, 10e-6, .8, () => {
                    animateNodes(outlyingPoints, animateTime, 10e-6, .8, () => {
                        animateNodes(noOutlyingPoints, animateTime, 10e-6, .8);
                    });
                });
            });
        }
    }

    function drawAxis(svg, variables) {
        let v1 = variables[0];
        let v2 = variables[1];
        let x1 = +svg.attr("width") / 2;
        let y1 = +svg.attr("height") - margins.bottom / 2;
        let x2 = margins.left / 2;
        let y2 = svgHeight / 2;
        svg.append("text").text(v1).attr("font-style", "italic").attr("alignment-baseline", "middle").attr("text-anchor", "middle").attr("transform", `translate(${x1}, ${y1}) rotate(0)`);
        svg.append("text").text(v2).attr("font-style", "italic").attr("alignment-baseline", "middle").attr("text-anchor", "middle").attr("transform", `translate(${x2}, ${y2}) rotate(-90)`);
    }

    function drawTitle(svg, title) {
        let x = +svg.attr("width") / 2;
        let y = margins.top / 2;
        svg.append('text').text(title).attr("font-weight", "bold").attr("alignment-baseline", "middle").attr("text-anchor", "middle").attr("transform", `translate(${x}, ${y}) rotate(0)`);
    }

    function drawContentBound(svg) {
        let x = margins.left;
        let y = margins.top;
        let rectWidth = +svg.attr("width") - margins.left - margins.right;
        let rectHeight = +svg.attr("height") - margins.top - margins.bottom;
        svg.append("rect").attr("x", x).attr("y", y).attr("width", rectWidth).attr("height", rectHeight).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "#ddd");
    }
</script>

</body>
</html>