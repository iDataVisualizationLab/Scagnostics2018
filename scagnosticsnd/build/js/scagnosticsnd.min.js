(function () {
	'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var underscore = createCommonjsModule(function (module, exports) {
	//     Underscore.js 1.9.1
	//     http://underscorejs.org
	//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` (`self`) in the browser, `global`
	  // on the server, or `this` in some virtual machines. We use `self`
	  // instead of `window` for `WebWorker` support.
	  var root = typeof self == 'object' && self.self === self && self ||
	            typeof commonjsGlobal == 'object' && commonjsGlobal.global === commonjsGlobal && commonjsGlobal ||
	            this ||
	            {};

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
	  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

	  // Create quick reference variables for speed access to core prototypes.
	  var push = ArrayProto.push,
	      slice = ArrayProto.slice,
	      toString = ObjProto.toString,
	      hasOwnProperty = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var nativeIsArray = Array.isArray,
	      nativeKeys = Object.keys,
	      nativeCreate = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for their old module API. If we're in
	  // the browser, add `_` as a global object.
	  // (`nodeType` is checked to ensure that `module`
	  // and `exports` are not HTML elements.)
	  if (!exports.nodeType) {
	    if (!module.nodeType && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.9.1';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      // The 2-argument case is omitted because we’re not using it.
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  var builtinIteratee;

	  // An internal function to generate callbacks that can be applied to each
	  // element in a collection, returning the desired result — either `identity`,
	  // an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
	    return _.property(value);
	  };

	  // External wrapper for our callback generator. Users may customize
	  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
	  // This abstraction hides the internal-only argCount argument.
	  _.iteratee = builtinIteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // Some functions take a variable number of arguments, or a few expected
	  // arguments at the beginning and then a variable number of values to operate
	  // on. This helper accumulates all remaining arguments past the function’s
	  // argument length (or an explicit `startIndex`), into an array that becomes
	  // the last argument. Similar to ES6’s "rest parameter".
	  var restArguments = function(func, startIndex) {
	    startIndex = startIndex == null ? func.length - 1 : +startIndex;
	    return function() {
	      var length = Math.max(arguments.length - startIndex, 0),
	          rest = Array(length),
	          index = 0;
	      for (; index < length; index++) {
	        rest[index] = arguments[index + startIndex];
	      }
	      switch (startIndex) {
	        case 0: return func.call(this, rest);
	        case 1: return func.call(this, arguments[0], rest);
	        case 2: return func.call(this, arguments[0], arguments[1], rest);
	      }
	      var args = Array(startIndex + 1);
	      for (index = 0; index < startIndex; index++) {
	        args[index] = arguments[index];
	      }
	      args[startIndex] = rest;
	      return func.apply(this, args);
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var shallowProperty = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  var has = function(obj, path) {
	    return obj != null && hasOwnProperty.call(obj, path);
	  };

	  var deepGet = function(obj, path) {
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      if (obj == null) return void 0;
	      obj = obj[path[i]];
	    }
	    return length ? obj : void 0;
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object.
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = shallowProperty('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  var createReduce = function(dir) {
	    // Wrap code that reassigns argument variables in a separate function than
	    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
	    var reducer = function(obj, iteratee, memo, initial) {
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      if (!initial) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    };

	    return function(obj, iteratee, memo, context) {
	      var initial = arguments.length >= 3;
	      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
	    };
	  };

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
	    var key = keyFinder(obj, predicate, context);
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = restArguments(function(obj, path, args) {
	    var contextPath, func;
	    if (_.isFunction(path)) {
	      func = path;
	    } else if (_.isArray(path)) {
	      contextPath = path.slice(0, -1);
	      path = path[path.length - 1];
	    }
	    return _.map(obj, function(context) {
	      var method = func;
	      if (!method) {
	        if (contextPath && contextPath.length) {
	          context = deepGet(context, contextPath);
	        }
	        if (context == null) return void 0;
	        method = context[path];
	      }
	      return method == null ? method : method.apply(context, args);
	    });
	  });

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value != null && value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(v, index, list) {
	        computed = iteratee(v, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = v;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection.
	  _.shuffle = function(obj) {
	    return _.sample(obj, Infinity);
	  };

	  // Sample **n** random values from a collection using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
	    var length = getLength(sample);
	    n = Math.max(Math.min(n, length), 0);
	    var last = length - 1;
	    for (var index = 0; index < n; index++) {
	      var rand = _.random(index, last);
	      var temp = sample[index];
	      sample[index] = sample[rand];
	      sample[rand] = temp;
	    }
	    return sample.slice(0, n);
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    var index = 0;
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, key, list) {
	      return {
	        value: value,
	        index: index++,
	        criteria: iteratee(value, key, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior, partition) {
	    return function(obj, iteratee, context) {
	      var result = partition ? [[], []] : {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (has(result, key)) result[key]++; else result[key] = 1;
	  });

	  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (_.isString(obj)) {
	      // Keep surrogate pair characters together
	      return obj.match(reStrSymbol);
	    }
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = group(function(result, value, pass) {
	    result[pass ? 0 : 1].push(value);
	  }, true);

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null || array.length < 1) return n == null ? void 0 : [];
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, Boolean);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, output) {
	    output = output || [];
	    var idx = output.length;
	    for (var i = 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        // Flatten current level of array or arguments object.
	        if (shallow) {
	          var j = 0, len = value.length;
	          while (j < len) output[idx++] = value[j++];
	        } else {
	          flatten(value, shallow, strict, output);
	          idx = output.length;
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = restArguments(function(array, otherArrays) {
	    return _.difference(array, otherArrays);
	  });

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // The faster algorithm will not work with an iteratee if the iteratee
	  // is not a one-to-one function, so providing an iteratee will disable
	  // the faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted && !iteratee) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = restArguments(function(arrays) {
	    return _.uniq(flatten(arrays, true, true));
	  });

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      var j;
	      for (j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = restArguments(function(array, rest) {
	    rest = flatten(rest, true, true);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  });

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices.
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = restArguments(_.unzip);

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values. Passing by pairs is the reverse of _.pairs.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions.
	  var createPredicateIndexFinder = function(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  };

	  // Returns the first index on an array-like that passes a predicate test.
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions.
	  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	          i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  };

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    if (!step) {
	      step = stop < start ? -1 : 1;
	    }

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Chunk a single array into multiple arrays, each containing `count` or fewer
	  // items.
	  _.chunk = function(array, count) {
	    if (count == null || count < 1) return [];
	    var result = [];
	    var i = 0, length = array.length;
	    while (i < length) {
	      result.push(slice.call(array, i, i += count));
	    }
	    return result;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments.
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = restArguments(function(func, context, args) {
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var bound = restArguments(function(callArgs) {
	      return executeBound(func, bound, context, this, args.concat(callArgs));
	    });
	    return bound;
	  });

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder by default, allowing any combination of arguments to be
	  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
	  _.partial = restArguments(function(func, boundArgs) {
	    var placeholder = _.partial.placeholder;
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  });

	  _.partial.placeholder = _;

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = restArguments(function(obj, keys) {
	    keys = flatten(keys, false, false);
	    var index = keys.length;
	    if (index < 1) throw new Error('bindAll must be passed function names');
	    while (index--) {
	      var key = keys[index];
	      obj[key] = _.bind(obj[key], obj);
	    }
	  });

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = restArguments(function(func, wait, args) {
	    return setTimeout(function() {
	      return func.apply(null, args);
	    }, wait);
	  });

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var timeout, context, args, result;
	    var previous = 0;
	    if (!options) options = {};

	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };

	    var throttled = function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };

	    throttled.cancel = function() {
	      clearTimeout(timeout);
	      previous = 0;
	      timeout = context = args = null;
	    };

	    return throttled;
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, result;

	    var later = function(context, args) {
	      timeout = null;
	      if (args) result = func.apply(context, args);
	    };

	    var debounced = restArguments(function(args) {
	      if (timeout) clearTimeout(timeout);
	      if (immediate) {
	        var callNow = !timeout;
	        timeout = setTimeout(later, wait);
	        if (callNow) result = func.apply(this, args);
	      } else {
	        timeout = _.delay(later, wait, this, args);
	      }

	      return result;
	    });

	    debounced.cancel = function() {
	      clearTimeout(timeout);
	      timeout = null;
	    };

	    return debounced;
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  _.restArguments = restArguments;

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  var collectNonEnumProps = function(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  };

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`.
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object.
	  // In contrast to _.map it returns an object.
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = _.keys(obj),
	        length = keys.length,
	        results = {};
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys[index];
	      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  // The opposite of _.object.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`.
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, defaults) {
	    return function(obj) {
	      var length = arguments.length;
	      if (defaults) obj = Object(obj);
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!defaults || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s).
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test.
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Internal pick helper function to determine if `obj` has key `key`.
	  var keyInObj = function(value, key, obj) {
	    return key in obj;
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = restArguments(function(obj, keys) {
	    var result = {}, iteratee = keys[0];
	    if (obj == null) return result;
	    if (_.isFunction(iteratee)) {
	      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
	      keys = _.allKeys(obj);
	    } else {
	      iteratee = keyInObj;
	      keys = flatten(keys, false, false);
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  });

	  // Return a copy of the object without the blacklisted properties.
	  _.omit = restArguments(function(obj, keys) {
	    var iteratee = keys[0], context;
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	      if (keys.length > 1) context = keys[1];
	    } else {
	      keys = _.map(flatten(keys, false, false), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  });

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq, deepEq;
	  eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // `null` or `undefined` only equal to itself (strict comparison).
	    if (a == null || b == null) return false;
	    // `NaN`s are equivalent, but non-reflexive.
	    if (a !== a) return b !== b;
	    // Exhaust primitive checks
	    var type = typeof a;
	    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
	    return deepEq(a, b, aStack, bStack);
	  };

	  // Internal recursive comparison function for `isEqual`.
	  deepEq = function(a, b, aStack, bStack) {
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN.
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	      case '[object Symbol]':
	        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
	  var nodelist = root.document && root.document.childNodes;
	  if (typeof Int8Array != 'object' && typeof nodelist != 'function') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`?
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && isNaN(obj);
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, path) {
	    if (!_.isArray(path)) {
	      return has(obj, path);
	    }
	    var length = path.length;
	    for (var i = 0; i < length; i++) {
	      var key = path[i];
	      if (obj == null || !hasOwnProperty.call(obj, key)) {
	        return false;
	      }
	      obj = obj[key];
	    }
	    return !!length;
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  // Creates a function that, when passed an object, will traverse that object’s
	  // properties down the given `path`, specified as an array of keys or indexes.
	  _.property = function(path) {
	    if (!_.isArray(path)) {
	      return shallowProperty(path);
	    }
	    return function(obj) {
	      return deepGet(obj, path);
	    };
	  };

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    if (obj == null) {
	      return function(){};
	    }
	    return function(path) {
	      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	  // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped.
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // Traverses the children of `obj` along `path`. If a child is a function, it
	  // is invoked with its parent as context. Returns the value of the final
	  // child, or `fallback` if any child is undefined.
	  _.result = function(obj, path, fallback) {
	    if (!_.isArray(path)) path = [path];
	    var length = path.length;
	    if (!length) {
	      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
	    }
	    for (var i = 0; i < length; i++) {
	      var prop = obj == null ? void 0 : obj[path[i]];
	      if (prop === void 0) {
	        prop = fallback;
	        i = length; // Ensure we don't continue iterating.
	      }
	      obj = _.isFunction(prop) ? prop.call(obj) : prop;
	    }
	    return obj;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate: /<%([\s\S]+?)%>/g,
	    interpolate: /<%=([\s\S]+?)%>/g,
	    escape: /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'": "'",
	    '\\': '\\',
	    '\r': 'r',
	    '\n': 'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offset.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    var render;
	    try {
	      render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var chainResult = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return chainResult(this, func.apply(_, args));
	      };
	    });
	    return _;
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return chainResult(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return chainResult(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return String(this._wrapped);
	  };
	}());
	});
	var underscore_1 = underscore._;

	class Normalizer {
	    constructor(points) {
	        this.points = points.map(e=>e.slice());
	        //pass the data over
	        this.points.forEach((p, i)=>{
	            p.data = points[i].data;
	        });
	        let nds = this.nds = underscore.unzip(this.points);
	        let maxD = this.maxD = [];
	        let minD = this.minD = [];
	        let rangeD = this.rangeD = [];
	        let normalizedD = this.normalizedD = [];
	        nds.forEach((d, i)=>{
	            maxD[i] = underscore.max(d);
	            minD[i] = underscore.min(d);
	            rangeD[i] = (maxD[i] != minD[i]) ? maxD[i] - minD[i] : 1;
	            normalizedD[i] = d.map(e=>(e-minD[i])/rangeD[i]);
	        });
	        let length = this.points.length;
	        this.normalizedPoints = [];
	        for (let i = 0; i < length; i++) {
	            this.normalizedPoints[i] = [];
	            for (let j = 0; j < this.nds.length; j++) {
	                this.normalizedPoints[i][j] = normalizedD[j][i];
	            }
	        }
	        //Add one step to pass the data over if there is.
	        for (let i = 0; i < length; i++) {
	            this.normalizedPoints[i].data = this.points[i].data;
	        }
	    }

	    /**
	     * Input a set of points in this scale range [0, 1] and will be scaled back to
	     * - Original scale ([minX, maxX], [minY, maxY], [minZ, maxZ])
	     * @param points
	     */
	    scaleBackPoints(points) {
	        return points.map(point => {
	            return this.scaleBackPoint(point);
	        });
	    }

	    /**
	     * Input a single point in this scale range [0, 1] and will be scaled back to
	     * - Original scale ([minX, maxX], [minY, maxY], [minZ, maxZ])
	     * @param points
	     */
	    scaleBackPoint(point) {
	        let newPoint = point.map((vs, i)=>{
	            let v = this.rangeD[i]*vs + this.minD[i];
	            return v;
	        });
	        return newPoint;
	    }
	}

	class LeaderBinner {
	    constructor(points, radius) {
	        //TODO: Should check if there are more than 3 unique values here or even after the binning.
	        //TODO: May need to clone the points to avoid modifying it, but we don't do to reserve other data or to make the process faster
	        // //Clone these to avoid modifying them
	        // this.points = points.map(p=>p.slice(0));
	        this.points = points;
	        this.radius = radius;
	    }

	    get leaders() {
	        let self = this;
	        let theLeaders = [];
	        //find all the leaders
	        this.points.forEach(point => {
	            let leader = closestLeader(theLeaders, point);
	            if (!leader) {
	                let newLeader = [];
	                newLeader.site = point.slice();
	                theLeaders.push(newLeader);
	            }
	        });
	        //now do this again to set the closest leader.
	        this.points.forEach(point => {
	            let leader = closestLeader(theLeaders, point);
	            leader.push(point);
	        });
	        return theLeaders;

	        function closestLeader(leaders, point) {
	            let length = leaders.length;
	            let minDistance = Number.MAX_SAFE_INTEGER;
	            let theLeader = null;
	            for (let i = 0; i < length; ++i) {
	                let l = leaders[i];
	                let d = distance(l.site, point);
	                if (d < self.radius) {
	                    if (d < minDistance) {
	                        minDistance = d;
	                        theLeader = l;
	                    }
	                }
	            }
	            return theLeader;
	        }
	    }
	}

	function distance(a, b) {
	    let sumsquared = 0;
	    for (let i = 0; i < a.length; i++) {
	        let d = a[i] - b[i];
	        if(!Number.isNaN(d)){
	            sumsquared += d*d;
	        }
	    }
	    //For computer storage issue, some coordinates of the same distance may return different distances if we use long floating point
	    //So take only 10 digits after the floating points=> this is precise enough and still have the same values for two different lines of the same distance
	    return Math.round(Math.sqrt(sumsquared) * Math.pow(10, 10)) / Math.pow(10, 10);
	}

	// https://gist.github.com/bmershon/25a74f7b1c7cbd07e7456af1d2c07da1

	/**
	 * This function create the pairs between node and its links.
	 *
	 * @param links
	 * @returns [["nodeX,nodeY": Array(numberOfLinksRelatedToTheNodes)]]
	 */
	function pairNodeLinks(links) {
	    let nestedByNodes = {};
	    links.forEach(l => {
	        let sourceKey = l.source.join(',');
	        if (!nestedByNodes[sourceKey]) {
	            nestedByNodes[sourceKey] = [];
	        }
	        nestedByNodes[sourceKey].push(l);
	        let targetKey = l.target.join(',');
	        if (!nestedByNodes[targetKey]) {
	            nestedByNodes[targetKey] = [];
	        }
	        nestedByNodes[targetKey].push(l);
	    });
	    //Pair the results
	    let pairedResults = underscore.pairs(nestedByNodes);
	    return pairedResults;
	}

	/**
	 * This function returns corners (three vertices) of vertices of degree two in the for mat of
	 * point1, point2, point3 => point1 is the the vertex with degree two (two edges connected to it are [point1, point2] and [point1, point3] (order of the points in each edge is not important)).
	 * @param tree
	 * @returns {*}
	 */
	function getAllV2CornersFromTree(tree) {
	    let pairedResults = pairNodeLinks(tree.links);
	    //Get all pairs with length = 2 (V2)
	    let allV2 = pairedResults.filter(p => p[1].length == 2);

	    let allCorners = allV2.map(v2 => {
	        let corner = [];
	        //First point is the common vertice
	        corner.push(v2[0].split(',').map(d => +d));//map(d=>+d) is to convert the strings into digits
	        //Push the source or target if they are not the common vertices of the two edges
	        v2[1].forEach(link => {
	            if (link.source.join(',') != v2[0]) {
	                corner.push(link.source);
	            } else {
	                corner.push(link.target);
	            }
	        });
	        return corner;
	    });
	    return allCorners;
	}
	/**
	 * This function returns all vertices with degree greater than or equal 2
	 * @param tree
	 */
	function getAllV2OrGreaterFromTree(tree) {
	    let pairedResults = pairNodeLinks(tree.links);
	    //Get all pairs with length >= 2 (V2)
	    let allGTEV2 = pairedResults.filter(p => p[1].length >= 2);
	    return allGTEV2.map(v => v[0].split(',').map(Number));
	}
	/**
	 * This function returns all single degree vertices from a tree
	 * @param tree
	 */
	function getAllV1sFromTree(tree) {
	    let pairedResults = pairNodeLinks(tree.links);
	    //Get all pairs with length = 1 (V1)
	    let allV1 = pairedResults.filter(p => p[1].length == 1);
	    return allV1.map(v1 => v1[0].split(',').map(Number));
	}

	/**
	 * Create a graph from mesh
	 * @param triangles is inform of set of triangles as the result from delaunay triangulations
	 */
	function createGraph(tetrahedra, weights) {

	    function makeLink(sourceId, targetId, weight) {
	        return {"source": sourceId, "target": targetId, "weight": weight};
	    }

	    let graph = {};
	    graph.nodes = [];
	    graph.links = [];
	    //Creating nodes
	    tetrahedra.forEach(t => {
	        t.forEach(id => {
	            if (!idExists(graph.nodes, id)) {
	                graph.nodes.push(makeNode(id));
	            }
	        });
	    });

	    //Creating links
	    tetrahedra.forEach(t => {
	        for (let i = 0; i < t.length - 1; i++) {
	            let p1 = t[i];
	            for (let j = i + 1; j < t.length; j++) {
	                let p2 = t[j];
	                let id1 = p1;
	                let id2 = p2;
	                let dist = distance$1(p1, p2, weights);
	                let link = makeLink(id1, id2, dist);
	                if (!linkExists(graph.links, link)) {
	                    graph.links.push(link);
	                }
	            }
	        }
	    });

	    //TODO: may sort the id alphabetically => when creating => so we can just check 1 condition only.
	    function linkExists(links, link) {
	        let length = links.length;
	        for (let i = length - 1; i >= 0; --i) {
	            if (equalLinks(link, links[i])) {
	                return true;
	            }
	        }
	        return false;
	    }
	    return graph;
	}

	function distance$1(a, b, weights) {
	    let totalSumSquared = 0;
	    if (!weights) {
	        for (let i = 0; i < a.length; i++) {
	            let diff = (a[i] - b[i]) * (a[i] - b[i]);
	            if (!Number.isNaN(diff)) {
	                totalSumSquared += diff;
	            }
	        }
	    } else {
	        for (let i = 0; i < a.length; i++) {
	            let diff = (a[i] - b[i]) * (a[i] - b[i]);
	            if (!Number.isNaN(diff)) {
	                totalSumSquared += diff * weights[i];
	            }
	        }
	    }
	//For computer storage issue, some coordinates of the same distance may return different distances if we use long floating point
	//So take only 10 digits after the floating points=> this is precise enough and still have the same values for two different lines of the same distance
	    return Math.round(Math.sqrt(totalSumSquared) * Math.pow(10, 10)) / Math.pow(10, 10);
	}

	function equalPoints(id1, id2) {
	    for (let i = 0; i < id1.length; i++) {
	        if (id1[i] !== id2[i]) {
	            return false;
	        }
	    }
	    return true;
	}

	function pointExists(points, point) {
	    for (let i = 0; i < points.length; i++) {
	        let point1 = points[i];
	        if (equalPoints(point1, point)) {
	            return true;
	        }
	    }
	    return false;
	}

	function equalLinks(l1, l2) {
	    return (equalPoints(l1.source, l2.source) && equalPoints(l1.target, l2.target)) ||
	        (equalPoints(l1.source, l2.target) && equalPoints(l1.target, l2.source));
	}

	function idExists(nodes, id) {
	    let length = nodes.length;
	    for (let i = length - 1; i >= 0; --i) {
	        let node = nodes[i];
	        if (equalPoints(node.id, id)) {
	            return true;
	        }
	    }
	    return false;
	}

	function makeNode(id) {
	    return {"id": id};
	}

	/**
	 * create the mst
	 * @param graph: in form of nodes and links
	 * @returns {{nodes: (selection_nodes|nodes), links: Array}}
	 */
	function mst(graph) {
	    let vertices = graph.nodes,
	        edges = graph.links.slice(0),
	        selectedEdges = [],
	        forest = new DisjointSet();

	    // Each vertex begins "disconnected" and isolated from all the others.
	    vertices.forEach((vertex) => {
	        forest.makeSet(vertex.id);
	    });

	    // Sort edges in descending order of weight. We will pop edges beginning
	    // from the end of the array.
	    edges.sort((a, b) => {
	        return -(a.weight - b.weight);
	    });

	    while (edges.length && forest.size() > 1) {
	        let edge = edges.pop();

	        if (forest.find(edge.source) !== forest.find(edge.target)) {
	            forest.union(edge.source, edge.target);
	            selectedEdges.push(edge);
	        }
	    }

	    return {
	        nodes: vertices,
	        links: selectedEdges
	    }
	}

	//<editor-fold desc="This section is for the disjoint set">
	function DisjointSet() {
	    this.index_ = {};
	}

	function Node(id) {
	    this.id_ = id;
	    this.parent_ = this;
	    this.rank_ = 0;
	}

	DisjointSet.prototype.makeSet = function (id) {
	    if (!this.index_[id]) {
	        let created = new Node(id);
	        this.index_[id] = created;
	    }
	};

	// Returns the id of the representative element of this set that (id)
	// belongs to.
	DisjointSet.prototype.find = function (id) {
	    if (this.index_[id] === undefined) {
	        return undefined;
	    }

	    let current = this.index_[id].parent_;
	    while (current !== current.parent_) {
	        current = current.parent_;
	    }
	    return current.id_;
	};

	DisjointSet.prototype.union = function (x, y) {
	    let xRoot = this.index_[this.find(x)];
	    let yRoot = this.index_[this.find(y)];

	    if (xRoot === undefined || yRoot === undefined || xRoot === yRoot) {
	        // x and y already belong to the same set.
	        return;
	    }

	    if (xRoot.rank < yRoot.rank) { // Move x into the set y is a member of.
	        xRoot.parent_ = yRoot;
	    } else if (yRoot.rank_ < xRoot.rank_) { // Move y into the set x is a member of.
	        yRoot.parent_ = xRoot;
	    } else { // Arbitrarily choose to move y into the set x is a member of.
	        yRoot.parent_ = xRoot;
	        xRoot.rank_++;
	    }
	};

	// Returns the current number of disjoint sets.
	DisjointSet.prototype.size = function () {
	    let uniqueIndices = {};
	    Object.keys(this.index_).forEach((id) => {
	        uniqueIndices[id] = true;
	    });
	    return Object.keys(uniqueIndices).length;
	};
	//</editor-fold>

	function c(r){if(0===r.length)throw new Error("max requires at least one data point");for(var t=r[0],n=1;n<r.length;n++)r[n]>t&&(t=r[n]);return t}function y(r,t){var n=r.length*t;if(0===r.length)throw new Error("quantile requires at least one data point.");if(t<0||t>1)throw new Error("quantiles must be between 0 and 1");return 1===t?r[r.length-1]:0===t?r[0]:n%1!=0?r[Math.ceil(n)-1]:r.length%2==0?(r[n-1]+r[n])/2:r[n]}function b(r,t,n,e){for(n=n||0,e=e||r.length-1;e>n;){if(e-n>600){var o=e-n+1,a=t-n+1,h=Math.log(o),f=.5*Math.exp(2*h/3),u=.5*Math.sqrt(h*f*(o-f)/o);a-o/2<0&&(u*=-1),b(r,t,Math.max(n,Math.floor(t-a*f/o+u)),Math.min(e,Math.floor(t+(o-a)*f/o+u)));}var i=r[t],l=n,g=e;for(d(r,n,t),r[e]>i&&d(r,n,e);l<g;){for(d(r,l,g),l++,g--;r[l]<i;)l++;for(;r[g]>i;)g--;}r[n]===i?d(r,n,g):d(r,++g,e),g<=t&&(n=g+1),t<=g&&(e=g-1);}}function d(r,t,n){var e=r[t];r[t]=r[n],r[n]=e;}function I(r,t){var n=r.slice();if(Array.isArray(t)){!function(r,t){for(var n=[0],e=0;e<t.length;e++)n.push(N(r.length,t[e]));n.push(r.length-1),n.sort(C);var o=[0,n.length-1];for(;o.length;){var a=Math.ceil(o.pop()),h=Math.floor(o.pop());if(!(a-h<=1)){var f=Math.floor((h+a)/2);P(r,n[f],Math.floor(n[h]),Math.ceil(n[a])),o.push(h,f,f,a);}}}(n,t);for(var e=[],o=0;o<t.length;o++)e[o]=y(n,t[o]);return e}return P(n,N(n.length,t),0,n.length-1),y(n,t)}function P(r,t,n,e){t%1==0?b(r,t,n,e):(b(r,t=Math.floor(t),n,e),b(r,t+1,t+1,e));}function C(r,t){return r-t}function N(r,t){var n=r*t;return 1===t?r-1:0===t?0:n%1!=0?Math.ceil(n)-1:r%2==0?n-.5:n}var pr=Math.log(Math.sqrt(2*Math.PI));var dr=Math.sqrt(2*Math.PI);var _r=Math.sqrt(2*Math.PI);function Ar(r){for(var t=r,n=r,e=1;e<15;e++)t+=n*=r*r/(2*e+1);return Math.round(1e4*(.5+t/_r*Math.exp(-r*r/2)))/1e4}for(var zr=[],Ur=0;Ur<=3.09;Ur+=.01)zr.push(Ar(Ur));

	/**
	 * options may contain upperBound, outlyingCoefficient (1.5 or 3.0), and weights (different variables may have different weights)
	 */
	class Outlying {
	    constructor(tree, options = {}) {
	        let upperBound = options.upperBound;
	        let outlyingCoefficient = options.outlyingCoefficient;
	        let weights = options.weights;
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	        this.upperBound = upperBound;
	        this.outlyingCoefficient = outlyingCoefficient ? outlyingCoefficient : 1.5;
	        //Calculate the upper bound if it is not provided.
	        if (!upperBound) {
	            upperBound = findUpperBound(this.tree, 1.5);
	            //Save it for displaying purpose.
	            this.upperBound = upperBound;
	        }
	        //Mark the long links
	        markLongLinks(this.tree, upperBound);
	        //Finding normal nodes
	        let normalNodes = findNormalNodes(this.tree);
	        //Finding outlying points
	        this.outlyingPoints = findOutlyingPoints(this.tree, normalNodes);

	        function findOutlyingPoints(tree, normalNodes) {
	            let newNodes = normalNodes;
	            let oldNodes = tree.nodes;
	            //Get the outlying points
	            let ops = [];
	            oldNodes.forEach(on => {
	                //.id since we are accessing to points and the node is in form of {id: thePoint}
	                if (!pointExists(newNodes.map(nn => nn.id), on.id)) {
	                    ops.push(on.id);
	                }
	            });
	            return ops;
	        }

	        //Now mark the outlying links
	        markOutlyingLinks(this.tree, this.outlyingPoints);

	        //Create none outlying tree
	        this.noOutlyingTree = buildNoOutlyingTree(this.tree, this.outlyingPoints);

	        function buildNoOutlyingTree(tree, outlyingPoints) {
	            let noOutlyingTree = {};
	            noOutlyingTree.nodes = normalNodes;
	            noOutlyingTree.links = tree.links.filter(l => l.isOutlying !== true);
	            //If the outlying nodes has the degree of 2 or greater => it will break the tree into subtrees => so we need to rebuild the tree.
	            //Take the outlying points
	            let outlyingPointsStr = outlyingPoints.map(p => p.join(','));
	            let v2OrGreaterStr = getAllV2OrGreaterFromTree(tree).map(p => p.join(','));

	            let diff = underscore.difference(outlyingPointsStr, v2OrGreaterStr);
	            if (diff.length < outlyingPointsStr.length) {
	                //Means there is outlying node(s) with degree 2 or higher (so we should rebuild the tree)
	                let graph = createGraph(noOutlyingTree.nodes.map(n => n.id), weights);
	                noOutlyingTree = mst(graph);
	            }
	            return noOutlyingTree;
	        }

	        function findNormalNodes(tree) {
	            //Remove long links
	            let normalLinks = tree.links.filter(l => !l.isLong);
	            //Remove outlying nodes (nodes are not in any none-long links)
	            let allNodesWithLinks = [];
	            normalLinks.forEach(l => {
	                allNodesWithLinks.push(l.source);
	                allNodesWithLinks.push(l.target);
	            });
	            allNodesWithLinks = underscore.uniq(allNodesWithLinks, false, d => d.join(','));
	            let normalNodes = allNodesWithLinks.map(n => {
	                return {id: n};
	            });
	            return normalNodes;
	        }

	        function markLongLinks(tree, upperBound) {
	            tree.links.forEach(l => {
	                if (l.weight > upperBound) {
	                    l.isLong = true;
	                }
	            });
	        }

	        function findUpperBound(tree, coefficient) {
	            let allLengths = tree.links.map(l => l.weight),
	                q1 = I(allLengths, 0.25),
	                q3 = I(allLengths, 0.75),
	                iqr = q3 - q1,
	                upperBound = q3 + coefficient * iqr;
	            return upperBound;
	        }

	        function markOutlyingLinks(tree, outlyingPoints) {
	            if (outlyingPoints.length > 0) {
	                //Check the long links only
	                tree.links.filter(l => l.isLong).forEach(l => {
	                    //Also check if the link contains outlying points.
	                    if (pointExists(outlyingPoints, l.source) || pointExists(outlyingPoints, l.target)) {
	                        l.isOutlying = true;
	                    }
	                });
	            }
	        }
	    }

	    /**
	     * Returns outlying score
	     * @returns {number}
	     */
	    score() {
	        let totalLengths = 0;
	        let totalOutlyingLengths = 0;
	        this.tree.links.forEach(l => {
	            totalLengths += l.weight;
	            //If there are outlying points first.
	            if (l.isOutlying) {
	                totalOutlyingLengths += l.weight;
	            }
	        });
	        return totalOutlyingLengths / totalLengths;
	    }

	    /**
	     * Returns outlying links
	     */
	    links() {
	        if (!this.outlyingLinks) {
	            this.outlyingLinks = this.tree.links.filter(l => l.isOutlying);
	        }
	        return this.outlyingLinks;
	    }

	    /**
	     * Remove outlying links and nodes and return a new tree without outlying points/edges
	     */
	    removeOutlying() {
	        return this.noOutlyingTree;
	    }

	    /**
	     * Returns the outlying points (in form of points, not node object).
	     * @returns {Array}
	     */
	    points() {
	        return this.outlyingPoints;
	    }
	}

	class Skewed {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns skewed score
	     * @returns {number}
	     */
	    score() {
	        let allLengths = this.tree.links.map(l=>l.weight),
	        q90 = I(allLengths, .9),
	        q50 = I(allLengths, .5),
	        q10 = I(allLengths, .1);
	        if(q90!=q10){
	            return (q90-q50)/(q90-q10);
	        }else{
	            return 0;
	        }
	    }
	}

	class Sparse {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns sparse score
	     * @returns {number}
	     */
	    score() {
	        let allLengths = this.tree.links.map(l=>l.weight),
	            q90 = I(allLengths, .9);
	        return q90;
	    }
	}

	class Clumpy {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns clumpy score
	     * @returns {number}
	     */
	    score() {
	        let allRuntRatios = [];
	        this.tree.links.forEach(link =>{
	            let rg = this.runtGraph(link);
	            if(rg.length>0){
	                allRuntRatios.push(this.maxLength(rg)/link.weight);
	            }
	        });
	        if(allRuntRatios.length>0){
	            //Only if there are some runt graphs
	            return c(allRuntRatios.map(rr=>1-rr));
	        }else{
	            //In case all lengths are equal => then the score is 0
	            return 0;
	        }
	    }

	    runtGraph(link){
	        //Links that are greater or equal to the currently checking link
	        let greaterOrEqualLinks = this.tree.links.filter(l=>l.weight < link.weight);
	        //Remove the currently checking link.
	        greaterOrEqualLinks = greaterOrEqualLinks.filter(l=>!equalLinks(l, link));
	        let pairedResults = pairNodeLinks(greaterOrEqualLinks);

	        //Process the source side.
	        let sourceConnectedNodes = [link.source];
	        let sourceConnectedLinks = this.getConnectedLinks(sourceConnectedNodes, pairedResults);

	        let targetConnectedNodes = [link.target];
	        let targetConnectedLinks = this.getConnectedLinks(targetConnectedNodes, pairedResults);

	        return sourceConnectedLinks.length < targetConnectedLinks.length?sourceConnectedLinks:targetConnectedLinks;
	    }


	    getConnectedLinks(connectedNodes, pairedResults) {
	        let processedNodes = [];
	        let connectedLinks = [];
	        while (connectedNodes.length > 0) {
	            //Can stop earlier if this is having more than half of the links in the whole tree.
	            if(connectedLinks.length > this.tree.links.length + 1){
	                break;
	            }
	            let firstNode = underscore.first(connectedNodes);
	            //Removed the processed nodes
	            connectedNodes = underscore.without(connectedNodes, firstNode);
	            //Add it to the processed node
	            processedNodes.push(firstNode);
	            //Find the edges connected to that node.
	            let result = pairedResults.find(p => p[0] === firstNode.join(","));
	            let links = result?result[1]:[];
	            connectedLinks = connectedLinks.concat(links);
	            //Add new nodes to be processed
	            links.forEach(l => {
	                //If the node in the connected link is not processed => then add it to be processed (to expand later on).
	                if (!pointExists(processedNodes, l.source)) {
	                    connectedNodes.push(l.source);
	                }
	                if(!pointExists(processedNodes, l.target)) {
	                    connectedNodes.push(l.target);
	                }
	            });
	        }
	        return connectedLinks;
	    }

	    maxLength(runtGraph){
	        if(runtGraph.length===0){
	            return 0;
	        }
	        return c(runtGraph.map(l=>l.weight));
	    }
	}

	class Stringy {
	    constructor(tree) {
	        //Clone the tree to avoid modifying it
	        this.tree = JSON.parse(JSON.stringify(tree));
	    }

	    /**
	     * Returns striated score
	     * @returns {number}
	     */
	    score() {
	        //Loop through the nodes.
	        let verticesCount = this.tree.nodes.length;
	        let v2Count = this.getAllV2Corners().length;
	        let v1Count = this.getAllV1s().length;
	        return v2Count/(verticesCount-v1Count);
	    }

	    /**
	     * This function returns corners (three vertices) of vertices of degree two in the for mat of
	     * point1, point2, point3 => point1 is the the vertex with degree two (two edges connected to it are [point1, point2] and [point1, point3] (order of the points in each edge is not important)).
	     * @returns {Array}
	     */
	    getAllV2Corners(){
	        return getAllV2CornersFromTree(this.tree);
	    }

	    /**
	     * This function returns
	     * @returns {Array}
	     */
	    getAllV1s(){
	        return getAllV1sFromTree(this.tree);
	    }
	}

	class Monotonic {
	    constructor(points) {
	        //Clone it in order to avoid modifying it.
	        this.points = points.slice(0);
	    }

	    /**
	     * Returns monotonic score
	     * @returns {number}
	     */
	    score() {
	        let spearmans = [];
	        let variables = underscore.unzip(this.points);
	        let length = variables.length;

	        //Calculate the spearman for all pairs of variables.
	        for (let i = 0; i < length - 1; i++) {
	            let v1 = variables[i];
	            for (let j = i+1; j < length; j++) {
	                let v2 = variables[j];
	                let r = computeSpearmans(v1, v2);
	                spearmans.push(r*r);
	            }
	        }
	        return underscore.max(spearmans);

	        /**Adopted from: https://bl.ocks.org/nkullman/f65d5619843dc22e061d957249121408**/
	        function computeSpearmans(arrX, arrY) {
	            // simple error handling for input arrays of nonequal lengths
	            if (arrX.length !== arrY.length) {
	                return null;
	            }

	            // number of observations
	            let n = arrX.length;

	            // rank datasets
	            let xRanked = rankArray(arrX),
	                yRanked = rankArray(arrY);

	            // sum of distances between ranks
	            let dsq = 0;
	            for (let i = 0; i < n; i++) {
	                dsq += Math.pow(xRanked[i] - yRanked[i], 2);
	            }

	            // compute correction for ties
	            let xTies = countTies(arrX),
	                yTies = countTies(arrY);
	            let xCorrection = 0,
	                yCorrection = 0;
	            for (let tieLength in xTies) {
	                xCorrection += xTies[tieLength] * tieLength * (Math.pow(tieLength, 2) - 1);
	            }
	            xCorrection /= 12.0;
	            for (let tieLength in yTies) {
	                yCorrection += yTies[tieLength] * tieLength * (Math.pow(tieLength, 2) - 1);
	            }
	            yCorrection /= 12.0;

	            // denominator
	            let denominator = n * (Math.pow(n, 2) - 1) / 6.0;

	            // compute rho
	            let rho = denominator - dsq - xCorrection - yCorrection;
	            rho /= Math.sqrt((denominator - 2 * xCorrection) * (denominator - 2 * yCorrection));

	            return rho;
	        }

	        /** Computes the rank array for arr, where each entry in arr is
	         * assigned a value 1 thru n, where n is arr.length.
	         *
	         * Tied entries in arr are each given the average rank of the ties.
	         * Lower ranks are not increased
	         */
	        function rankArray(arr) {

	            // ranking without averaging
	            let sorted = arr.slice().sort(function (a, b) {
	                return b - a
	            });
	            let ranks = arr.slice().map(function (v) {
	                return sorted.indexOf(v) + 1
	            });

	            // counts of each rank
	            let counts = {};
	            ranks.forEach(function (x) {
	                counts[x] = (counts[x] || 0) + 1;
	            });

	            // average duplicates
	            ranks = ranks.map(function (x) {
	                return x + 0.5 * ((counts[x] || 0) - 1);
	            });

	            return ranks;
	        }

	        /** Counts the number of ties in arr, and returns
	         * an object with
	         * a key for each tie length (an entry n for each n-way tie) and
	         * a value corresponding to the number of key-way (n-way) ties
	         */
	        function countTies(arr) {
	            let ties = {},
	                arrSorted = arr.slice().sort(),
	                currValue = arrSorted[0],
	                tieLength = 1;

	            for (let i = 1; i < arrSorted.length; i++) {
	                if (arrSorted[i] === currValue) {
	                    tieLength++;
	                } else {
	                    if (tieLength > 1) {
	                        if (ties[tieLength] === undefined) ties[tieLength] = 0;
	                        ties[tieLength]++;
	                    }
	                    currValue = arrSorted[i];
	                    tieLength = 1;
	                }
	            }
	            if (tieLength > 1) {
	                if (ties[tieLength] === undefined) ties[tieLength] = 0;
	                ties[tieLength]++;
	            }
	            return ties;
	        }
	    }
	}

	(function (window) {
	    /**
	     * initialize a scagnosticsnd object
	     * @param inputPoints   {*[][]} set of points from the scatter plot
	     * @returns {*[][]}
	     */
	    window.scagnosticsnd = function (inputPoints, options={}) {
	        let dims = inputPoints[0].length;
	        //Clone it to avoid modifying it.
	        let points = inputPoints.map(e=>e.slice());
	        //Add one step to pass the data over if there is.
	        for (let i = 0; i < points.length; i++) {
	            points[i].data = inputPoints[i].data;
	        }
	        let normalizedPoints = points;

	        if(options.isNormalized === undefined){
	            let normalizer = new Normalizer(points);
	            normalizedPoints = normalizer.normalizedPoints;
	            outputValue("normalizedPoints", normalizedPoints);
	            outputValue("normalizer", normalizer);
	        }

	        let binType = options.binType;
	        /******This section is about the outlying score and outlying score results******/
	        let outlyingUpperBound = options.outlyingUpperBound;
	        let outlyingCoefficient = options.outlyingCoefficient;

	        /******This section is about finding number of bins and binners******/
	        let sites = null;
	        let bins = null;
	        let binner = null;
	        let binSize = null;
	        let binRadius = 0;
	        let startBinGridSize = options.startBinGridSize;

	        if(options.isBinned===undefined){//Only do the binning if needed.
	            let incrementA = options.incrementA?options.incrementA: 2;
	            let incrementB = options.incrementB?options.incrementB: 0;
	            let decrementA = options.decrementA?options.decrementA: 1/2;
	            let decrementB = options.decrementB?options.decrementB: 0;

	            if(startBinGridSize===undefined){
	                startBinGridSize = 20;
	            }
	            bins = [];
	            //Default number of bins
	            let minNumOfBins = 30;
	            let maxNumOfBins = 200;
	            let minBins = options.minBins;
	            let maxBins = options.maxBins;
	            if(minBins){
	                minNumOfBins =minBins;
	            }
	            if(maxBins){
	                maxNumOfBins = maxBins;
	            }
	            //Don't do the binning if the unique set of values are less than min number. Just return the unique set.
	            let uniqueKeys = underscore_1.uniq(normalizedPoints.map(p=>p.join(',')));
	            let groups = underscore_1.groupBy(normalizedPoints, p=>p.join(','));
	            if(uniqueKeys.length<minNumOfBins){
	                uniqueKeys.forEach(key=>{
	                    let bin = groups[key];
	                    //Take the coordinate of the first point in the group to be the bin leader (they should have the same points actually=> so just take the first one.
	                    bin.site = bin[0].slice();
	                    bins.push(bin);
	                });
	            }else{
	                do{
	                    //Start with binSize x binSize x binSize... bins, and then increase it as binSize = binSize * incrementA + incrementB or binSize = binSize * decrementA + decrementB.
	                    if(binSize===null){
	                        binSize = startBinGridSize;
	                    }else if(bins.length>maxNumOfBins){
	                        binSize = binSize*decrementA+decrementB;
	                    }else if(bins.length<minNumOfBins){
	                        binSize = binSize*incrementA + incrementB;
	                    }
	                    if(binType==="hexagon");else if(!binType || binType==="leader"){
	                        // This section uses leader binner
	                        binRadius = Math.sqrt(dims*Math.pow(1/(binSize*2), 2));
	                        binner = new LeaderBinner(normalizedPoints, binRadius);
	                        bins = binner.leaders;
	                    }
	                }while(bins.length > maxNumOfBins || bins.length < minNumOfBins);
	            }
	            sites = bins.map(d=>d.site); //=>sites are the set of centers of all bins
	            /******This section is about the binning and binning results******/
	            outputValue("binner", binner);
	            outputValue("bins", bins);
	            outputValue("binSize", binSize);
	            outputValue("binRadius", binRadius);
	        }else{
	            sites = normalizedPoints;
	        }

	        outputValue("binnedSites", sites);

	        /******This section is about the spanning tree and spanning tree results******/
	        //Spanning tree calculation
	        let tetrahedraCoordinates = [sites];
	        let weights = options.distanceWeights;
	        let graph = createGraph(tetrahedraCoordinates, weights);
	        let mstree = mst(graph);
	        //Assigning the output values
	        outputValue("graph", graph);
	        outputValue("mst", mstree);

	        /******This section is about the outlying score and outlying score results******/
	            //TODO: Need to check if outlying links are really connected to outlying points
	        let outlying = new Outlying(mstree, outlyingUpperBound,outlyingCoefficient);
	        let outlyingScore = outlying.score();
	        outlyingUpperBound = outlying.upperBound;
	        let outlyingLinks = outlying.links();
	        let outlyingSites = outlying.points().map(p=>p.join(','));
	        let outlyingBins = bins.filter(b=> outlyingSites.indexOf(b.site.join(','))>=0) ;

	        //Add outlying points from the bin to it.
	        let outlyingPoints = [];
	        outlying.points().forEach(p=>{
	            bins.forEach(b=>{
	                if(equalPoints(p, b.site)){
	                    outlyingPoints = outlyingPoints.concat(b);
	                }
	            });

	        });
	        outputValue("outlyingBins", outlyingBins);
	        outputValue("outlyingScore", outlyingScore);
	        outputValue("outlyingUpperBound", outlyingUpperBound);
	        outputValue("outlyingLinks", outlyingLinks);
	        outputValue("outlyingPoints", outlyingPoints);


	        /******This section is about the skewed score and skewed score results******/
	        let noOutlyingTree = mstree;
	        let skewed = new Skewed(noOutlyingTree);
	        outputValue("skewedScore", skewed.score());

	        /******This section is about the sparse score and sparse score results******/
	        let sparse = new Sparse(noOutlyingTree);
	        outputValue("sparseScore", sparse.score());

	        /******This section is about the clumpy score and clumpy score results******/
	        let clumpy = new Clumpy(noOutlyingTree);
	        outputValue("clumpy", clumpy);
	        outputValue("clumpyScore", clumpy.score());


	        // /******This section is about the striated score and striated score results******/
	        // let striated = new Striated(noOutlyingTree);
	        // outputValue("striatedScore", striated.score());
	        //
	        // /******This section is about the convex hull and convex hull results******/
	        // let convex = new Convex(noOutlyingTree, 1/outlying.upperBound);
	        // let convexHull = convex.convexHull();
	        // outputValue("convexHull", convexHull);
	        //
	        //
	        // /******This section is about the concave hull and concave hull results******/
	        // let concaveHull = convex.concaveHull();
	        // outputValue("concaveHull", concaveHull);
	        //
	        //
	        // /******This section is about the convex score and convex score results******/
	        // let convexScore = convex.score();
	        // outputValue("convexScore", convexScore);
	        //
	        //
	        // /******This section is about the skinny score and skinny score results******/
	        // let skinny = new Skinny(concaveHull);
	        // let skinnyScore = skinny.score();
	        // outputValue("skinnyScore", skinnyScore);
	        //
	        /******This section is about the stringy score and stringy score results******/
	        let stringy = new Stringy(noOutlyingTree);
	        let v1s = stringy.getAllV1s();
	        let v2Corners = stringy.getAllV2Corners();
	        // let obtuseV2Corners = striated.getAllObtuseV2Corners();
	        let stringyScore = stringy.score();
	        outputValue("v1s", v1s);
	        outputValue("stringyScore", stringyScore);
	        outputValue("v2Corners", v2Corners);
	        // outputValue("obtuseV2Corners", obtuseV2Corners);


	        /******This section is about the monotonic score and monotonic score results******/
	        let monotonic = new Monotonic(noOutlyingTree.nodes.map(n=>n.id));
	        let monotonicScore = monotonic.score();
	        outputValue("monotonicScore", monotonicScore);

	        return window.scagnosticsnd;
	        function outputValue(name, value) {
	            window.scagnosticsnd[name] = value;
	        }
	    };

	})(window);

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhZ25vc3RpY3NuZC5taW4uanMiLCJzb3VyY2VzIjpbIi4uLy4uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL25vcm1hbGl6ZXIuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL2xlYWRlckJpbm5lci5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMva3J1c2thbC1tc3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvc2ltcGxlLXN0YXRpc3RpY3MvZGlzdC9zaW1wbGUtc3RhdGlzdGljcy5tanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL291dGx5aW5nLmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9za2V3ZWQuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9tb2R1bGVzL3NwYXJzZS5qcyIsIi4uLy4uL3NyYy9zY3JpcHRzL21vZHVsZXMvY2x1bXB5LmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9zdHJpbmd5LmpzIiwiLi4vLi4vc3JjL3NjcmlwdHMvbW9kdWxlcy9tb25vdG9uaWMuanMiLCIuLi8uLi9zcmMvc2NyaXB0cy9zY2Fnbm9zdGljc25kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOS4xXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE4IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIGBnbG9iYWxgXG4gIC8vIG9uIHRoZSBzZXJ2ZXIsIG9yIGB0aGlzYCBpbiBzb21lIHZpcnR1YWwgbWFjaGluZXMuIFdlIHVzZSBgc2VsZmBcbiAgLy8gaW5zdGVhZCBvZiBgd2luZG93YCBmb3IgYFdlYldvcmtlcmAgc3VwcG9ydC5cbiAgdmFyIHJvb3QgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZiB8fFxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsIHx8XG4gICAgICAgICAgICB0aGlzIHx8XG4gICAgICAgICAgICB7fTtcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBTeW1ib2xQcm90byA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLnByb3RvdHlwZSA6IG51bGw7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhciBwdXNoID0gQXJyYXlQcm90by5wdXNoLFxuICAgICAgc2xpY2UgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXIgbmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgICBuYXRpdmVLZXlzID0gT2JqZWN0LmtleXMsXG4gICAgICBuYXRpdmVDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGVpciBvbGQgbW9kdWxlIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICAvLyAoYG5vZGVUeXBlYCBpcyBjaGVja2VkIHRvIGVuc3VyZSB0aGF0IGBtb2R1bGVgXG4gIC8vIGFuZCBgZXhwb3J0c2AgYXJlIG5vdCBIVE1MIGVsZW1lbnRzLilcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmICFleHBvcnRzLm5vZGVUeXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS45LjEnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICAvLyBUaGUgMi1hcmd1bWVudCBjYXNlIGlzIG9taXR0ZWQgYmVjYXVzZSB3ZeKAmXJlIG5vdCB1c2luZyBpdC5cbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBidWlsdGluSXRlcmF0ZWU7XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG8gZWFjaFxuICAvLyBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyIGBpZGVudGl0eWAsXG4gIC8vIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoXy5pdGVyYXRlZSAhPT0gYnVpbHRpbkl0ZXJhdGVlKSByZXR1cm4gXy5pdGVyYXRlZSh2YWx1ZSwgY29udGV4dCk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSAmJiAhXy5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIEV4dGVybmFsIHdyYXBwZXIgZm9yIG91ciBjYWxsYmFjayBnZW5lcmF0b3IuIFVzZXJzIG1heSBjdXN0b21pemVcbiAgLy8gYF8uaXRlcmF0ZWVgIGlmIHRoZXkgd2FudCBhZGRpdGlvbmFsIHByZWRpY2F0ZS9pdGVyYXRlZSBzaG9ydGhhbmQgc3R5bGVzLlxuICAvLyBUaGlzIGFic3RyYWN0aW9uIGhpZGVzIHRoZSBpbnRlcm5hbC1vbmx5IGFyZ0NvdW50IGFyZ3VtZW50LlxuICBfLml0ZXJhdGVlID0gYnVpbHRpbkl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBTb21lIGZ1bmN0aW9ucyB0YWtlIGEgdmFyaWFibGUgbnVtYmVyIG9mIGFyZ3VtZW50cywgb3IgYSBmZXcgZXhwZWN0ZWRcbiAgLy8gYXJndW1lbnRzIGF0IHRoZSBiZWdpbm5pbmcgYW5kIHRoZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgdmFsdWVzIHRvIG9wZXJhdGVcbiAgLy8gb24uIFRoaXMgaGVscGVyIGFjY3VtdWxhdGVzIGFsbCByZW1haW5pbmcgYXJndW1lbnRzIHBhc3QgdGhlIGZ1bmN0aW9u4oCZc1xuICAvLyBhcmd1bWVudCBsZW5ndGggKG9yIGFuIGV4cGxpY2l0IGBzdGFydEluZGV4YCksIGludG8gYW4gYXJyYXkgdGhhdCBiZWNvbWVzXG4gIC8vIHRoZSBsYXN0IGFyZ3VtZW50LiBTaW1pbGFyIHRvIEVTNuKAmXMgXCJyZXN0IHBhcmFtZXRlclwiLlxuICB2YXIgcmVzdEFyZ3VtZW50cyA9IGZ1bmN0aW9uKGZ1bmMsIHN0YXJ0SW5kZXgpIHtcbiAgICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCA9PSBudWxsID8gZnVuYy5sZW5ndGggLSAxIDogK3N0YXJ0SW5kZXg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGFyZ3VtZW50cy5sZW5ndGggLSBzdGFydEluZGV4LCAwKSxcbiAgICAgICAgICByZXN0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXggKyBzdGFydEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoc3RhcnRJbmRleCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIHJlc3QpO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0sIHJlc3QpO1xuICAgICAgfVxuICAgICAgdmFyIGFyZ3MgPSBBcnJheShzdGFydEluZGV4ICsgMSk7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzdGFydEluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGFyZ3Nbc3RhcnRJbmRleF0gPSByZXN0O1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgc2hhbGxvd1Byb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGFzID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwYXRoKTtcbiAgfVxuXG4gIHZhciBkZWVwR2V0ID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aCA/IG9iaiA6IHZvaWQgMDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdC5cbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgLy8gQXZvaWRzIGEgdmVyeSBuYXN0eSBpT1MgOCBKSVQgYnVnIG9uIEFSTS02NC4gIzIwOTRcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBnZXRMZW5ndGggPSBzaGFsbG93UHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgdmFyIGNyZWF0ZVJlZHVjZSA9IGZ1bmN0aW9uKGRpcikge1xuICAgIC8vIFdyYXAgY29kZSB0aGF0IHJlYXNzaWducyBhcmd1bWVudCB2YXJpYWJsZXMgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiB0aGFuXG4gICAgLy8gdGhlIG9uZSB0aGF0IGFjY2Vzc2VzIGBhcmd1bWVudHMubGVuZ3RoYCB0byBhdm9pZCBhIHBlcmYgaGl0LiAoIzE5OTEpXG4gICAgdmFyIHJlZHVjZXIgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBpbml0aWFsKSB7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgaWYgKCFpbml0aWFsKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+PSAzO1xuICAgICAgcmV0dXJuIHJlZHVjZXIob2JqLCBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KSwgbWVtbywgaW5pdGlhbCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleUZpbmRlciA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmZpbmRJbmRleCA6IF8uZmluZEtleTtcbiAgICB2YXIga2V5ID0ga2V5RmluZGVyKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwgcGF0aCwgYXJncykge1xuICAgIHZhciBjb250ZXh0UGF0aCwgZnVuYztcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHBhdGgpKSB7XG4gICAgICBmdW5jID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShwYXRoKSkge1xuICAgICAgY29udGV4dFBhdGggPSBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgICAgIHBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXRob2QgPSBmdW5jO1xuICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgaWYgKGNvbnRleHRQYXRoICYmIGNvbnRleHRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRleHQgPSBkZWVwR2V0KGNvbnRleHQsIGNvbnRleHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGV4dCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICBtZXRob2QgPSBjb250ZXh0W3BhdGhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGhvZCA9PSBudWxsID8gbWV0aG9kIDogbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8IHR5cGVvZiBpdGVyYXRlZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqWzBdICE9ICdvYmplY3QnICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2O1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmF0ZWUgPT0gJ251bWJlcicgJiYgdHlwZW9mIG9ialswXSAhPSAnb2JqZWN0JyAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odiwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2LCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5zYW1wbGUob2JqLCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24gdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgdmFyIHNhbXBsZSA9IGlzQXJyYXlMaWtlKG9iaikgPyBfLmNsb25lKG9iaikgOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoc2FtcGxlKTtcbiAgICBuID0gTWF0aC5tYXgoTWF0aC5taW4obiwgbGVuZ3RoKSwgMCk7XG4gICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBuOyBpbmRleCsrKSB7XG4gICAgICB2YXIgcmFuZCA9IF8ucmFuZG9tKGluZGV4LCBsYXN0KTtcbiAgICAgIHZhciB0ZW1wID0gc2FtcGxlW2luZGV4XTtcbiAgICAgIHNhbXBsZVtpbmRleF0gPSBzYW1wbGVbcmFuZF07XG4gICAgICBzYW1wbGVbcmFuZF0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gc2FtcGxlLnNsaWNlKDAsIG4pO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4KyssXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwga2V5LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IsIHBhcnRpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gcGFydGl0aW9uID8gW1tdLCBbXV0gOiB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChoYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgdmFyIHJlU3RyU3ltYm9sID0gL1teXFx1ZDgwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRmZmZdL2c7XG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChfLmlzU3RyaW5nKG9iaikpIHtcbiAgICAgIC8vIEtlZXAgc3Vycm9nYXRlIHBhaXIgY2hhcmFjdGVycyB0b2dldGhlclxuICAgICAgcmV0dXJuIG9iai5tYXRjaChyZVN0clN5bWJvbCk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIHBhc3MpIHtcbiAgICByZXN1bHRbcGFzcyA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsIHx8IGFycmF5Lmxlbmd0aCA8IDEpIHJldHVybiBuID09IG51bGwgPyB2b2lkIDAgOiBbXTtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCB8fCBhcnJheS5sZW5ndGggPCAxKSByZXR1cm4gbiA9PSBudWxsID8gdm9pZCAwIDogW107XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBCb29sZWFuKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0IHx8IFtdO1xuICAgIHZhciBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy8gRmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3QuXG4gICAgICAgIGlmIChzaGFsbG93KSB7XG4gICAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGogPCBsZW4pIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KTtcbiAgICAgICAgICBpZHggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5LCBvdGhlckFycmF5cykge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIG90aGVyQXJyYXlzKTtcbiAgfSk7XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBUaGUgZmFzdGVyIGFsZ29yaXRobSB3aWxsIG5vdCB3b3JrIHdpdGggYW4gaXRlcmF0ZWUgaWYgdGhlIGl0ZXJhdGVlXG4gIC8vIGlzIG5vdCBhIG9uZS10by1vbmUgZnVuY3Rpb24sIHNvIHByb3ZpZGluZyBhbiBpdGVyYXRlZSB3aWxsIGRpc2FibGVcbiAgLy8gdGhlIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQgJiYgIWl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheXMpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJyYXlzLCB0cnVlLCB0cnVlKSk7XG4gIH0pO1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGo7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXksIHJlc3QpIHtcbiAgICByZXN0ID0gZmxhdHRlbihyZXN0LCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzLlxuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gcmVzdEFyZ3VtZW50cyhfLnVuemlwKTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuIFBhc3NpbmcgYnkgcGFpcnMgaXMgdGhlIHJldmVyc2Ugb2YgXy5wYWlycy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUluZGV4RmluZGVyID0gZnVuY3Rpb24oZGlyLCBwcmVkaWNhdGVGaW5kLCBzb3J0ZWRJbmRleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgaXRlbSwgaWR4KSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICBpZiAodHlwZW9mIGlkeCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZGlyID4gMCkge1xuICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigxLCBfLmZpbmRJbmRleCwgXy5zb3J0ZWRJbmRleCk7XG4gIF8ubGFzdEluZGV4T2YgPSBjcmVhdGVJbmRleEZpbmRlcigtMSwgXy5maW5kTGFzdEluZGV4KTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChzdG9wID09IG51bGwpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXN0ZXApIHtcbiAgICAgIHN0ZXAgPSBzdG9wIDwgc3RhcnQgPyAtMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBDaHVuayBhIHNpbmdsZSBhcnJheSBpbnRvIG11bHRpcGxlIGFycmF5cywgZWFjaCBjb250YWluaW5nIGBjb3VudGAgb3IgZmV3ZXJcbiAgLy8gaXRlbXMuXG4gIF8uY2h1bmsgPSBmdW5jdGlvbihhcnJheSwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCB8fCBjb3VudCA8IDEpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNsaWNlLmNhbGwoYXJyYXksIGksIGkgKz0gY291bnQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGJvdW5kID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihjYWxsQXJncykge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyIGJ5IGRlZmF1bHQsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmVcbiAgLy8gcHJlLWZpbGxlZC4gU2V0IGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIGZvciBhIGN1c3RvbSBwbGFjZWhvbGRlciBhcmd1bWVudC5cbiAgXy5wYXJ0aWFsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCBib3VuZEFyZ3MpIHtcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSBfLnBhcnRpYWwucGxhY2Vob2xkZXI7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBwbGFjZWhvbGRlciA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH0pO1xuXG4gIF8ucGFydGlhbC5wbGFjZWhvbGRlciA9IF87XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICB2YXIgaW5kZXggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAoaW5kZXggPCAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICB9KTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFoYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH0pO1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGltZW91dCwgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aHJvdHRsZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBwcmV2aW91cyA9IDA7XG4gICAgICB0aW1lb3V0ID0gY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG5cbiAgICByZXR1cm4gdGhyb3R0bGVkO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIGlmIChhcmdzKSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgZGVib3VuY2VkID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcmdzKSB7XG4gICAgICBpZiAodGltZW91dCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICB2YXIgY2FsbE5vdyA9ICF0aW1lb3V0O1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICAgIGlmIChjYWxsTm93KSByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IF8uZGVsYXkobGF0ZXIsIHdhaXQsIHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZGVib3VuY2VkLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICBfLnJlc3RBcmd1bWVudHMgPSByZXN0QXJndW1lbnRzO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgdmFyIGNvbGxlY3ROb25FbnVtUHJvcHMgPSBmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChoYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgLlxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKGhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdC5cbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3QuXG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0ge307XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICAvLyBUaGUgb3Bwb3NpdGUgb2YgXy5vYmplY3QuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgLlxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoZGVmYXVsdHMpIG9iaiA9IE9iamVjdChvYmopO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCFkZWZhdWx0cyB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKS5cbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdC5cbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcGljayBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIGBvYmpgIGhhcyBrZXkgYGtleWAuXG4gIHZhciBrZXlJbk9iaiA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBrZXlzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBpdGVyYXRlZSA9IGtleXNbMF07XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGtleXNbMV0pO1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGtleUluT2JqO1xuICAgICAga2V5cyA9IGZsYXR0ZW4oa2V5cywgZmFsc2UsIGZhbHNlKTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgaXRlcmF0ZWUgPSBrZXlzWzBdLCBjb250ZXh0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGNvbnRleHQgPSBrZXlzWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gXy5tYXAoZmxhdHRlbihrZXlzLCBmYWxzZSwgZmFsc2UpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfSk7XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxLCBkZWVwRXE7XG4gIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb25seSBlcXVhbCB0byBpdHNlbGYgKHN0cmljdCBjb21wYXJpc29uKS5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgaWYgKGEgIT09IGEpIHJldHVybiBiICE9PSBiO1xuICAgIC8vIEV4aGF1c3QgcHJpbWl0aXZlIGNoZWNrc1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGE7XG4gICAgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZSAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gZGVlcEVxKGEsIGIsIGFTdGFjaywgYlN0YWNrKTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICBkZWVwRXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU4uXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBTeW1ib2xdJzpcbiAgICAgICAgcmV0dXJuIFN5bWJvbFByb3RvLnZhbHVlT2YuY2FsbChhKSA9PT0gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGIpO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IsIGlzTWFwLCBpc1dlYWtNYXAsIGlzU2V0LCBpc1dlYWtTZXQuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJywgJ1N5bWJvbCcsICdNYXAnLCAnV2Vha01hcCcsICdTZXQnLCAnV2Vha1NldCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBTYWZhcmkgOCAoIzE5MjkpLCBhbmQgUGhhbnRvbUpTICgjMjIzNikuXG4gIHZhciBub2RlbGlzdCA9IHJvb3QuZG9jdW1lbnQgJiYgcm9vdC5kb2N1bWVudC5jaGlsZE5vZGVzO1xuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcgJiYgdHlwZW9mIG5vZGVsaXN0ICE9ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhXy5pc1N5bWJvbChvYmopICYmIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gP1xuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBpc05hTihvYmopO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBoYXMob2JqLCBwYXRoKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwYXRoW2ldO1xuICAgICAgaWYgKG9iaiA9PSBudWxsIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmpba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuICEhbGVuZ3RoO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcGFzc2VkIGFuIG9iamVjdCwgd2lsbCB0cmF2ZXJzZSB0aGF0IG9iamVjdOKAmXNcbiAgLy8gcHJvcGVydGllcyBkb3duIHRoZSBnaXZlbiBgcGF0aGAsIHNwZWNpZmllZCBhcyBhbiBhcnJheSBvZiBrZXlzIG9yIGluZGV4ZXMuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICAgIHJldHVybiBzaGFsbG93UHJvcGVydHkocGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiAhXy5pc0FycmF5KHBhdGgpID8gb2JqW3BhdGhdIDogZGVlcEdldChvYmosIHBhdGgpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIFRyYXZlcnNlcyB0aGUgY2hpbGRyZW4gb2YgYG9iamAgYWxvbmcgYHBhdGhgLiBJZiBhIGNoaWxkIGlzIGEgZnVuY3Rpb24sIGl0XG4gIC8vIGlzIGludm9rZWQgd2l0aCBpdHMgcGFyZW50IGFzIGNvbnRleHQuIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBmaW5hbFxuICAvLyBjaGlsZCwgb3IgYGZhbGxiYWNrYCBpZiBhbnkgY2hpbGQgaXMgdW5kZWZpbmVkLlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iaiwgcGF0aCwgZmFsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkgcGF0aCA9IFtwYXRoXTtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIHJldHVybiBfLmlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2suY2FsbChvYmopIDogZmFsbGJhY2s7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpbcGF0aFtpXV07XG4gICAgICBpZiAocHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByb3AgPSBmYWxsYmFjaztcbiAgICAgICAgaSA9IGxlbmd0aDsgLy8gRW5zdXJlIHdlIGRvbid0IGNvbnRpbnVlIGl0ZXJhdGluZy5cbiAgICAgIH1cbiAgICAgIG9iaiA9IF8uaXNGdW5jdGlvbihwcm9wKSA/IHByb3AuY2FsbChvYmopIDogcHJvcDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHInOiAncicsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZVJlZ0V4cCA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2Zmc2V0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHZhciByZW5kZXI7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgY2hhaW5SZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBfO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY2hhaW5SZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLl93cmFwcGVkKTtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufSgpKTtcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuXG5leHBvcnQgY2xhc3MgTm9ybWFsaXplciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzKSB7XG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzLm1hcChlPT5lLnNsaWNlKCkpO1xuICAgICAgICAvL3Bhc3MgdGhlIGRhdGEgb3ZlclxuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChwLCBpKT0+e1xuICAgICAgICAgICAgcC5kYXRhID0gcG9pbnRzW2ldLmRhdGE7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbmRzID0gdGhpcy5uZHMgPSBfLnVuemlwKHRoaXMucG9pbnRzKTtcbiAgICAgICAgbGV0IG1heEQgPSB0aGlzLm1heEQgPSBbXTtcbiAgICAgICAgbGV0IG1pbkQgPSB0aGlzLm1pbkQgPSBbXTtcbiAgICAgICAgbGV0IHJhbmdlRCA9IHRoaXMucmFuZ2VEID0gW107XG4gICAgICAgIGxldCBub3JtYWxpemVkRCA9IHRoaXMubm9ybWFsaXplZEQgPSBbXTtcbiAgICAgICAgbmRzLmZvckVhY2goKGQsIGkpPT57XG4gICAgICAgICAgICBtYXhEW2ldID0gXy5tYXgoZCk7XG4gICAgICAgICAgICBtaW5EW2ldID0gXy5taW4oZCk7XG4gICAgICAgICAgICByYW5nZURbaV0gPSAobWF4RFtpXSAhPSBtaW5EW2ldKSA/IG1heERbaV0gLSBtaW5EW2ldIDogMTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWREW2ldID0gZC5tYXAoZT0+KGUtbWluRFtpXSkvcmFuZ2VEW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGg7XG4gICAgICAgIHRoaXMubm9ybWFsaXplZFBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRQb2ludHNbaV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5uZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWRQb2ludHNbaV1bal0gPSBub3JtYWxpemVkRFtqXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL0FkZCBvbmUgc3RlcCB0byBwYXNzIHRoZSBkYXRhIG92ZXIgaWYgdGhlcmUgaXMuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplZFBvaW50c1tpXS5kYXRhID0gdGhpcy5wb2ludHNbaV0uZGF0YTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IGEgc2V0IG9mIHBvaW50cyBpbiB0aGlzIHNjYWxlIHJhbmdlIFswLCAxXSBhbmQgd2lsbCBiZSBzY2FsZWQgYmFjayB0b1xuICAgICAqIC0gT3JpZ2luYWwgc2NhbGUgKFttaW5YLCBtYXhYXSwgW21pblksIG1heFldLCBbbWluWiwgbWF4Wl0pXG4gICAgICogQHBhcmFtIHBvaW50c1xuICAgICAqL1xuICAgIHNjYWxlQmFja1BvaW50cyhwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAocG9pbnQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVCYWNrUG9pbnQocG9pbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBhIHNpbmdsZSBwb2ludCBpbiB0aGlzIHNjYWxlIHJhbmdlIFswLCAxXSBhbmQgd2lsbCBiZSBzY2FsZWQgYmFjayB0b1xuICAgICAqIC0gT3JpZ2luYWwgc2NhbGUgKFttaW5YLCBtYXhYXSwgW21pblksIG1heFldLCBbbWluWiwgbWF4Wl0pXG4gICAgICogQHBhcmFtIHBvaW50c1xuICAgICAqL1xuICAgIHNjYWxlQmFja1BvaW50KHBvaW50KSB7XG4gICAgICAgIGxldCBuZXdQb2ludCA9IHBvaW50Lm1hcCgodnMsIGkpPT57XG4gICAgICAgICAgICBsZXQgdiA9IHRoaXMucmFuZ2VEW2ldKnZzICsgdGhpcy5taW5EW2ldO1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3UG9pbnQ7XG4gICAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIExlYWRlckJpbm5lciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRzLCByYWRpdXMpIHtcbiAgICAgICAgLy9UT0RPOiBTaG91bGQgY2hlY2sgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiAzIHVuaXF1ZSB2YWx1ZXMgaGVyZSBvciBldmVuIGFmdGVyIHRoZSBiaW5uaW5nLlxuICAgICAgICAvL1RPRE86IE1heSBuZWVkIHRvIGNsb25lIHRoZSBwb2ludHMgdG8gYXZvaWQgbW9kaWZ5aW5nIGl0LCBidXQgd2UgZG9uJ3QgZG8gdG8gcmVzZXJ2ZSBvdGhlciBkYXRhIG9yIHRvIG1ha2UgdGhlIHByb2Nlc3MgZmFzdGVyXG4gICAgICAgIC8vIC8vQ2xvbmUgdGhlc2UgdG8gYXZvaWQgbW9kaWZ5aW5nIHRoZW1cbiAgICAgICAgLy8gdGhpcy5wb2ludHMgPSBwb2ludHMubWFwKHA9PnAuc2xpY2UoMCkpO1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgfVxuXG4gICAgZ2V0IGxlYWRlcnMoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHRoZUxlYWRlcnMgPSBbXTtcbiAgICAgICAgLy9maW5kIGFsbCB0aGUgbGVhZGVyc1xuICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICAgICAgICAgIGxldCBsZWFkZXIgPSBjbG9zZXN0TGVhZGVyKHRoZUxlYWRlcnMsIHBvaW50KTtcbiAgICAgICAgICAgIGlmICghbGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5ld0xlYWRlciA9IFtdO1xuICAgICAgICAgICAgICAgIG5ld0xlYWRlci5zaXRlID0gcG9pbnQuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGVMZWFkZXJzLnB1c2gobmV3TGVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vbm93IGRvIHRoaXMgYWdhaW4gdG8gc2V0IHRoZSBjbG9zZXN0IGxlYWRlci5cbiAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaChwb2ludCA9PiB7XG4gICAgICAgICAgICBsZXQgbGVhZGVyID0gY2xvc2VzdExlYWRlcih0aGVMZWFkZXJzLCBwb2ludCk7XG4gICAgICAgICAgICBsZWFkZXIucHVzaChwb2ludCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhlTGVhZGVycztcblxuICAgICAgICBmdW5jdGlvbiBjbG9zZXN0TGVhZGVyKGxlYWRlcnMsIHBvaW50KSB7XG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gbGVhZGVycy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGxldCB0aGVMZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBsID0gbGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgZCA9IGRpc3RhbmNlKGwuc2l0ZSwgcG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmIChkIDwgc2VsZi5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlTGVhZGVyID0gbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGVMZWFkZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgbGV0IHN1bXNxdWFyZWQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZCA9IGFbaV0gLSBiW2ldO1xuICAgICAgICBpZighTnVtYmVyLmlzTmFOKGQpKXtcbiAgICAgICAgICAgIHN1bXNxdWFyZWQgKz0gZCpkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vRm9yIGNvbXB1dGVyIHN0b3JhZ2UgaXNzdWUsIHNvbWUgY29vcmRpbmF0ZXMgb2YgdGhlIHNhbWUgZGlzdGFuY2UgbWF5IHJldHVybiBkaWZmZXJlbnQgZGlzdGFuY2VzIGlmIHdlIHVzZSBsb25nIGZsb2F0aW5nIHBvaW50XG4gICAgLy9TbyB0YWtlIG9ubHkgMTAgZGlnaXRzIGFmdGVyIHRoZSBmbG9hdGluZyBwb2ludHM9PiB0aGlzIGlzIHByZWNpc2UgZW5vdWdoIGFuZCBzdGlsbCBoYXZlIHRoZSBzYW1lIHZhbHVlcyBmb3IgdHdvIGRpZmZlcmVudCBsaW5lcyBvZiB0aGUgc2FtZSBkaXN0YW5jZVxuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydChzdW1zcXVhcmVkKSAqIE1hdGgucG93KDEwLCAxMCkpIC8gTWF0aC5wb3coMTAsIDEwKTtcbn0iLCIvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ibWVyc2hvbi8yNWE3NGY3YjFjN2NiZDA3ZTc0NTZhZjFkMmMwN2RhMVxuLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tydXNrYWwlMjdzX2FsZ29yaXRobVxcXG4vLyBEZXBlbmRzIG9uIERpc2pvaW50U2V0LlxuaW1wb3J0IF8gZnJvbSBcInVuZGVyc2NvcmVcIjtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZSB0aGUgcGFpcnMgYmV0d2VlbiBub2RlIGFuZCBpdHMgbGlua3MuXG4gKlxuICogQHBhcmFtIGxpbmtzXG4gKiBAcmV0dXJucyBbW1wibm9kZVgsbm9kZVlcIjogQXJyYXkobnVtYmVyT2ZMaW5rc1JlbGF0ZWRUb1RoZU5vZGVzKV1dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWlyTm9kZUxpbmtzKGxpbmtzKSB7XG4gICAgbGV0IG5lc3RlZEJ5Tm9kZXMgPSB7fTtcbiAgICBsaW5rcy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICBsZXQgc291cmNlS2V5ID0gbC5zb3VyY2Uuam9pbignLCcpO1xuICAgICAgICBpZiAoIW5lc3RlZEJ5Tm9kZXNbc291cmNlS2V5XSkge1xuICAgICAgICAgICAgbmVzdGVkQnlOb2Rlc1tzb3VyY2VLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbmVzdGVkQnlOb2Rlc1tzb3VyY2VLZXldLnB1c2gobCk7XG4gICAgICAgIGxldCB0YXJnZXRLZXkgPSBsLnRhcmdldC5qb2luKCcsJyk7XG4gICAgICAgIGlmICghbmVzdGVkQnlOb2Rlc1t0YXJnZXRLZXldKSB7XG4gICAgICAgICAgICBuZXN0ZWRCeU5vZGVzW3RhcmdldEtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBuZXN0ZWRCeU5vZGVzW3RhcmdldEtleV0ucHVzaChsKTtcbiAgICB9KTtcbiAgICAvL1BhaXIgdGhlIHJlc3VsdHNcbiAgICBsZXQgcGFpcmVkUmVzdWx0cyA9IF8ucGFpcnMobmVzdGVkQnlOb2Rlcyk7XG4gICAgcmV0dXJuIHBhaXJlZFJlc3VsdHM7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGNvcm5lcnMgKHRocmVlIHZlcnRpY2VzKSBvZiB2ZXJ0aWNlcyBvZiBkZWdyZWUgdHdvIGluIHRoZSBmb3IgbWF0IG9mXG4gKiBwb2ludDEsIHBvaW50MiwgcG9pbnQzID0+IHBvaW50MSBpcyB0aGUgdGhlIHZlcnRleCB3aXRoIGRlZ3JlZSB0d28gKHR3byBlZGdlcyBjb25uZWN0ZWQgdG8gaXQgYXJlIFtwb2ludDEsIHBvaW50Ml0gYW5kIFtwb2ludDEsIHBvaW50M10gKG9yZGVyIG9mIHRoZSBwb2ludHMgaW4gZWFjaCBlZGdlIGlzIG5vdCBpbXBvcnRhbnQpKS5cbiAqIEBwYXJhbSB0cmVlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFYyQ29ybmVyc0Zyb21UcmVlKHRyZWUpIHtcbiAgICBsZXQgcGFpcmVkUmVzdWx0cyA9IHBhaXJOb2RlTGlua3ModHJlZS5saW5rcyk7XG4gICAgLy9HZXQgYWxsIHBhaXJzIHdpdGggbGVuZ3RoID0gMiAoVjIpXG4gICAgbGV0IGFsbFYyID0gcGFpcmVkUmVzdWx0cy5maWx0ZXIocCA9PiBwWzFdLmxlbmd0aCA9PSAyKTtcblxuICAgIGxldCBhbGxDb3JuZXJzID0gYWxsVjIubWFwKHYyID0+IHtcbiAgICAgICAgbGV0IGNvcm5lciA9IFtdO1xuICAgICAgICAvL0ZpcnN0IHBvaW50IGlzIHRoZSBjb21tb24gdmVydGljZVxuICAgICAgICBjb3JuZXIucHVzaCh2MlswXS5zcGxpdCgnLCcpLm1hcChkID0+ICtkKSk7Ly9tYXAoZD0+K2QpIGlzIHRvIGNvbnZlcnQgdGhlIHN0cmluZ3MgaW50byBkaWdpdHNcbiAgICAgICAgLy9QdXNoIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0IGlmIHRoZXkgYXJlIG5vdCB0aGUgY29tbW9uIHZlcnRpY2VzIG9mIHRoZSB0d28gZWRnZXNcbiAgICAgICAgdjJbMV0uZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgIGlmIChsaW5rLnNvdXJjZS5qb2luKCcsJykgIT0gdjJbMF0pIHtcbiAgICAgICAgICAgICAgICBjb3JuZXIucHVzaChsaW5rLnNvdXJjZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcm5lci5wdXNoKGxpbmsudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb3JuZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFsbENvcm5lcnM7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdmVydGljZXMgd2l0aCBkZWdyZWUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIDJcbiAqIEBwYXJhbSB0cmVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxWMk9yR3JlYXRlckZyb21UcmVlKHRyZWUpIHtcbiAgICBsZXQgcGFpcmVkUmVzdWx0cyA9IHBhaXJOb2RlTGlua3ModHJlZS5saW5rcyk7XG4gICAgLy9HZXQgYWxsIHBhaXJzIHdpdGggbGVuZ3RoID49IDIgKFYyKVxuICAgIGxldCBhbGxHVEVWMiA9IHBhaXJlZFJlc3VsdHMuZmlsdGVyKHAgPT4gcFsxXS5sZW5ndGggPj0gMik7XG4gICAgcmV0dXJuIGFsbEdURVYyLm1hcCh2ID0+IHZbMF0uc3BsaXQoJywnKS5tYXAoTnVtYmVyKSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgc2luZ2xlIGRlZ3JlZSB2ZXJ0aWNlcyBmcm9tIGEgdHJlZVxuICogQHBhcmFtIHRyZWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFYxc0Zyb21UcmVlKHRyZWUpIHtcbiAgICBsZXQgcGFpcmVkUmVzdWx0cyA9IHBhaXJOb2RlTGlua3ModHJlZS5saW5rcyk7XG4gICAgLy9HZXQgYWxsIHBhaXJzIHdpdGggbGVuZ3RoID0gMSAoVjEpXG4gICAgbGV0IGFsbFYxID0gcGFpcmVkUmVzdWx0cy5maWx0ZXIocCA9PiBwWzFdLmxlbmd0aCA9PSAxKTtcbiAgICByZXR1cm4gYWxsVjEubWFwKHYxID0+IHYxWzBdLnNwbGl0KCcsJykubWFwKE51bWJlcikpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGdyYXBoIGZyb20gbWVzaFxuICogQHBhcmFtIHRyaWFuZ2xlcyBpcyBpbmZvcm0gb2Ygc2V0IG9mIHRyaWFuZ2xlcyBhcyB0aGUgcmVzdWx0IGZyb20gZGVsYXVuYXkgdHJpYW5ndWxhdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdyYXBoKHRldHJhaGVkcmEsIHdlaWdodHMpIHtcblxuICAgIGZ1bmN0aW9uIG1ha2VMaW5rKHNvdXJjZUlkLCB0YXJnZXRJZCwgd2VpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XCJzb3VyY2VcIjogc291cmNlSWQsIFwidGFyZ2V0XCI6IHRhcmdldElkLCBcIndlaWdodFwiOiB3ZWlnaHR9O1xuICAgIH1cblxuICAgIGxldCBncmFwaCA9IHt9O1xuICAgIGdyYXBoLm5vZGVzID0gW107XG4gICAgZ3JhcGgubGlua3MgPSBbXTtcbiAgICAvL0NyZWF0aW5nIG5vZGVzXG4gICAgdGV0cmFoZWRyYS5mb3JFYWNoKHQgPT4ge1xuICAgICAgICB0LmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgaWYgKCFpZEV4aXN0cyhncmFwaC5ub2RlcywgaWQpKSB7XG4gICAgICAgICAgICAgICAgZ3JhcGgubm9kZXMucHVzaChtYWtlTm9kZShpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vQ3JlYXRpbmcgbGlua3NcbiAgICB0ZXRyYWhlZHJhLmZvckVhY2godCA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwMSA9IHRbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCB0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAyID0gdFtqXTtcbiAgICAgICAgICAgICAgICBsZXQgaWQxID0gcDE7XG4gICAgICAgICAgICAgICAgbGV0IGlkMiA9IHAyO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gZGlzdGFuY2UocDEsIHAyLCB3ZWlnaHRzKTtcbiAgICAgICAgICAgICAgICBsZXQgbGluayA9IG1ha2VMaW5rKGlkMSwgaWQyLCBkaXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmtFeGlzdHMoZ3JhcGgubGlua3MsIGxpbmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmxpbmtzLnB1c2gobGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvL1RPRE86IG1heSBzb3J0IHRoZSBpZCBhbHBoYWJldGljYWxseSA9PiB3aGVuIGNyZWF0aW5nID0+IHNvIHdlIGNhbiBqdXN0IGNoZWNrIDEgY29uZGl0aW9uIG9ubHkuXG4gICAgZnVuY3Rpb24gbGlua0V4aXN0cyhsaW5rcywgbGluaykge1xuICAgICAgICBsZXQgbGVuZ3RoID0gbGlua3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChlcXVhbExpbmtzKGxpbmssIGxpbmtzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYXBoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYiwgd2VpZ2h0cykge1xuICAgIGxldCB0b3RhbFN1bVNxdWFyZWQgPSAwO1xuICAgIGlmICghd2VpZ2h0cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBkaWZmID0gKGFbaV0gLSBiW2ldKSAqIChhW2ldIC0gYltpXSk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihkaWZmKSkge1xuICAgICAgICAgICAgICAgIHRvdGFsU3VtU3F1YXJlZCArPSBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGlmZiA9IChhW2ldIC0gYltpXSkgKiAoYVtpXSAtIGJbaV0pO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZGlmZikpIHtcbiAgICAgICAgICAgICAgICB0b3RhbFN1bVNxdWFyZWQgKz0gZGlmZiAqIHdlaWdodHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4vL0ZvciBjb21wdXRlciBzdG9yYWdlIGlzc3VlLCBzb21lIGNvb3JkaW5hdGVzIG9mIHRoZSBzYW1lIGRpc3RhbmNlIG1heSByZXR1cm4gZGlmZmVyZW50IGRpc3RhbmNlcyBpZiB3ZSB1c2UgbG9uZyBmbG9hdGluZyBwb2ludFxuLy9TbyB0YWtlIG9ubHkgMTAgZGlnaXRzIGFmdGVyIHRoZSBmbG9hdGluZyBwb2ludHM9PiB0aGlzIGlzIHByZWNpc2UgZW5vdWdoIGFuZCBzdGlsbCBoYXZlIHRoZSBzYW1lIHZhbHVlcyBmb3IgdHdvIGRpZmZlcmVudCBsaW5lcyBvZiB0aGUgc2FtZSBkaXN0YW5jZVxuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguc3FydCh0b3RhbFN1bVNxdWFyZWQpICogTWF0aC5wb3coMTAsIDEwKSkgLyBNYXRoLnBvdygxMCwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxQb2ludHMoaWQxLCBpZDIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlkMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaWQxW2ldICE9PSBpZDJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50RXhpc3RzKHBvaW50cywgcG9pbnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcG9pbnQxID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAoZXF1YWxQb2ludHMocG9pbnQxLCBwb2ludCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsTGlua3MobDEsIGwyKSB7XG4gICAgcmV0dXJuIChlcXVhbFBvaW50cyhsMS5zb3VyY2UsIGwyLnNvdXJjZSkgJiYgZXF1YWxQb2ludHMobDEudGFyZ2V0LCBsMi50YXJnZXQpKSB8fFxuICAgICAgICAoZXF1YWxQb2ludHMobDEuc291cmNlLCBsMi50YXJnZXQpICYmIGVxdWFsUG9pbnRzKGwxLnRhcmdldCwgbDIuc291cmNlKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZEV4aXN0cyhub2RlcywgaWQpIHtcbiAgICBsZXQgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoZXF1YWxQb2ludHMobm9kZS5pZCwgaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTm9kZShpZCkge1xuICAgIHJldHVybiB7XCJpZFwiOiBpZH07XG59XG5cbi8qKlxuICogY3JlYXRlIHRoZSBtc3RcbiAqIEBwYXJhbSBncmFwaDogaW4gZm9ybSBvZiBub2RlcyBhbmQgbGlua3NcbiAqIEByZXR1cm5zIHt7bm9kZXM6IChzZWxlY3Rpb25fbm9kZXN8bm9kZXMpLCBsaW5rczogQXJyYXl9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXN0KGdyYXBoKSB7XG4gICAgbGV0IHZlcnRpY2VzID0gZ3JhcGgubm9kZXMsXG4gICAgICAgIGVkZ2VzID0gZ3JhcGgubGlua3Muc2xpY2UoMCksXG4gICAgICAgIHNlbGVjdGVkRWRnZXMgPSBbXSxcbiAgICAgICAgZm9yZXN0ID0gbmV3IERpc2pvaW50U2V0KCk7XG5cbiAgICAvLyBFYWNoIHZlcnRleCBiZWdpbnMgXCJkaXNjb25uZWN0ZWRcIiBhbmQgaXNvbGF0ZWQgZnJvbSBhbGwgdGhlIG90aGVycy5cbiAgICB2ZXJ0aWNlcy5mb3JFYWNoKCh2ZXJ0ZXgpID0+IHtcbiAgICAgICAgZm9yZXN0Lm1ha2VTZXQodmVydGV4LmlkKTtcbiAgICB9KTtcblxuICAgIC8vIFNvcnQgZWRnZXMgaW4gZGVzY2VuZGluZyBvcmRlciBvZiB3ZWlnaHQuIFdlIHdpbGwgcG9wIGVkZ2VzIGJlZ2lubmluZ1xuICAgIC8vIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgZWRnZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gLShhLndlaWdodCAtIGIud2VpZ2h0KTtcbiAgICB9KTtcblxuICAgIHdoaWxlIChlZGdlcy5sZW5ndGggJiYgZm9yZXN0LnNpemUoKSA+IDEpIHtcbiAgICAgICAgbGV0IGVkZ2UgPSBlZGdlcy5wb3AoKTtcblxuICAgICAgICBpZiAoZm9yZXN0LmZpbmQoZWRnZS5zb3VyY2UpICE9PSBmb3Jlc3QuZmluZChlZGdlLnRhcmdldCkpIHtcbiAgICAgICAgICAgIGZvcmVzdC51bmlvbihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuICAgICAgICAgICAgc2VsZWN0ZWRFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IHZlcnRpY2VzLFxuICAgICAgICBsaW5rczogc2VsZWN0ZWRFZGdlc1xuICAgIH1cbn1cblxuLy88ZWRpdG9yLWZvbGQgZGVzYz1cIlRoaXMgc2VjdGlvbiBpcyBmb3IgdGhlIGRpc2pvaW50IHNldFwiPlxuZnVuY3Rpb24gRGlzam9pbnRTZXQoKSB7XG4gICAgdGhpcy5pbmRleF8gPSB7fTtcbn1cblxuZnVuY3Rpb24gTm9kZShpZCkge1xuICAgIHRoaXMuaWRfID0gaWQ7XG4gICAgdGhpcy5wYXJlbnRfID0gdGhpcztcbiAgICB0aGlzLnJhbmtfID0gMDtcbn1cblxuRGlzam9pbnRTZXQucHJvdG90eXBlLm1ha2VTZXQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAoIXRoaXMuaW5kZXhfW2lkXSkge1xuICAgICAgICBsZXQgY3JlYXRlZCA9IG5ldyBOb2RlKGlkKTtcbiAgICAgICAgdGhpcy5pbmRleF9baWRdID0gY3JlYXRlZDtcbiAgICB9XG59XG5cbi8vIFJldHVybnMgdGhlIGlkIG9mIHRoZSByZXByZXNlbnRhdGl2ZSBlbGVtZW50IG9mIHRoaXMgc2V0IHRoYXQgKGlkKVxuLy8gYmVsb25ncyB0by5cbkRpc2pvaW50U2V0LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKHRoaXMuaW5kZXhfW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmluZGV4X1tpZF0ucGFyZW50XztcbiAgICB3aGlsZSAoY3VycmVudCAhPT0gY3VycmVudC5wYXJlbnRfKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudF87XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50LmlkXztcbn1cblxuRGlzam9pbnRTZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBsZXQgeFJvb3QgPSB0aGlzLmluZGV4X1t0aGlzLmZpbmQoeCldO1xuICAgIGxldCB5Um9vdCA9IHRoaXMuaW5kZXhfW3RoaXMuZmluZCh5KV07XG5cbiAgICBpZiAoeFJvb3QgPT09IHVuZGVmaW5lZCB8fCB5Um9vdCA9PT0gdW5kZWZpbmVkIHx8IHhSb290ID09PSB5Um9vdCkge1xuICAgICAgICAvLyB4IGFuZCB5IGFscmVhZHkgYmVsb25nIHRvIHRoZSBzYW1lIHNldC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh4Um9vdC5yYW5rIDwgeVJvb3QucmFuaykgeyAvLyBNb3ZlIHggaW50byB0aGUgc2V0IHkgaXMgYSBtZW1iZXIgb2YuXG4gICAgICAgIHhSb290LnBhcmVudF8gPSB5Um9vdDtcbiAgICB9IGVsc2UgaWYgKHlSb290LnJhbmtfIDwgeFJvb3QucmFua18pIHsgLy8gTW92ZSB5IGludG8gdGhlIHNldCB4IGlzIGEgbWVtYmVyIG9mLlxuICAgICAgICB5Um9vdC5wYXJlbnRfID0geFJvb3Q7XG4gICAgfSBlbHNlIHsgLy8gQXJiaXRyYXJpbHkgY2hvb3NlIHRvIG1vdmUgeSBpbnRvIHRoZSBzZXQgeCBpcyBhIG1lbWJlciBvZi5cbiAgICAgICAgeVJvb3QucGFyZW50XyA9IHhSb290O1xuICAgICAgICB4Um9vdC5yYW5rXysrO1xuICAgIH1cbn1cblxuLy8gUmV0dXJucyB0aGUgY3VycmVudCBudW1iZXIgb2YgZGlzam9pbnQgc2V0cy5cbkRpc2pvaW50U2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCB1bmlxdWVJbmRpY2VzID0ge307XG4gICAgT2JqZWN0LmtleXModGhpcy5pbmRleF8pLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIHVuaXF1ZUluZGljZXNbaWRdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModW5pcXVlSW5kaWNlcykubGVuZ3RoO1xufVxuLy88L2VkaXRvci1mb2xkPiIsImZ1bmN0aW9uIHIocil7dmFyIHQsbixlPXIubGVuZ3RoO2lmKDE9PT1lKXQ9MCxuPXJbMF1bMV07ZWxzZXtmb3IodmFyIG8sYSxoLGY9MCx1PTAsaT0wLGw9MCxnPTA7ZzxlO2crKylmKz1hPShvPXJbZ10pWzBdLHUrPWg9b1sxXSxpKz1hKmEsbCs9YSpoO249dS9lLSh0PShlKmwtZip1KS8oZSppLWYqZikpKmYvZX1yZXR1cm57bTp0LGI6bn19ZnVuY3Rpb24gdChyKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIHIuYityLm0qdH19ZnVuY3Rpb24gbihyKXtpZigwPT09ci5sZW5ndGgpcmV0dXJuIDA7Zm9yKHZhciB0LG49clswXSxlPTAsbz0xO288ci5sZW5ndGg7bysrKXQ9bityW29dLE1hdGguYWJzKG4pPj1NYXRoLmFicyhyW29dKT9lKz1uLXQrcltvXTplKz1yW29dLXQrbixuPXQ7cmV0dXJuIG4rZX1mdW5jdGlvbiBlKHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtZWFuIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO3JldHVybiBuKHIpL3IubGVuZ3RofWZ1bmN0aW9uIG8ocix0KXt2YXIgbixvLGE9ZShyKSxoPTA7aWYoMj09PXQpZm9yKG89MDtvPHIubGVuZ3RoO28rKyloKz0obj1yW29dLWEpKm47ZWxzZSBmb3Iobz0wO288ci5sZW5ndGg7bysrKWgrPU1hdGgucG93KHJbb10tYSx0KTtyZXR1cm4gaH1mdW5jdGlvbiBhKHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtyZXR1cm4gbyhyLDIpL3IubGVuZ3RofWZ1bmN0aW9uIGgocil7aWYoMT09PXIubGVuZ3RoKXJldHVybiAwO3ZhciB0PWEocik7cmV0dXJuIE1hdGguc3FydCh0KX1mdW5jdGlvbiBmKHIsdCl7aWYoci5sZW5ndGg8MilyZXR1cm4gMTtmb3IodmFyIG49MCxlPTA7ZTxyLmxlbmd0aDtlKyspbis9cltlXVsxXTtmb3IodmFyIG89bi9yLmxlbmd0aCxhPTAsaD0wO2g8ci5sZW5ndGg7aCsrKWErPU1hdGgucG93KG8tcltoXVsxXSwyKTtmb3IodmFyIGY9MCx1PTA7dTxyLmxlbmd0aDt1KyspZis9TWF0aC5wb3coclt1XVsxXS10KHJbdV1bMF0pLDIpO3JldHVybiAxLWYvYX1mdW5jdGlvbiB1KHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtb2RlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2lmKDE9PT1yLmxlbmd0aClyZXR1cm4gclswXTtmb3IodmFyIHQ9clswXSxuPU5hTixlPTAsbz0xLGE9MTthPHIubGVuZ3RoKzE7YSsrKXJbYV0hPT10PyhvPmUmJihlPW8sbj10KSxvPTEsdD1yW2FdKTpvKys7cmV0dXJuIG59ZnVuY3Rpb24gaShyKXtyZXR1cm4gci5zbGljZSgpLnNvcnQoZnVuY3Rpb24ocix0KXtyZXR1cm4gci10fSl9ZnVuY3Rpb24gbChyKXtyZXR1cm4gdShpKHIpKX1mdW5jdGlvbiBnKHIpe2Zvcih2YXIgdCxuPW5ldyBNYXAsZT0wLG89MDtvPHIubGVuZ3RoO28rKyl7dmFyIGE9bi5nZXQocltvXSk7dm9pZCAwPT09YT9hPTE6YSsrLGE+ZSYmKHQ9cltvXSxlPWEpLG4uc2V0KHJbb10sYSl9aWYoMD09PWUpdGhyb3cgbmV3IEVycm9yKFwibW9kZSByZXF1aXJlcyBhdCBsYXN0IG9uZSBkYXRhIHBvaW50XCIpO3JldHVybiB0fWZ1bmN0aW9uIHYocil7aWYoMD09PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm1pbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHQ9clswXSxuPTE7bjxyLmxlbmd0aDtuKyspcltuXTx0JiYodD1yW25dKTtyZXR1cm4gdH1mdW5jdGlvbiBjKHIpe2lmKDA9PT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJtYXggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciB0PXJbMF0sbj0xO248ci5sZW5ndGg7bisrKXJbbl0+dCYmKHQ9cltuXSk7cmV0dXJuIHR9ZnVuY3Rpb24gcyhyKXtpZigwPT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZXh0ZW50IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgdD1yWzBdLG49clswXSxlPTE7ZTxyLmxlbmd0aDtlKyspcltlXT5uJiYobj1yW2VdKSxyW2VdPHQmJih0PXJbZV0pO3JldHVyblt0LG5dfWZ1bmN0aW9uIHAocil7cmV0dXJuIHJbMF19ZnVuY3Rpb24gTShyKXtyZXR1cm4gcltyLmxlbmd0aC0xXX1mdW5jdGlvbiB3KHIpe3JldHVybltyWzBdLHJbci5sZW5ndGgtMV1dfWZ1bmN0aW9uIHEocil7Zm9yKHZhciB0PTAsbj0wO248ci5sZW5ndGg7bisrKXQrPXJbbl07cmV0dXJuIHR9ZnVuY3Rpb24gRShyKXtmb3IodmFyIHQ9MSxuPTA7bjxyLmxlbmd0aDtuKyspdCo9cltuXTtyZXR1cm4gdH1mdW5jdGlvbiB5KHIsdCl7dmFyIG49ci5sZW5ndGgqdDtpZigwPT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwicXVhbnRpbGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQuXCIpO2lmKHQ8MHx8dD4xKXRocm93IG5ldyBFcnJvcihcInF1YW50aWxlcyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMVwiKTtyZXR1cm4gMT09PXQ/cltyLmxlbmd0aC0xXTowPT09dD9yWzBdOm4lMSE9MD9yW01hdGguY2VpbChuKS0xXTpyLmxlbmd0aCUyPT0wPyhyW24tMV0rcltuXSkvMjpyW25dfWZ1bmN0aW9uIGIocix0LG4sZSl7Zm9yKG49bnx8MCxlPWV8fHIubGVuZ3RoLTE7ZT5uOyl7aWYoZS1uPjYwMCl7dmFyIG89ZS1uKzEsYT10LW4rMSxoPU1hdGgubG9nKG8pLGY9LjUqTWF0aC5leHAoMipoLzMpLHU9LjUqTWF0aC5zcXJ0KGgqZiooby1mKS9vKTthLW8vMjwwJiYodSo9LTEpLGIocix0LE1hdGgubWF4KG4sTWF0aC5mbG9vcih0LWEqZi9vK3UpKSxNYXRoLm1pbihlLE1hdGguZmxvb3IodCsoby1hKSpmL28rdSkpKX12YXIgaT1yW3RdLGw9bixnPWU7Zm9yKGQocixuLHQpLHJbZV0+aSYmZChyLG4sZSk7bDxnOyl7Zm9yKGQocixsLGcpLGwrKyxnLS07cltsXTxpOylsKys7Zm9yKDtyW2ddPmk7KWctLX1yW25dPT09aT9kKHIsbixnKTpkKHIsKytnLGUpLGc8PXQmJihuPWcrMSksdDw9ZyYmKGU9Zy0xKX19ZnVuY3Rpb24gZChyLHQsbil7dmFyIGU9clt0XTtyW3RdPXJbbl0scltuXT1lfWZ1bmN0aW9uIEkocix0KXt2YXIgbj1yLnNsaWNlKCk7aWYoQXJyYXkuaXNBcnJheSh0KSl7IWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuPVswXSxlPTA7ZTx0Lmxlbmd0aDtlKyspbi5wdXNoKE4oci5sZW5ndGgsdFtlXSkpO24ucHVzaChyLmxlbmd0aC0xKSxuLnNvcnQoQyk7dmFyIG89WzAsbi5sZW5ndGgtMV07Zm9yKDtvLmxlbmd0aDspe3ZhciBhPU1hdGguY2VpbChvLnBvcCgpKSxoPU1hdGguZmxvb3Ioby5wb3AoKSk7aWYoIShhLWg8PTEpKXt2YXIgZj1NYXRoLmZsb29yKChoK2EpLzIpO1AocixuW2ZdLE1hdGguZmxvb3IobltoXSksTWF0aC5jZWlsKG5bYV0pKSxvLnB1c2goaCxmLGYsYSl9fX0obix0KTtmb3IodmFyIGU9W10sbz0wO288dC5sZW5ndGg7bysrKWVbb109eShuLHRbb10pO3JldHVybiBlfXJldHVybiBQKG4sTihuLmxlbmd0aCx0KSwwLG4ubGVuZ3RoLTEpLHkobix0KX1mdW5jdGlvbiBQKHIsdCxuLGUpe3QlMT09MD9iKHIsdCxuLGUpOihiKHIsdD1NYXRoLmZsb29yKHQpLG4sZSksYihyLHQrMSx0KzEsZSkpfWZ1bmN0aW9uIEMocix0KXtyZXR1cm4gci10fWZ1bmN0aW9uIE4ocix0KXt2YXIgbj1yKnQ7cmV0dXJuIDE9PT10P3ItMTowPT09dD8wOm4lMSE9MD9NYXRoLmNlaWwobiktMTpyJTI9PTA/bi0uNTpufWZ1bmN0aW9uIF8ocix0KXtpZih0PHJbMF0pcmV0dXJuIDA7aWYodD5yW3IubGVuZ3RoLTFdKXJldHVybiAxO3ZhciBuPWZ1bmN0aW9uKHIsdCl7dmFyIG49MCxlPTAsbz1yLmxlbmd0aDtmb3IoO2U8bzspdDw9cltuPWUrbz4+PjFdP289bjplPS1+bjtyZXR1cm4gZX0ocix0KTtpZihyW25dIT09dClyZXR1cm4gbi9yLmxlbmd0aDtuKys7dmFyIGU9ZnVuY3Rpb24ocix0KXt2YXIgbj0wLGU9MCxvPXIubGVuZ3RoO2Zvcig7ZTxvOyl0Pj1yW249ZStvPj4+MV0/ZT0tfm46bz1uO3JldHVybiBlfShyLHQpO2lmKGU9PT1uKXJldHVybiBuL3IubGVuZ3RoO3ZhciBvPWUtbisxO3JldHVybiBvKihlK24pLzIvby9yLmxlbmd0aH1mdW5jdGlvbiBBKHIsdCl7cmV0dXJuIF8oaShyKSx0KX1mdW5jdGlvbiB6KHIpe3ZhciB0PUkociwuNzUpLG49SShyLC4yNSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQmJlwibnVtYmVyXCI9PXR5cGVvZiBuKXJldHVybiB0LW59ZnVuY3Rpb24gVShyKXtyZXR1cm4rSShyLC41KX1mdW5jdGlvbiBLKHIpe2Zvcih2YXIgdD1VKHIpLG49W10sZT0wO2U8ci5sZW5ndGg7ZSsrKW4ucHVzaChNYXRoLmFicyhyW2VdLXQpKTtyZXR1cm4gVShuKX1mdW5jdGlvbiBCKHIsdCl7dmFyIG49W107aWYodDwxKXRocm93IG5ldyBFcnJvcihcImNodW5rIHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtpZihNYXRoLmZsb29yKHQpIT09dCl0aHJvdyBuZXcgRXJyb3IoXCJjaHVuayBzaXplIG11c3QgYmUgYW4gaW50ZWdlclwiKTtmb3IodmFyIGU9MDtlPHIubGVuZ3RoO2UrPXQpbi5wdXNoKHIuc2xpY2UoZSxlK3QpKTtyZXR1cm4gbn1mdW5jdGlvbiBHKHIsdCxuKXtpZigwPT09ci5sZW5ndGgpcmV0dXJuW107bj1ufHxNYXRoLnJhbmRvbTtmb3IodmFyIGU9ci5sZW5ndGgsbz1bXSxhPTA7YTx0O2ErKyl7dmFyIGg9TWF0aC5mbG9vcihuKCkqZSk7by5wdXNoKHJbaF0pfXJldHVybiBvfWZ1bmN0aW9uIEgocix0KXt0PXR8fE1hdGgucmFuZG9tO2Zvcih2YXIgbixlLG89ci5sZW5ndGg7bz4wOyllPU1hdGguZmxvb3IodCgpKm8tLSksbj1yW29dLHJbb109cltlXSxyW2VdPW47cmV0dXJuIHJ9ZnVuY3Rpb24gSihyLHQpe3JldHVybiBIKHIuc2xpY2UoKS5zbGljZSgpLHQpfWZ1bmN0aW9uIFEocix0LG4pe3JldHVybiBKKHIsbikuc2xpY2UoMCx0KX1mdW5jdGlvbiBSKHIpe2Zvcih2YXIgdCxuPTAsZT0wO2U8ci5sZW5ndGg7ZSsrKTAhPT1lJiZyW2VdPT09dHx8KHQ9cltlXSxuKyspO3JldHVybiBufWZ1bmN0aW9uIFcocix0KXtmb3IodmFyIG49W10sZT0wO2U8cjtlKyspe2Zvcih2YXIgbz1bXSxhPTA7YTx0O2ErKylvLnB1c2goMCk7bi5wdXNoKG8pfXJldHVybiBufWZ1bmN0aW9uIFkocix0LG4sZSl7dmFyIG87aWYocj4wKXt2YXIgYT0oblt0XS1uW3ItMV0pLyh0LXIrMSk7bz1lW3RdLWVbci0xXS0odC1yKzEpKmEqYX1lbHNlIG89ZVt0XS1uW3RdKm5bdF0vKHQrMSk7cmV0dXJuIG88MD8wOm99ZnVuY3Rpb24gWihyLHQsbixlLG8sYSxoKXtpZighKHI+dCkpe3ZhciBmPU1hdGguZmxvb3IoKHIrdCkvMik7ZVtuXVtmXT1lW24tMV1bZi0xXSxvW25dW2ZdPWY7dmFyIHU9bjtyPm4mJih1PU1hdGgubWF4KHUsb1tuXVtyLTFdfHwwKSksdT1NYXRoLm1heCh1LG9bbi0xXVtmXXx8MCk7dmFyIGksbCxnLHY9Zi0xO3Q8ZS5sZW5ndGgtMSYmKHY9TWF0aC5taW4odixvW25dW3QrMV18fDApKTtmb3IodmFyIGM9djtjPj11JiYhKChpPVkoYyxmLGEsaCkpK2Vbbi0xXVt1LTFdPj1lW25dW2ZdKTstLWMpKGw9WSh1LGYsYSxoKStlW24tMV1bdS0xXSk8ZVtuXVtmXSYmKGVbbl1bZl09bCxvW25dW2ZdPXUpLHUrKywoZz1pK2Vbbi0xXVtjLTFdKTxlW25dW2ZdJiYoZVtuXVtmXT1nLG9bbl1bZl09Yyk7WihyLGYtMSxuLGUsbyxhLGgpLFooZisxLHQsbixlLG8sYSxoKX19ZnVuY3Rpb24geChyLHQpe2lmKHQ+ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGdlbmVyYXRlIG1vcmUgY2xhc3NlcyB0aGFuIHRoZXJlIGFyZSBkYXRhIHZhbHVlc1wiKTt2YXIgbj1pKHIpO2lmKDE9PT1SKG4pKXJldHVybltuXTt2YXIgZT1XKHQsbi5sZW5ndGgpLG89Vyh0LG4ubGVuZ3RoKTshZnVuY3Rpb24ocix0LG4pe2Zvcih2YXIgZT10WzBdLmxlbmd0aCxvPXJbTWF0aC5mbG9vcihlLzIpXSxhPVtdLGg9W10sZj0wLHU9dm9pZCAwO2Y8ZTsrK2YpdT1yW2ZdLW8sMD09PWY/KGEucHVzaCh1KSxoLnB1c2godSp1KSk6KGEucHVzaChhW2YtMV0rdSksaC5wdXNoKGhbZi0xXSt1KnUpKSx0WzBdW2ZdPVkoMCxmLGEsaCksblswXVtmXT0wO2Zvcih2YXIgaT0xO2k8dC5sZW5ndGg7KytpKVooaTx0Lmxlbmd0aC0xP2k6ZS0xLGUtMSxpLHQsbixhLGgpfShuLGUsbyk7Zm9yKHZhciBhPVtdLGg9b1swXS5sZW5ndGgtMSxmPW8ubGVuZ3RoLTE7Zj49MDtmLS0pe3ZhciB1PW9bZl1baF07YVtmXT1uLnNsaWNlKHUsaCsxKSxmPjAmJihoPXUtMSl9cmV0dXJuIGF9ZnVuY3Rpb24gVChyLHQpe2lmKHIubGVuZ3RoPDIpcmV0dXJuIHI7Zm9yKHZhciBuPXYociksZT1jKHIpLG89W25dLGE9KGUtbikvdCxoPTE7aDx0O2grKylvLnB1c2gob1swXSthKmgpO3JldHVybiBvLnB1c2goZSksb31mdW5jdGlvbiBEKHIsdCl7aWYoci5sZW5ndGghPT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVDb3ZhcmlhbmNlIHJlcXVpcmVzIHNhbXBsZXMgd2l0aCBlcXVhbCBsZW5ndGhzXCIpO2lmKHIubGVuZ3RoPDIpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlQ292YXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gZGF0YSBwb2ludHMgaW4gZWFjaCBzYW1wbGVcIik7Zm9yKHZhciBuPWUociksbz1lKHQpLGE9MCxoPTA7aDxyLmxlbmd0aDtoKyspYSs9KHJbaF0tbikqKHRbaF0tbyk7cmV0dXJuIGEvKHIubGVuZ3RoLTEpfWZ1bmN0aW9uIEwocil7aWYoci5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVWYXJpYW5jZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gZGF0YSBwb2ludHNcIik7cmV0dXJuIG8ociwyKS8oci5sZW5ndGgtMSl9ZnVuY3Rpb24gTyhyKXt2YXIgdD1MKHIpO3JldHVybiBNYXRoLnNxcnQodCl9ZnVuY3Rpb24gWChyLHQpe3JldHVybiBEKHIsdCkvTyhyKS9PKHQpfWZ1bmN0aW9uIFYocil7aWYoci5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJzYW1wbGVTa2V3bmVzcyByZXF1aXJlcyBhdCBsZWFzdCB0aHJlZSBkYXRhIHBvaW50c1wiKTtmb3IodmFyIHQsbj1lKHIpLG89MCxhPTAsaD0wO2g8ci5sZW5ndGg7aCsrKW8rPSh0PXJbaF0tbikqdCxhKz10KnQqdDt2YXIgZj1NYXRoLnNxcnQoby8oci5sZW5ndGgtMSkpLHU9ci5sZW5ndGg7cmV0dXJuIHUqYS8oKHUtMSkqKHUtMikqTWF0aC5wb3coZiwzKSl9ZnVuY3Rpb24gbShyKXt2YXIgdD1yLmxlbmd0aDtpZih0PDQpdGhyb3cgbmV3IEVycm9yKFwic2FtcGxlS3VydG9zaXMgcmVxdWlyZXMgYXQgbGVhc3QgZm91ciBkYXRhIHBvaW50c1wiKTtmb3IodmFyIG4sbz1lKHIpLGE9MCxoPTAsZj0wO2Y8dDtmKyspYSs9KG49cltmXS1vKSpuLGgrPW4qbipuKm47cmV0dXJuKHQtMSkvKCh0LTIpKih0LTMpKSoodCoodCsxKSpoLyhhKmEpLTMqKHQtMSkpfWZ1bmN0aW9uIEYocil7Zm9yKHZhciB0PW5ldyBBcnJheShyLmxlbmd0aCksbj1bci5zbGljZSgpXSxlPTA7ZTxyLmxlbmd0aDtlKyspdFtlXT0wO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7KWlmKHRbb108byl7dmFyIGE9MDtvJTIhPTAmJihhPXRbb10pO3ZhciBoPXJbYV07clthXT1yW29dLHJbb109aCxuLnB1c2goci5zbGljZSgpKSx0W29dKyssbz0wfWVsc2UgdFtvXT0wLG8rKztyZXR1cm4gbn1mdW5jdGlvbiBrKHIsdCl7dmFyIG4sZSxvLGEsaD1bXTtmb3Iobj0wO248ci5sZW5ndGg7bisrKWlmKDE9PT10KWgucHVzaChbcltuXV0pO2Vsc2UgZm9yKG89ayhyLnNsaWNlKG4rMSxyLmxlbmd0aCksdC0xKSxlPTA7ZTxvLmxlbmd0aDtlKyspKGE9b1tlXSkudW5zaGlmdChyW25dKSxoLnB1c2goYSk7cmV0dXJuIGh9ZnVuY3Rpb24gUyhyLHQpe2Zvcih2YXIgbj1bXSxlPTA7ZTxyLmxlbmd0aDtlKyspaWYoMT09PXQpbi5wdXNoKFtyW2VdXSk7ZWxzZSBmb3IodmFyIG89UyhyLnNsaWNlKGUsci5sZW5ndGgpLHQtMSksYT0wO2E8by5sZW5ndGg7YSsrKW4ucHVzaChbcltlXV0uY29uY2F0KG9bYV0pKTtyZXR1cm4gbn1mdW5jdGlvbiBqKHIsdCxuKXtyZXR1cm4gcisobi1yKS8odCsxKX1mdW5jdGlvbiAkKHIsdCxuLGUpe3JldHVybihyKnQrbiplKS8odCtlKX1mdW5jdGlvbiBycihyLHQsbixlLG8sYSl7dmFyIGg9JCh0LG4sbyxhKTtyZXR1cm4obioocitNYXRoLnBvdyh0LWgsMikpK2EqKGUrTWF0aC5wb3coby1oLDIpKSkvKG4rYSl9ZnVuY3Rpb24gdHIocil7aWYoMD09PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImdlb21ldHJpY01lYW4gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGRhdGEgcG9pbnRcIik7Zm9yKHZhciB0PTEsbj0wO248ci5sZW5ndGg7bisrKXtpZihyW25dPD0wKXRocm93IG5ldyBFcnJvcihcImdlb21ldHJpY01lYW4gcmVxdWlyZXMgb25seSBwb3NpdGl2ZSBudW1iZXJzIGFzIGlucHV0XCIpO3QqPXJbbl19cmV0dXJuIE1hdGgucG93KHQsMS9yLmxlbmd0aCl9ZnVuY3Rpb24gbnIocil7aWYoMD09PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImhhcm1vbmljTWVhbiByZXF1aXJlcyBhdCBsZWFzdCBvbmUgZGF0YSBwb2ludFwiKTtmb3IodmFyIHQ9MCxuPTA7bjxyLmxlbmd0aDtuKyspe2lmKHJbbl08PTApdGhyb3cgbmV3IEVycm9yKFwiaGFybW9uaWNNZWFuIHJlcXVpcmVzIG9ubHkgcG9zaXRpdmUgbnVtYmVycyBhcyBpbnB1dFwiKTt0Kz0xL3Jbbl19cmV0dXJuIHIubGVuZ3RoL3R9ZnVuY3Rpb24gZXIocil7cmV0dXJuIHkociwuNSl9ZnVuY3Rpb24gb3Iocix0LG4pe3JldHVybihyKnQtbikvKHQtMSl9ZnVuY3Rpb24gYXIocil7aWYoMD09PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInJvb3RNZWFuU3F1YXJlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBkYXRhIHBvaW50XCIpO2Zvcih2YXIgdD0wLG49MDtuPHIubGVuZ3RoO24rKyl0Kz1NYXRoLnBvdyhyW25dLDIpO3JldHVybiBNYXRoLnNxcnQodC9yLmxlbmd0aCl9ZnVuY3Rpb24gaHIocix0KXtyZXR1cm4oZShyKS10KS8oaChyKS9NYXRoLnNxcnQoci5sZW5ndGgpKX1mdW5jdGlvbiBmcihyLHQsbil7dmFyIG89ci5sZW5ndGgsYT10Lmxlbmd0aDtpZighb3x8IWEpcmV0dXJuIG51bGw7bnx8KG49MCk7dmFyIGg9ZShyKSxmPWUodCksdT1MKHIpLGk9TCh0KTtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgaCYmXCJudW1iZXJcIj09dHlwZW9mIGYmJlwibnVtYmVyXCI9PXR5cGVvZiB1JiZcIm51bWJlclwiPT10eXBlb2YgaT8oaC1mLW4pL01hdGguc3FydCgoKG8tMSkqdSsoYS0xKSppKS8obythLTIpKigxL28rMS9hKSk6dm9pZCAwfXZhciB1cj1mdW5jdGlvbigpe3RoaXMudG90YWxDb3VudD0wLHRoaXMuZGF0YT17fX07dXIucHJvdG90eXBlLnRyYWluPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBuIGluIHRoaXMuZGF0YVt0XXx8KHRoaXMuZGF0YVt0XT17fSkscil7dmFyIGU9cltuXTt2b2lkIDA9PT10aGlzLmRhdGFbdF1bbl0mJih0aGlzLmRhdGFbdF1bbl09e30pLHZvaWQgMD09PXRoaXMuZGF0YVt0XVtuXVtlXSYmKHRoaXMuZGF0YVt0XVtuXVtlXT0wKSx0aGlzLmRhdGFbdF1bbl1bZV0rK310aGlzLnRvdGFsQ291bnQrK30sdXIucHJvdG90eXBlLnNjb3JlPWZ1bmN0aW9uKHIpe3ZhciB0LG49e307Zm9yKHZhciBlIGluIHIpe3ZhciBvPXJbZV07Zm9yKHQgaW4gdGhpcy5kYXRhKW5bdF09e30sblt0XVtlK1wiX1wiK29dPXRoaXMuZGF0YVt0XVtlXT8odGhpcy5kYXRhW3RdW2VdW29dfHwwKS90aGlzLnRvdGFsQ291bnQ6MH12YXIgYT17fTtmb3IodCBpbiBuKWZvcih2YXIgaCBpbiBhW3RdPTAsblt0XSlhW3RdKz1uW3RdW2hdO3JldHVybiBhfTt2YXIgaXI9ZnVuY3Rpb24oKXt0aGlzLndlaWdodHM9W10sdGhpcy5iaWFzPTB9O2lyLnByb3RvdHlwZS5wcmVkaWN0PWZ1bmN0aW9uKHIpe2lmKHIubGVuZ3RoIT09dGhpcy53ZWlnaHRzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIHQ9MCxuPTA7bjx0aGlzLndlaWdodHMubGVuZ3RoO24rKyl0Kz10aGlzLndlaWdodHNbbl0qcltuXTtyZXR1cm4odCs9dGhpcy5iaWFzKT4wPzE6MH0saXIucHJvdG90eXBlLnRyYWluPWZ1bmN0aW9uKHIsdCl7aWYoMCE9PXQmJjEhPT10KXJldHVybiBudWxsO3IubGVuZ3RoIT09dGhpcy53ZWlnaHRzLmxlbmd0aCYmKHRoaXMud2VpZ2h0cz1yLHRoaXMuYmlhcz0xKTt2YXIgbj10aGlzLnByZWRpY3Qocik7aWYoXCJudW1iZXJcIj09dHlwZW9mIG4mJm4hPT10KXtmb3IodmFyIGU9dC1uLG89MDtvPHRoaXMud2VpZ2h0cy5sZW5ndGg7bysrKXRoaXMud2VpZ2h0c1tvXSs9ZSpyW29dO3RoaXMuYmlhcys9ZX1yZXR1cm4gdGhpc307dmFyIGxyPTFlLTQ7ZnVuY3Rpb24gZ3Iocil7aWYocjwwKXRocm93IG5ldyBFcnJvcihcImZhY3RvcmlhbCByZXF1aXJlcyBhIG5vbi1uZWdhdGl2ZSB2YWx1ZVwiKTtpZihNYXRoLmZsb29yKHIpIT09cil0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3JpYWwgcmVxdWlyZXMgYW4gaW50ZWdlciBpbnB1dFwiKTtmb3IodmFyIHQ9MSxuPTI7bjw9cjtuKyspdCo9bjtyZXR1cm4gdH1mdW5jdGlvbiB2cihyKXtpZihOdW1iZXIuaXNJbnRlZ2VyKHIpKXJldHVybiByPD0wP05hTjpncihyLTEpO2lmKC0tcjwwKXJldHVybiBNYXRoLlBJLyhNYXRoLnNpbihNYXRoLlBJKi1yKSp2cigtcikpO3ZhciB0PXIrLjI1O3JldHVybiBNYXRoLnBvdyhyL01hdGguRSxyKSpNYXRoLnNxcnQoMipNYXRoLlBJKihyKzEvNikpKigxKzEvMTQ0L01hdGgucG93KHQsMiktMS8xMjk2MC9NYXRoLnBvdyh0LDMpLTI1Ny8yMDczNjAvTWF0aC5wb3codCw0KS01Mi8yNjEyNzM2L01hdGgucG93KHQsNSkrNTc0MTE3My85NDA1ODQ5NjAwL01hdGgucG93KHQsNikrMzc1MjkvMTg4MTE2OTkyMDAvTWF0aC5wb3codCw3KSl9dmFyIGNyPVsuOTk5OTk5OTk5OTk5OTk3MSw1Ny4xNTYyMzU2NjU4NjI5MiwtNTkuNTk3OTYwMzU1NDc1NDksMTQuMTM2MDk3OTc0NzQxNzQ2LC0uNDkxOTEzODE2MDk3NjIwMiwzMzk5NDY0OTk4NDgxMTg5ZS0yMCw0NjUyMzYyODkyNzA0ODU4ZS0yMCwtOTgzNzQ0NzUzMDQ4Nzk1NmUtMjAsLjAwMDE1ODA4ODcwMzIyNDkxMjUsLS4wMDAyMTAyNjQ0NDE3MjQxMDQ4OCwuMDAwMjE3NDM5NjE4MTE1MjEyNjUsLS4wMDAxNjQzMTgxMDY1MzY3NjM5LDg0NDE4MjIzOTgzODUyNzVlLTIwLC0yNjE5MDgzODQwMTU4MTQwOGUtMjEsMzY4OTkxODI2NTk1MzE2MjVlLTIyXSxzcj02MDcvMTI4LHByPU1hdGgubG9nKE1hdGguc3FydCgyKk1hdGguUEkpKTtmdW5jdGlvbiBNcihyKXtpZihyPD0wKXJldHVybiBJbmZpbml0eTtyLS07Zm9yKHZhciB0PWNyWzBdLG49MTtuPDE1O24rKyl0Kz1jcltuXS8ocituKTt2YXIgZT1zcisuNStyO3JldHVybiBwcitNYXRoLmxvZyh0KS1lKyhyKy41KSpNYXRoLmxvZyhlKX1mdW5jdGlvbiB3cihyKXtpZihyPDB8fHI+MSl0aHJvdyBuZXcgRXJyb3IoXCJiZXJub3VsbGlEaXN0cmlidXRpb24gcmVxdWlyZXMgcHJvYmFiaWxpdHkgdG8gYmUgYmV0d2VlbiAwIGFuZCAxIGluY2x1c2l2ZVwiKTtyZXR1cm5bMS1yLHJdfWZ1bmN0aW9uIHFyKHIsdCl7aWYoISh0PDB8fHQ+MXx8cjw9MHx8ciUxIT0wKSl7dmFyIG49MCxlPTAsbz1bXSxhPTE7ZG97b1tuXT1hKk1hdGgucG93KHQsbikqTWF0aC5wb3coMS10LHItbiksZSs9b1tuXSxhPWEqKHItKytuKzEpL259d2hpbGUoZTwxLWxyKTtyZXR1cm4gb319ZnVuY3Rpb24gRXIocil7aWYoIShyPD0wKSl7dmFyIHQ9MCxuPTAsZT1bXSxvPTE7ZG97ZVt0XT1NYXRoLmV4cCgtcikqTWF0aC5wb3cocix0KS9vLG4rPWVbdF0sbyo9Kyt0fXdoaWxlKG48MS1scik7cmV0dXJuIGV9fXZhciB5cj17MTp7Ljk5NTowLC45OTowLC45NzU6MCwuOTU6MCwuOTouMDIsLjU6LjQ1LC4xOjIuNzEsLjA1OjMuODQsLjAyNTo1LjAyLC4wMTo2LjYzLC4wMDU6Ny44OH0sMjp7Ljk5NTouMDEsLjk5Oi4wMiwuOTc1Oi4wNSwuOTU6LjEsLjk6LjIxLC41OjEuMzksLjE6NC42MSwuMDU6NS45OSwuMDI1OjcuMzgsLjAxOjkuMjEsLjAwNToxMC42fSwzOnsuOTk1Oi4wNywuOTk6LjExLC45NzU6LjIyLC45NTouMzUsLjk6LjU4LC41OjIuMzcsLjE6Ni4yNSwuMDU6Ny44MSwuMDI1OjkuMzUsLjAxOjExLjM0LC4wMDU6MTIuODR9LDQ6ey45OTU6LjIxLC45OTouMywuOTc1Oi40OCwuOTU6LjcxLC45OjEuMDYsLjU6My4zNiwuMTo3Ljc4LC4wNTo5LjQ5LC4wMjU6MTEuMTQsLjAxOjEzLjI4LC4wMDU6MTQuODZ9LDU6ey45OTU6LjQxLC45OTouNTUsLjk3NTouODMsLjk1OjEuMTUsLjk6MS42MSwuNTo0LjM1LC4xOjkuMjQsLjA1OjExLjA3LC4wMjU6MTIuODMsLjAxOjE1LjA5LC4wMDU6MTYuNzV9LDY6ey45OTU6LjY4LC45OTouODcsLjk3NToxLjI0LC45NToxLjY0LC45OjIuMiwuNTo1LjM1LC4xOjEwLjY1LC4wNToxMi41OSwuMDI1OjE0LjQ1LC4wMToxNi44MSwuMDA1OjE4LjU1fSw3OnsuOTk1Oi45OSwuOTk6MS4yNSwuOTc1OjEuNjksLjk1OjIuMTcsLjk6Mi44MywuNTo2LjM1LC4xOjEyLjAyLC4wNToxNC4wNywuMDI1OjE2LjAxLC4wMToxOC40OCwuMDA1OjIwLjI4fSw4OnsuOTk1OjEuMzQsLjk5OjEuNjUsLjk3NToyLjE4LC45NToyLjczLC45OjMuNDksLjU6Ny4zNCwuMToxMy4zNiwuMDU6MTUuNTEsLjAyNToxNy41MywuMDE6MjAuMDksLjAwNToyMS45Nn0sOTp7Ljk5NToxLjczLC45OToyLjA5LC45NzU6Mi43LC45NTozLjMzLC45OjQuMTcsLjU6OC4zNCwuMToxNC42OCwuMDU6MTYuOTIsLjAyNToxOS4wMiwuMDE6MjEuNjcsLjAwNToyMy41OX0sMTA6ey45OTU6Mi4xNiwuOTk6Mi41NiwuOTc1OjMuMjUsLjk1OjMuOTQsLjk6NC44NywuNTo5LjM0LC4xOjE1Ljk5LC4wNToxOC4zMSwuMDI1OjIwLjQ4LC4wMToyMy4yMSwuMDA1OjI1LjE5fSwxMTp7Ljk5NToyLjYsLjk5OjMuMDUsLjk3NTozLjgyLC45NTo0LjU3LC45OjUuNTgsLjU6MTAuMzQsLjE6MTcuMjgsLjA1OjE5LjY4LC4wMjU6MjEuOTIsLjAxOjI0LjcyLC4wMDU6MjYuNzZ9LDEyOnsuOTk1OjMuMDcsLjk5OjMuNTcsLjk3NTo0LjQsLjk1OjUuMjMsLjk6Ni4zLC41OjExLjM0LC4xOjE4LjU1LC4wNToyMS4wMywuMDI1OjIzLjM0LC4wMToyNi4yMiwuMDA1OjI4LjN9LDEzOnsuOTk1OjMuNTcsLjk5OjQuMTEsLjk3NTo1LjAxLC45NTo1Ljg5LC45OjcuMDQsLjU6MTIuMzQsLjE6MTkuODEsLjA1OjIyLjM2LC4wMjU6MjQuNzQsLjAxOjI3LjY5LC4wMDU6MjkuODJ9LDE0OnsuOTk1OjQuMDcsLjk5OjQuNjYsLjk3NTo1LjYzLC45NTo2LjU3LC45OjcuNzksLjU6MTMuMzQsLjE6MjEuMDYsLjA1OjIzLjY4LC4wMjU6MjYuMTIsLjAxOjI5LjE0LC4wMDU6MzEuMzJ9LDE1OnsuOTk1OjQuNiwuOTk6NS4yMywuOTc1OjYuMjcsLjk1OjcuMjYsLjk6OC41NSwuNToxNC4zNCwuMToyMi4zMSwuMDU6MjUsLjAyNToyNy40OSwuMDE6MzAuNTgsLjAwNTozMi44fSwxNjp7Ljk5NTo1LjE0LC45OTo1LjgxLC45NzU6Ni45MSwuOTU6Ny45NiwuOTo5LjMxLC41OjE1LjM0LC4xOjIzLjU0LC4wNToyNi4zLC4wMjU6MjguODUsLjAxOjMyLC4wMDU6MzQuMjd9LDE3OnsuOTk1OjUuNywuOTk6Ni40MSwuOTc1OjcuNTYsLjk1OjguNjcsLjk6MTAuMDksLjU6MTYuMzQsLjE6MjQuNzcsLjA1OjI3LjU5LC4wMjU6MzAuMTksLjAxOjMzLjQxLC4wMDU6MzUuNzJ9LDE4OnsuOTk1OjYuMjYsLjk5OjcuMDEsLjk3NTo4LjIzLC45NTo5LjM5LC45OjEwLjg3LC41OjE3LjM0LC4xOjI1Ljk5LC4wNToyOC44NywuMDI1OjMxLjUzLC4wMTozNC44MSwuMDA1OjM3LjE2fSwxOTp7Ljk5NTo2Ljg0LC45OTo3LjYzLC45NzU6OC45MSwuOTU6MTAuMTIsLjk6MTEuNjUsLjU6MTguMzQsLjE6MjcuMiwuMDU6MzAuMTQsLjAyNTozMi44NSwuMDE6MzYuMTksLjAwNTozOC41OH0sMjA6ey45OTU6Ny40MywuOTk6OC4yNiwuOTc1OjkuNTksLjk1OjEwLjg1LC45OjEyLjQ0LC41OjE5LjM0LC4xOjI4LjQxLC4wNTozMS40MSwuMDI1OjM0LjE3LC4wMTozNy41NywuMDA1OjQwfSwyMTp7Ljk5NTo4LjAzLC45OTo4LjksLjk3NToxMC4yOCwuOTU6MTEuNTksLjk6MTMuMjQsLjU6MjAuMzQsLjE6MjkuNjIsLjA1OjMyLjY3LC4wMjU6MzUuNDgsLjAxOjM4LjkzLC4wMDU6NDEuNH0sMjI6ey45OTU6OC42NCwuOTk6OS41NCwuOTc1OjEwLjk4LC45NToxMi4zNCwuOToxNC4wNCwuNToyMS4zNCwuMTozMC44MSwuMDU6MzMuOTIsLjAyNTozNi43OCwuMDE6NDAuMjksLjAwNTo0Mi44fSwyMzp7Ljk5NTo5LjI2LC45OToxMC4yLC45NzU6MTEuNjksLjk1OjEzLjA5LC45OjE0Ljg1LC41OjIyLjM0LC4xOjMyLjAxLC4wNTozNS4xNywuMDI1OjM4LjA4LC4wMTo0MS42NCwuMDA1OjQ0LjE4fSwyNDp7Ljk5NTo5Ljg5LC45OToxMC44NiwuOTc1OjEyLjQsLjk1OjEzLjg1LC45OjE1LjY2LC41OjIzLjM0LC4xOjMzLjIsLjA1OjM2LjQyLC4wMjU6MzkuMzYsLjAxOjQyLjk4LC4wMDU6NDUuNTZ9LDI1OnsuOTk1OjEwLjUyLC45OToxMS41MiwuOTc1OjEzLjEyLC45NToxNC42MSwuOToxNi40NywuNToyNC4zNCwuMTozNC4yOCwuMDU6MzcuNjUsLjAyNTo0MC42NSwuMDE6NDQuMzEsLjAwNTo0Ni45M30sMjY6ey45OTU6MTEuMTYsLjk5OjEyLjIsLjk3NToxMy44NCwuOTU6MTUuMzgsLjk6MTcuMjksLjU6MjUuMzQsLjE6MzUuNTYsLjA1OjM4Ljg5LC4wMjU6NDEuOTIsLjAxOjQ1LjY0LC4wMDU6NDguMjl9LDI3OnsuOTk1OjExLjgxLC45OToxMi44OCwuOTc1OjE0LjU3LC45NToxNi4xNSwuOToxOC4xMSwuNToyNi4zNCwuMTozNi43NCwuMDU6NDAuMTEsLjAyNTo0My4xOSwuMDE6NDYuOTYsLjAwNTo0OS42NX0sMjg6ey45OTU6MTIuNDYsLjk5OjEzLjU3LC45NzU6MTUuMzEsLjk1OjE2LjkzLC45OjE4Ljk0LC41OjI3LjM0LC4xOjM3LjkyLC4wNTo0MS4zNCwuMDI1OjQ0LjQ2LC4wMTo0OC4yOCwuMDA1OjUwLjk5fSwyOTp7Ljk5NToxMy4xMiwuOTk6MTQuMjYsLjk3NToxNi4wNSwuOTU6MTcuNzEsLjk6MTkuNzcsLjU6MjguMzQsLjE6MzkuMDksLjA1OjQyLjU2LC4wMjU6NDUuNzIsLjAxOjQ5LjU5LC4wMDU6NTIuMzR9LDMwOnsuOTk1OjEzLjc5LC45OToxNC45NSwuOTc1OjE2Ljc5LC45NToxOC40OSwuOToyMC42LC41OjI5LjM0LC4xOjQwLjI2LC4wNTo0My43NywuMDI1OjQ2Ljk4LC4wMTo1MC44OSwuMDA1OjUzLjY3fSw0MDp7Ljk5NToyMC43MSwuOTk6MjIuMTYsLjk3NToyNC40MywuOTU6MjYuNTEsLjk6MjkuMDUsLjU6MzkuMzQsLjE6NTEuODEsLjA1OjU1Ljc2LC4wMjU6NTkuMzQsLjAxOjYzLjY5LC4wMDU6NjYuNzd9LDUwOnsuOTk1OjI3Ljk5LC45OToyOS43MSwuOTc1OjMyLjM2LC45NTozNC43NiwuOTozNy42OSwuNTo0OS4zMywuMTo2My4xNywuMDU6NjcuNSwuMDI1OjcxLjQyLC4wMTo3Ni4xNSwuMDA1Ojc5LjQ5fSw2MDp7Ljk5NTozNS41MywuOTk6MzcuNDgsLjk3NTo0MC40OCwuOTU6NDMuMTksLjk6NDYuNDYsLjU6NTkuMzMsLjE6NzQuNCwuMDU6NzkuMDgsLjAyNTo4My4zLC4wMTo4OC4zOCwuMDA1OjkxLjk1fSw3MDp7Ljk5NTo0My4yOCwuOTk6NDUuNDQsLjk3NTo0OC43NiwuOTU6NTEuNzQsLjk6NTUuMzMsLjU6NjkuMzMsLjE6ODUuNTMsLjA1OjkwLjUzLC4wMjU6OTUuMDIsLjAxOjEwMC40MiwuMDA1OjEwNC4yMn0sODA6ey45OTU6NTEuMTcsLjk5OjUzLjU0LC45NzU6NTcuMTUsLjk1OjYwLjM5LC45OjY0LjI4LC41Ojc5LjMzLC4xOjk2LjU4LC4wNToxMDEuODgsLjAyNToxMDYuNjMsLjAxOjExMi4zMywuMDA1OjExNi4zMn0sOTA6ey45OTU6NTkuMiwuOTk6NjEuNzUsLjk3NTo2NS42NSwuOTU6NjkuMTMsLjk6NzMuMjksLjU6ODkuMzMsLjE6MTA3LjU3LC4wNToxMTMuMTQsLjAyNToxMTguMTQsLjAxOjEyNC4xMiwuMDA1OjEyOC4zfSwxMDA6ey45OTU6NjcuMzMsLjk5OjcwLjA2LC45NzU6NzQuMjIsLjk1Ojc3LjkzLC45OjgyLjM2LC41Ojk5LjMzLC4xOjExOC41LC4wNToxMjQuMzQsLjAyNToxMjkuNTYsLjAxOjEzNS44MSwuMDA1OjE0MC4xN319O2Z1bmN0aW9uIGJyKHIsdCxuKXtmb3IodmFyIG89MCxhPXQoZShyKSksaD1bXSxmPVtdLHU9MDt1PHIubGVuZ3RoO3UrKyl2b2lkIDA9PT1oW3JbdV1dJiYoaFtyW3VdXT0wKSxoW3JbdV1dKys7Zm9yKHZhciBpPTA7aTxoLmxlbmd0aDtpKyspdm9pZCAwPT09aFtpXSYmKGhbaV09MCk7Zm9yKHZhciBsIGluIGEpbCBpbiBoJiYoZlsrbF09YVtsXSpyLmxlbmd0aCk7Zm9yKHZhciBnPWYubGVuZ3RoLTE7Zz49MDtnLS0pZltnXTwzJiYoZltnLTFdKz1mW2ddLGYucG9wKCksaFtnLTFdKz1oW2ddLGgucG9wKCkpO2Zvcih2YXIgdj0wO3Y8aC5sZW5ndGg7disrKW8rPU1hdGgucG93KGhbdl0tZlt2XSwyKS9mW3ZdO3JldHVybiB5cltoLmxlbmd0aC0xLTFdW25dPG99dmFyIGRyPU1hdGguc3FydCgyKk1hdGguUEkpLElyPXtnYXVzc2lhbjpmdW5jdGlvbihyKXtyZXR1cm4gTWF0aC5leHAoLS41KnIqcikvZHJ9fSxQcj17bnJkOmZ1bmN0aW9uKHIpe3ZhciB0PU8ociksbj16KHIpO3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBuJiYodD1NYXRoLm1pbih0LG4vMS4zNCkpLDEuMDYqdCpNYXRoLnBvdyhyLmxlbmd0aCwtLjIpfX07ZnVuY3Rpb24gQ3Iocix0LG4pe3ZhciBlLG87aWYodm9pZCAwPT09dCllPUlyLmdhdXNzaWFuO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKCFJclt0XSl0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24ga2VybmVsIFwiJyt0KydcIicpO2U9SXJbdF19ZWxzZSBlPXQ7aWYodm9pZCAwPT09bilvPVByLm5yZChyKTtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXtpZighUHJbbl0pdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhbmR3aWR0aCBtZXRob2QgXCInK24rJ1wiJyk7bz1QcltuXShyKX1lbHNlIG89bjtyZXR1cm4gZnVuY3Rpb24odCl7dmFyIG49MCxhPTA7Zm9yKG49MDtuPHIubGVuZ3RoO24rKylhKz1lKCh0LXJbbl0pL28pO3JldHVybiBhL28vci5sZW5ndGh9fWZ1bmN0aW9uIE5yKHIsdCxuKXtyZXR1cm4oci10KS9ufXZhciBfcj1NYXRoLnNxcnQoMipNYXRoLlBJKTtmdW5jdGlvbiBBcihyKXtmb3IodmFyIHQ9cixuPXIsZT0xO2U8MTU7ZSsrKXQrPW4qPXIqci8oMiplKzEpO3JldHVybiBNYXRoLnJvdW5kKDFlNCooLjUrdC9fcipNYXRoLmV4cCgtcipyLzIpKSkvMWU0fWZvcih2YXIgenI9W10sVXI9MDtVcjw9My4wOTtVcis9LjAxKXpyLnB1c2goQXIoVXIpKTtmdW5jdGlvbiBLcihyKXt2YXIgdD1NYXRoLmFicyhyKSxuPU1hdGgubWluKE1hdGgucm91bmQoMTAwKnQpLHpyLmxlbmd0aC0xKTtyZXR1cm4gcj49MD96cltuXTorKDEtenJbbl0pLnRvRml4ZWQoNCl9ZnVuY3Rpb24gQnIocil7dmFyIHQ9MS8oMSsuNSpNYXRoLmFicyhyKSksbj10Kk1hdGguZXhwKC1NYXRoLnBvdyhyLDIpLTEuMjY1NTEyMjMrMS4wMDAwMjM2OCp0Ky4zNzQwOTE5NipNYXRoLnBvdyh0LDIpKy4wOTY3ODQxOCpNYXRoLnBvdyh0LDMpLS4xODYyODgwNipNYXRoLnBvdyh0LDQpKy4yNzg4NjgwNypNYXRoLnBvdyh0LDUpLTEuMTM1MjAzOTgqTWF0aC5wb3codCw2KSsxLjQ4ODUxNTg3Kk1hdGgucG93KHQsNyktLjgyMjE1MjIzKk1hdGgucG93KHQsOCkrLjE3MDg3Mjc3Kk1hdGgucG93KHQsOSkpO3JldHVybiByPj0wPzEtbjpuLTF9ZnVuY3Rpb24gR3Iocil7dmFyIHQ9OCooTWF0aC5QSS0zKS8oMypNYXRoLlBJKig0LU1hdGguUEkpKSxuPU1hdGguc3FydChNYXRoLnNxcnQoTWF0aC5wb3coMi8oTWF0aC5QSSp0KStNYXRoLmxvZygxLXIqcikvMiwyKS1NYXRoLmxvZygxLXIqcikvdCktKDIvKE1hdGguUEkqdCkrTWF0aC5sb2coMS1yKnIpLzIpKTtyZXR1cm4gcj49MD9uOi1ufWZ1bmN0aW9uIEhyKHIpe3JldHVybiAwPT09cj9yPWxyOnI+PTEmJihyPTEtbHIpLE1hdGguc3FydCgyKSpHcigyKnItMSl9ZnVuY3Rpb24gSnIocix0LG4sbyl7aWYodm9pZCAwPT09byYmKG89MWU0KSx2b2lkIDA9PT1uJiYobj1cInR3b19zaWRlXCIpLFwidHdvX3NpZGVcIiE9PW4mJlwiZ3JlYXRlclwiIT09biYmXCJsZXNzXCIhPT1uKXRocm93IG5ldyBFcnJvcihcImBhbHRlcm5hdGl2ZWAgbXVzdCBiZSBlaXRoZXIgJ3R3b19zaWRlJywgJ2dyZWF0ZXInLCBvciAnbGVzcydcIik7Zm9yKHZhciBhPWUociktZSh0KSxoPW5ldyBBcnJheShvKSxmPXIuY29uY2F0KHQpLHU9TWF0aC5mbG9vcihmLmxlbmd0aC8yKSxpPTA7aTxvO2krKyl7SChmKTt2YXIgbD1mLnNsaWNlKDAsdSksZz1mLnNsaWNlKHUsZi5sZW5ndGgpLHY9ZShsKS1lKGcpO2hbaV09dn12YXIgYz0wO2lmKFwidHdvX3NpZGVcIj09PW4pZm9yKHZhciBzPTA7czw9bztzKyspTWF0aC5hYnMoaFtzXSk+PU1hdGguYWJzKGEpJiYoYys9MSk7ZWxzZSBpZihcImdyZWF0ZXJcIj09PW4pZm9yKHZhciBwPTA7cDw9bztwKyspaFtwXT49YSYmKGMrPTEpO2Vsc2UgZm9yKHZhciBNPTA7TTw9bztNKyspaFtNXTw9YSYmKGMrPTEpO3JldHVybiBjL299ZnVuY3Rpb24gUXIocil7aWYoXCJudW1iZXJcIj09dHlwZW9mIHIpcmV0dXJuIHI8MD8tMTowPT09cj8wOjE7dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIG51bWJlclwiKX1mdW5jdGlvbiBScihyLHQsbixlLG8pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImZ1bmMgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO2Zvcih2YXIgYT0wO2E8ZTthKyspe3ZhciBoPSh0K24pLzI7aWYoMD09PXIoaCl8fE1hdGguYWJzKChuLXQpLzIpPG8pcmV0dXJuIGg7UXIocihoKSk9PT1RcihyKHQpKT90PWg6bj1ofXRocm93IG5ldyBFcnJvcihcIm1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZXhjZWVkZWRcIil9ZXhwb3J0e3IgYXMgbGluZWFyUmVncmVzc2lvbix0IGFzIGxpbmVhclJlZ3Jlc3Npb25MaW5lLGggYXMgc3RhbmRhcmREZXZpYXRpb24sZiBhcyByU3F1YXJlZCxsIGFzIG1vZGUsZyBhcyBtb2RlRmFzdCx1IGFzIG1vZGVTb3J0ZWQsdiBhcyBtaW4sYyBhcyBtYXgscyBhcyBleHRlbnQscCBhcyBtaW5Tb3J0ZWQsTSBhcyBtYXhTb3J0ZWQsdyBhcyBleHRlbnRTb3J0ZWQsbiBhcyBzdW0scSBhcyBzdW1TaW1wbGUsRSBhcyBwcm9kdWN0LEkgYXMgcXVhbnRpbGUseSBhcyBxdWFudGlsZVNvcnRlZCxBIGFzIHF1YW50aWxlUmFuayxfIGFzIHF1YW50aWxlUmFua1NvcnRlZCx6IGFzIGludGVycXVhcnRpbGVSYW5nZSx6IGFzIGlxcixLIGFzIG1lZGlhbkFic29sdXRlRGV2aWF0aW9uLEsgYXMgbWFkLEIgYXMgY2h1bmssRyBhcyBzYW1wbGVXaXRoUmVwbGFjZW1lbnQsSiBhcyBzaHVmZmxlLEggYXMgc2h1ZmZsZUluUGxhY2UsUSBhcyBzYW1wbGUseCBhcyBja21lYW5zLFIgYXMgdW5pcXVlQ291bnRTb3J0ZWQsbyBhcyBzdW1OdGhQb3dlckRldmlhdGlvbnMsVCBhcyBlcXVhbEludGVydmFsQnJlYWtzLEQgYXMgc2FtcGxlQ292YXJpYW5jZSxYIGFzIHNhbXBsZUNvcnJlbGF0aW9uLEwgYXMgc2FtcGxlVmFyaWFuY2UsTyBhcyBzYW1wbGVTdGFuZGFyZERldmlhdGlvbixWIGFzIHNhbXBsZVNrZXduZXNzLG0gYXMgc2FtcGxlS3VydG9zaXMsRiBhcyBwZXJtdXRhdGlvbnNIZWFwLGsgYXMgY29tYmluYXRpb25zLFMgYXMgY29tYmluYXRpb25zUmVwbGFjZW1lbnQsaiBhcyBhZGRUb01lYW4sJCBhcyBjb21iaW5lTWVhbnMscnIgYXMgY29tYmluZVZhcmlhbmNlcyx0ciBhcyBnZW9tZXRyaWNNZWFuLG5yIGFzIGhhcm1vbmljTWVhbixlIGFzIGF2ZXJhZ2UsZSBhcyBtZWFuLFUgYXMgbWVkaWFuLGVyIGFzIG1lZGlhblNvcnRlZCxvciBhcyBzdWJ0cmFjdEZyb21NZWFuLGFyIGFzIHJvb3RNZWFuU3F1YXJlLGFyIGFzIHJtcyxhIGFzIHZhcmlhbmNlLGhyIGFzIHRUZXN0LGZyIGFzIHRUZXN0VHdvU2FtcGxlLHVyIGFzIEJheWVzaWFuQ2xhc3NpZmllcix1ciBhcyBiYXllc2lhbixpciBhcyBQZXJjZXB0cm9uTW9kZWwsaXIgYXMgcGVyY2VwdHJvbixsciBhcyBlcHNpbG9uLGdyIGFzIGZhY3RvcmlhbCx2ciBhcyBnYW1tYSxNciBhcyBnYW1tYWxuLHdyIGFzIGJlcm5vdWxsaURpc3RyaWJ1dGlvbixxciBhcyBiaW5vbWlhbERpc3RyaWJ1dGlvbixFciBhcyBwb2lzc29uRGlzdHJpYnV0aW9uLHlyIGFzIGNoaVNxdWFyZWREaXN0cmlidXRpb25UYWJsZSxiciBhcyBjaGlTcXVhcmVkR29vZG5lc3NPZkZpdCxDciBhcyBrZXJuZWxEZW5zaXR5RXN0aW1hdGlvbixDciBhcyBrZGUsTnIgYXMgelNjb3JlLEtyIGFzIGN1bXVsYXRpdmVTdGROb3JtYWxQcm9iYWJpbGl0eSx6ciBhcyBzdGFuZGFyZE5vcm1hbFRhYmxlLEJyIGFzIGVycm9yRnVuY3Rpb24sQnIgYXMgZXJmLEdyIGFzIGludmVyc2VFcnJvckZ1bmN0aW9uLEhyIGFzIHByb2JpdCxKciBhcyBwZXJtdXRhdGlvblRlc3QsUnIgYXMgYmlzZWN0LGIgYXMgcXVpY2tzZWxlY3QsUXIgYXMgc2lnbixpIGFzIG51bWVyaWNTb3J0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpbXBsZS1zdGF0aXN0aWNzLm1qcy5tYXBcbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnO1xuaW1wb3J0IHtxdWFudGlsZX0gZnJvbSAnc2ltcGxlLXN0YXRpc3RpY3MnO1xuaW1wb3J0IHtwb2ludEV4aXN0cywgY3JlYXRlR3JhcGgsIG1zdCwgZ2V0QWxsVjJPckdyZWF0ZXJGcm9tVHJlZX0gZnJvbSBcIi4va3J1c2thbC1tc3RcIjtcblxuLyoqXG4gKiBvcHRpb25zIG1heSBjb250YWluIHVwcGVyQm91bmQsIG91dGx5aW5nQ29lZmZpY2llbnQgKDEuNSBvciAzLjApLCBhbmQgd2VpZ2h0cyAoZGlmZmVyZW50IHZhcmlhYmxlcyBtYXkgaGF2ZSBkaWZmZXJlbnQgd2VpZ2h0cylcbiAqL1xuZXhwb3J0IGNsYXNzIE91dGx5aW5nIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHVwcGVyQm91bmQgPSBvcHRpb25zLnVwcGVyQm91bmQ7XG4gICAgICAgIGxldCBvdXRseWluZ0NvZWZmaWNpZW50ID0gb3B0aW9ucy5vdXRseWluZ0NvZWZmaWNpZW50O1xuICAgICAgICBsZXQgd2VpZ2h0cyA9IG9wdGlvbnMud2VpZ2h0cztcbiAgICAgICAgLy9DbG9uZSB0aGUgdHJlZSB0byBhdm9pZCBtb2RpZnlpbmcgaXRcbiAgICAgICAgdGhpcy50cmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0cmVlKSk7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XG4gICAgICAgIHRoaXMub3V0bHlpbmdDb2VmZmljaWVudCA9IG91dGx5aW5nQ29lZmZpY2llbnQgPyBvdXRseWluZ0NvZWZmaWNpZW50IDogMS41O1xuICAgICAgICAvL0NhbGN1bGF0ZSB0aGUgdXBwZXIgYm91bmQgaWYgaXQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgICBpZiAoIXVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHVwcGVyQm91bmQgPSBmaW5kVXBwZXJCb3VuZCh0aGlzLnRyZWUsIDEuNSk7XG4gICAgICAgICAgICAvL1NhdmUgaXQgZm9yIGRpc3BsYXlpbmcgcHVycG9zZS5cbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9NYXJrIHRoZSBsb25nIGxpbmtzXG4gICAgICAgIG1hcmtMb25nTGlua3ModGhpcy50cmVlLCB1cHBlckJvdW5kKTtcbiAgICAgICAgLy9GaW5kaW5nIG5vcm1hbCBub2Rlc1xuICAgICAgICBsZXQgbm9ybWFsTm9kZXMgPSBmaW5kTm9ybWFsTm9kZXModGhpcy50cmVlKTtcbiAgICAgICAgLy9GaW5kaW5nIG91dGx5aW5nIHBvaW50c1xuICAgICAgICB0aGlzLm91dGx5aW5nUG9pbnRzID0gZmluZE91dGx5aW5nUG9pbnRzKHRoaXMudHJlZSwgbm9ybWFsTm9kZXMpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRPdXRseWluZ1BvaW50cyh0cmVlLCBub3JtYWxOb2Rlcykge1xuICAgICAgICAgICAgbGV0IG5ld05vZGVzID0gbm9ybWFsTm9kZXM7XG4gICAgICAgICAgICBsZXQgb2xkTm9kZXMgPSB0cmVlLm5vZGVzO1xuICAgICAgICAgICAgLy9HZXQgdGhlIG91dGx5aW5nIHBvaW50c1xuICAgICAgICAgICAgbGV0IG9wcyA9IFtdO1xuICAgICAgICAgICAgb2xkTm9kZXMuZm9yRWFjaChvbiA9PiB7XG4gICAgICAgICAgICAgICAgLy8uaWQgc2luY2Ugd2UgYXJlIGFjY2Vzc2luZyB0byBwb2ludHMgYW5kIHRoZSBub2RlIGlzIGluIGZvcm0gb2Yge2lkOiB0aGVQb2ludH1cbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50RXhpc3RzKG5ld05vZGVzLm1hcChubiA9PiBubi5pZCksIG9uLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHMucHVzaChvbi5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9Ob3cgbWFyayB0aGUgb3V0bHlpbmcgbGlua3NcbiAgICAgICAgbWFya091dGx5aW5nTGlua3ModGhpcy50cmVlLCB0aGlzLm91dGx5aW5nUG9pbnRzKTtcblxuICAgICAgICAvL0NyZWF0ZSBub25lIG91dGx5aW5nIHRyZWVcbiAgICAgICAgdGhpcy5ub091dGx5aW5nVHJlZSA9IGJ1aWxkTm9PdXRseWluZ1RyZWUodGhpcy50cmVlLCB0aGlzLm91dGx5aW5nUG9pbnRzKTtcblxuICAgICAgICBmdW5jdGlvbiBidWlsZE5vT3V0bHlpbmdUcmVlKHRyZWUsIG91dGx5aW5nUG9pbnRzKSB7XG4gICAgICAgICAgICBsZXQgbm9PdXRseWluZ1RyZWUgPSB7fTtcbiAgICAgICAgICAgIG5vT3V0bHlpbmdUcmVlLm5vZGVzID0gbm9ybWFsTm9kZXM7XG4gICAgICAgICAgICBub091dGx5aW5nVHJlZS5saW5rcyA9IHRyZWUubGlua3MuZmlsdGVyKGwgPT4gbC5pc091dGx5aW5nICE9PSB0cnVlKVxuICAgICAgICAgICAgLy9JZiB0aGUgb3V0bHlpbmcgbm9kZXMgaGFzIHRoZSBkZWdyZWUgb2YgMiBvciBncmVhdGVyID0+IGl0IHdpbGwgYnJlYWsgdGhlIHRyZWUgaW50byBzdWJ0cmVlcyA9PiBzbyB3ZSBuZWVkIHRvIHJlYnVpbGQgdGhlIHRyZWUuXG4gICAgICAgICAgICAvL1Rha2UgdGhlIG91dGx5aW5nIHBvaW50c1xuICAgICAgICAgICAgbGV0IG91dGx5aW5nUG9pbnRzU3RyID0gb3V0bHlpbmdQb2ludHMubWFwKHAgPT4gcC5qb2luKCcsJykpO1xuICAgICAgICAgICAgbGV0IHYyT3JHcmVhdGVyU3RyID0gZ2V0QWxsVjJPckdyZWF0ZXJGcm9tVHJlZSh0cmVlKS5tYXAocCA9PiBwLmpvaW4oJywnKSk7XG5cbiAgICAgICAgICAgIGxldCBkaWZmID0gXy5kaWZmZXJlbmNlKG91dGx5aW5nUG9pbnRzU3RyLCB2Mk9yR3JlYXRlclN0cik7XG4gICAgICAgICAgICBpZiAoZGlmZi5sZW5ndGggPCBvdXRseWluZ1BvaW50c1N0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvL01lYW5zIHRoZXJlIGlzIG91dGx5aW5nIG5vZGUocykgd2l0aCBkZWdyZWUgMiBvciBoaWdoZXIgKHNvIHdlIHNob3VsZCByZWJ1aWxkIHRoZSB0cmVlKVxuICAgICAgICAgICAgICAgIGxldCBncmFwaCA9IGNyZWF0ZUdyYXBoKG5vT3V0bHlpbmdUcmVlLm5vZGVzLm1hcChuID0+IG4uaWQpLCB3ZWlnaHRzKVxuICAgICAgICAgICAgICAgIG5vT3V0bHlpbmdUcmVlID0gbXN0KGdyYXBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub091dGx5aW5nVHJlZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmROb3JtYWxOb2Rlcyh0cmVlKSB7XG4gICAgICAgICAgICAvL1JlbW92ZSBsb25nIGxpbmtzXG4gICAgICAgICAgICBsZXQgbm9ybWFsTGlua3MgPSB0cmVlLmxpbmtzLmZpbHRlcihsID0+ICFsLmlzTG9uZyk7XG4gICAgICAgICAgICAvL1JlbW92ZSBvdXRseWluZyBub2RlcyAobm9kZXMgYXJlIG5vdCBpbiBhbnkgbm9uZS1sb25nIGxpbmtzKVxuICAgICAgICAgICAgbGV0IGFsbE5vZGVzV2l0aExpbmtzID0gW107XG4gICAgICAgICAgICBub3JtYWxMaW5rcy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzV2l0aExpbmtzLnB1c2gobC5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGFsbE5vZGVzV2l0aExpbmtzLnB1c2gobC50YXJnZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbGxOb2Rlc1dpdGhMaW5rcyA9IF8udW5pcShhbGxOb2Rlc1dpdGhMaW5rcywgZmFsc2UsIGQgPT4gZC5qb2luKCcsJykpO1xuICAgICAgICAgICAgbGV0IG5vcm1hbE5vZGVzID0gYWxsTm9kZXNXaXRoTGlua3MubWFwKG4gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7aWQ6IG59O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsTm9kZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYXJrTG9uZ0xpbmtzKHRyZWUsIHVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHRyZWUubGlua3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobC53ZWlnaHQgPiB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGwuaXNMb25nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmRVcHBlckJvdW5kKHRyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgICAgICBsZXQgYWxsTGVuZ3RocyA9IHRyZWUubGlua3MubWFwKGwgPT4gbC53ZWlnaHQpLFxuICAgICAgICAgICAgICAgIHExID0gcXVhbnRpbGUoYWxsTGVuZ3RocywgMC4yNSksXG4gICAgICAgICAgICAgICAgcTMgPSBxdWFudGlsZShhbGxMZW5ndGhzLCAwLjc1KSxcbiAgICAgICAgICAgICAgICBpcXIgPSBxMyAtIHExLFxuICAgICAgICAgICAgICAgIHVwcGVyQm91bmQgPSBxMyArIGNvZWZmaWNpZW50ICogaXFyO1xuICAgICAgICAgICAgcmV0dXJuIHVwcGVyQm91bmQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtYXJrT3V0bHlpbmdMaW5rcyh0cmVlLCBvdXRseWluZ1BvaW50cykge1xuICAgICAgICAgICAgaWYgKG91dGx5aW5nUG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvL0NoZWNrIHRoZSBsb25nIGxpbmtzIG9ubHlcbiAgICAgICAgICAgICAgICB0cmVlLmxpbmtzLmZpbHRlcihsID0+IGwuaXNMb25nKS5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvL0Fsc28gY2hlY2sgaWYgdGhlIGxpbmsgY29udGFpbnMgb3V0bHlpbmcgcG9pbnRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRFeGlzdHMob3V0bHlpbmdQb2ludHMsIGwuc291cmNlKSB8fCBwb2ludEV4aXN0cyhvdXRseWluZ1BvaW50cywgbC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsLmlzT3V0bHlpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG91dGx5aW5nIHNjb3JlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzY29yZSgpIHtcbiAgICAgICAgbGV0IHRvdGFsTGVuZ3RocyA9IDA7XG4gICAgICAgIGxldCB0b3RhbE91dGx5aW5nTGVuZ3RocyA9IDA7XG4gICAgICAgIHRoaXMudHJlZS5saW5rcy5mb3JFYWNoKGwgPT4ge1xuICAgICAgICAgICAgdG90YWxMZW5ndGhzICs9IGwud2VpZ2h0O1xuICAgICAgICAgICAgLy9JZiB0aGVyZSBhcmUgb3V0bHlpbmcgcG9pbnRzIGZpcnN0LlxuICAgICAgICAgICAgaWYgKGwuaXNPdXRseWluZykge1xuICAgICAgICAgICAgICAgIHRvdGFsT3V0bHlpbmdMZW5ndGhzICs9IGwud2VpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsT3V0bHlpbmdMZW5ndGhzIC8gdG90YWxMZW5ndGhzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb3V0bHlpbmcgbGlua3NcbiAgICAgKi9cbiAgICBsaW5rcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm91dGx5aW5nTGlua3MpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bHlpbmdMaW5rcyA9IHRoaXMudHJlZS5saW5rcy5maWx0ZXIobCA9PiBsLmlzT3V0bHlpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm91dGx5aW5nTGlua3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG91dGx5aW5nIGxpbmtzIGFuZCBub2RlcyBhbmQgcmV0dXJuIGEgbmV3IHRyZWUgd2l0aG91dCBvdXRseWluZyBwb2ludHMvZWRnZXNcbiAgICAgKi9cbiAgICByZW1vdmVPdXRseWluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9PdXRseWluZ1RyZWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3V0bHlpbmcgcG9pbnRzIChpbiBmb3JtIG9mIHBvaW50cywgbm90IG5vZGUgb2JqZWN0KS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgcG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRseWluZ1BvaW50cztcbiAgICB9XG59IiwiaW1wb3J0IHtxdWFudGlsZX0gZnJvbSAnc2ltcGxlLXN0YXRpc3RpY3MnO1xuXG5leHBvcnQgY2xhc3MgU2tld2VkIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlKSB7XG4gICAgICAgIC8vQ2xvbmUgdGhlIHRyZWUgdG8gYXZvaWQgbW9kaWZ5aW5nIGl0XG4gICAgICAgIHRoaXMudHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2tld2VkIHNjb3JlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzY29yZSgpIHtcbiAgICAgICAgbGV0IGFsbExlbmd0aHMgPSB0aGlzLnRyZWUubGlua3MubWFwKGw9Pmwud2VpZ2h0KSxcbiAgICAgICAgcTkwID0gcXVhbnRpbGUoYWxsTGVuZ3RocywgLjkpLFxuICAgICAgICBxNTAgPSBxdWFudGlsZShhbGxMZW5ndGhzLCAuNSksXG4gICAgICAgIHExMCA9IHF1YW50aWxlKGFsbExlbmd0aHMsIC4xKTtcbiAgICAgICAgaWYocTkwIT1xMTApe1xuICAgICAgICAgICAgcmV0dXJuIChxOTAtcTUwKS8ocTkwLXExMCk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQge3F1YW50aWxlfSBmcm9tICdzaW1wbGUtc3RhdGlzdGljcyc7XG5cbmV4cG9ydCBjbGFzcyBTcGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyZWUpIHtcbiAgICAgICAgLy9DbG9uZSB0aGUgdHJlZSB0byBhdm9pZCBtb2RpZnlpbmcgaXRcbiAgICAgICAgdGhpcy50cmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0cmVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzcGFyc2Ugc2NvcmVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjb3JlKCkge1xuICAgICAgICBsZXQgYWxsTGVuZ3RocyA9IHRoaXMudHJlZS5saW5rcy5tYXAobD0+bC53ZWlnaHQpLFxuICAgICAgICAgICAgcTkwID0gcXVhbnRpbGUoYWxsTGVuZ3RocywgLjkpO1xuICAgICAgICByZXR1cm4gcTkwO1xuICAgIH1cbn1cbiIsImltcG9ydCB7bWF4fSBmcm9tICdzaW1wbGUtc3RhdGlzdGljcyc7XG5pbXBvcnQge3BhaXJOb2RlTGlua3MsIGVxdWFsTGlua3MsIHBvaW50RXhpc3RzfSBmcm9tIFwiLi9rcnVza2FsLW1zdFwiO1xuaW1wb3J0IF8gZnJvbSAndW5kZXJzY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBDbHVtcHkge1xuICAgIGNvbnN0cnVjdG9yKHRyZWUpIHtcbiAgICAgICAgLy9DbG9uZSB0aGUgdHJlZSB0byBhdm9pZCBtb2RpZnlpbmcgaXRcbiAgICAgICAgdGhpcy50cmVlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0cmVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjbHVtcHkgc2NvcmVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjb3JlKCkge1xuICAgICAgICBsZXQgYWxsUnVudFJhdGlvcyA9IFtdO1xuICAgICAgICB0aGlzLnRyZWUubGlua3MuZm9yRWFjaChsaW5rID0+e1xuICAgICAgICAgICAgbGV0IHJnID0gdGhpcy5ydW50R3JhcGgobGluayk7XG4gICAgICAgICAgICBpZihyZy5sZW5ndGg+MCl7XG4gICAgICAgICAgICAgICAgYWxsUnVudFJhdGlvcy5wdXNoKHRoaXMubWF4TGVuZ3RoKHJnKS9saW5rLndlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZihhbGxSdW50UmF0aW9zLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIC8vT25seSBpZiB0aGVyZSBhcmUgc29tZSBydW50IGdyYXBoc1xuICAgICAgICAgICAgcmV0dXJuIG1heChhbGxSdW50UmF0aW9zLm1hcChycj0+MS1ycikpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vSW4gY2FzZSBhbGwgbGVuZ3RocyBhcmUgZXF1YWwgPT4gdGhlbiB0aGUgc2NvcmUgaXMgMFxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBydW50R3JhcGgobGluayl7XG4gICAgICAgIC8vTGlua3MgdGhhdCBhcmUgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgY3VycmVudGx5IGNoZWNraW5nIGxpbmtcbiAgICAgICAgbGV0IGdyZWF0ZXJPckVxdWFsTGlua3MgPSB0aGlzLnRyZWUubGlua3MuZmlsdGVyKGw9Pmwud2VpZ2h0IDwgbGluay53ZWlnaHQpO1xuICAgICAgICAvL1JlbW92ZSB0aGUgY3VycmVudGx5IGNoZWNraW5nIGxpbmsuXG4gICAgICAgIGdyZWF0ZXJPckVxdWFsTGlua3MgPSBncmVhdGVyT3JFcXVhbExpbmtzLmZpbHRlcihsPT4hZXF1YWxMaW5rcyhsLCBsaW5rKSk7XG4gICAgICAgIGxldCBwYWlyZWRSZXN1bHRzID0gcGFpck5vZGVMaW5rcyhncmVhdGVyT3JFcXVhbExpbmtzKTtcblxuICAgICAgICAvL1Byb2Nlc3MgdGhlIHNvdXJjZSBzaWRlLlxuICAgICAgICBsZXQgc291cmNlQ29ubmVjdGVkTm9kZXMgPSBbbGluay5zb3VyY2VdO1xuICAgICAgICBsZXQgc291cmNlQ29ubmVjdGVkTGlua3MgPSB0aGlzLmdldENvbm5lY3RlZExpbmtzKHNvdXJjZUNvbm5lY3RlZE5vZGVzLCBwYWlyZWRSZXN1bHRzKTtcblxuICAgICAgICBsZXQgdGFyZ2V0Q29ubmVjdGVkTm9kZXMgPSBbbGluay50YXJnZXRdO1xuICAgICAgICBsZXQgdGFyZ2V0Q29ubmVjdGVkTGlua3MgPSB0aGlzLmdldENvbm5lY3RlZExpbmtzKHRhcmdldENvbm5lY3RlZE5vZGVzLCBwYWlyZWRSZXN1bHRzKTtcblxuICAgICAgICByZXR1cm4gc291cmNlQ29ubmVjdGVkTGlua3MubGVuZ3RoIDwgdGFyZ2V0Q29ubmVjdGVkTGlua3MubGVuZ3RoP3NvdXJjZUNvbm5lY3RlZExpbmtzOnRhcmdldENvbm5lY3RlZExpbmtzO1xuICAgIH1cblxuXG4gICAgZ2V0Q29ubmVjdGVkTGlua3MoY29ubmVjdGVkTm9kZXMsIHBhaXJlZFJlc3VsdHMpIHtcbiAgICAgICAgbGV0IHByb2Nlc3NlZE5vZGVzID0gW107XG4gICAgICAgIGxldCBjb25uZWN0ZWRMaW5rcyA9IFtdO1xuICAgICAgICB3aGlsZSAoY29ubmVjdGVkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy9DYW4gc3RvcCBlYXJsaWVyIGlmIHRoaXMgaXMgaGF2aW5nIG1vcmUgdGhhbiBoYWxmIG9mIHRoZSBsaW5rcyBpbiB0aGUgd2hvbGUgdHJlZS5cbiAgICAgICAgICAgIGlmKGNvbm5lY3RlZExpbmtzLmxlbmd0aCA+IHRoaXMudHJlZS5saW5rcy5sZW5ndGggKyAxKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaXJzdE5vZGUgPSBfLmZpcnN0KGNvbm5lY3RlZE5vZGVzKTtcbiAgICAgICAgICAgIC8vUmVtb3ZlZCB0aGUgcHJvY2Vzc2VkIG5vZGVzXG4gICAgICAgICAgICBjb25uZWN0ZWROb2RlcyA9IF8ud2l0aG91dChjb25uZWN0ZWROb2RlcywgZmlyc3ROb2RlKTtcbiAgICAgICAgICAgIC8vQWRkIGl0IHRvIHRoZSBwcm9jZXNzZWQgbm9kZVxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXMucHVzaChmaXJzdE5vZGUpO1xuICAgICAgICAgICAgLy9GaW5kIHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhhdCBub2RlLlxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhaXJlZFJlc3VsdHMuZmluZChwID0+IHBbMF0gPT09IGZpcnN0Tm9kZS5qb2luKFwiLFwiKSk7XG4gICAgICAgICAgICBsZXQgbGlua3MgPSByZXN1bHQ/cmVzdWx0WzFdOltdO1xuICAgICAgICAgICAgY29ubmVjdGVkTGlua3MgPSBjb25uZWN0ZWRMaW5rcy5jb25jYXQobGlua3MpO1xuICAgICAgICAgICAgLy9BZGQgbmV3IG5vZGVzIHRvIGJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgbGlua3MuZm9yRWFjaChsID0+IHtcbiAgICAgICAgICAgICAgICAvL0lmIHRoZSBub2RlIGluIHRoZSBjb25uZWN0ZWQgbGluayBpcyBub3QgcHJvY2Vzc2VkID0+IHRoZW4gYWRkIGl0IHRvIGJlIHByb2Nlc3NlZCAodG8gZXhwYW5kIGxhdGVyIG9uKS5cbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50RXhpc3RzKHByb2Nlc3NlZE5vZGVzLCBsLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaChsLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKCFwb2ludEV4aXN0cyhwcm9jZXNzZWROb2RlcywgbC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2gobC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0ZWRMaW5rcztcbiAgICB9XG5cbiAgICBtYXhMZW5ndGgocnVudEdyYXBoKXtcbiAgICAgICAgaWYocnVudEdyYXBoLmxlbmd0aD09PTApe1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heChydW50R3JhcGgubWFwKGw9Pmwud2VpZ2h0KSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHtnZXRBbGxWMkNvcm5lcnNGcm9tVHJlZSwgZ2V0QWxsVjFzRnJvbVRyZWV9IGZyb20gXCIuL2tydXNrYWwtbXN0XCI7XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmd5IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmVlKSB7XG4gICAgICAgIC8vQ2xvbmUgdGhlIHRyZWUgdG8gYXZvaWQgbW9kaWZ5aW5nIGl0XG4gICAgICAgIHRoaXMudHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc3RyaWF0ZWQgc2NvcmVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjb3JlKCkge1xuICAgICAgICAvL0xvb3AgdGhyb3VnaCB0aGUgbm9kZXMuXG4gICAgICAgIGxldCB2ZXJ0aWNlc0NvdW50ID0gdGhpcy50cmVlLm5vZGVzLmxlbmd0aDtcbiAgICAgICAgbGV0IHYyQ291bnQgPSB0aGlzLmdldEFsbFYyQ29ybmVycygpLmxlbmd0aDtcbiAgICAgICAgbGV0IHYxQ291bnQgPSB0aGlzLmdldEFsbFYxcygpLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHYyQ291bnQvKHZlcnRpY2VzQ291bnQtdjFDb3VudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGNvcm5lcnMgKHRocmVlIHZlcnRpY2VzKSBvZiB2ZXJ0aWNlcyBvZiBkZWdyZWUgdHdvIGluIHRoZSBmb3IgbWF0IG9mXG4gICAgICogcG9pbnQxLCBwb2ludDIsIHBvaW50MyA9PiBwb2ludDEgaXMgdGhlIHRoZSB2ZXJ0ZXggd2l0aCBkZWdyZWUgdHdvICh0d28gZWRnZXMgY29ubmVjdGVkIHRvIGl0IGFyZSBbcG9pbnQxLCBwb2ludDJdIGFuZCBbcG9pbnQxLCBwb2ludDNdIChvcmRlciBvZiB0aGUgcG9pbnRzIGluIGVhY2ggZWRnZSBpcyBub3QgaW1wb3J0YW50KSkuXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGdldEFsbFYyQ29ybmVycygpe1xuICAgICAgICByZXR1cm4gZ2V0QWxsVjJDb3JuZXJzRnJvbVRyZWUodGhpcy50cmVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0QWxsVjFzKCl7XG4gICAgICAgIHJldHVybiBnZXRBbGxWMXNGcm9tVHJlZSh0aGlzLnRyZWUpO1xuICAgIH1cbn1cbiIsImltcG9ydCBfIGZyb20gJ3VuZGVyc2NvcmUnXG5cbmV4cG9ydCBjbGFzcyBNb25vdG9uaWMge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50cykge1xuICAgICAgICAvL0Nsb25lIGl0IGluIG9yZGVyIHRvIGF2b2lkIG1vZGlmeWluZyBpdC5cbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHMuc2xpY2UoMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBtb25vdG9uaWMgc2NvcmVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNjb3JlKCkge1xuICAgICAgICBsZXQgc3BlYXJtYW5zID0gW107XG4gICAgICAgIGxldCB2YXJpYWJsZXMgPSBfLnVuemlwKHRoaXMucG9pbnRzKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHZhcmlhYmxlcy5sZW5ndGg7XG5cbiAgICAgICAgLy9DYWxjdWxhdGUgdGhlIHNwZWFybWFuIGZvciBhbGwgcGFpcnMgb2YgdmFyaWFibGVzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgbGV0IHYxID0gdmFyaWFibGVzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkrMTsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHYyID0gdmFyaWFibGVzW2pdO1xuICAgICAgICAgICAgICAgIGxldCByID0gY29tcHV0ZVNwZWFybWFucyh2MSwgdjIpO1xuICAgICAgICAgICAgICAgIHNwZWFybWFucy5wdXNoKHIqcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8ubWF4KHNwZWFybWFucyk7XG5cbiAgICAgICAgLyoqQWRvcHRlZCBmcm9tOiBodHRwczovL2JsLm9ja3Mub3JnL25rdWxsbWFuL2Y2NWQ1NjE5ODQzZGMyMmUwNjFkOTU3MjQ5MTIxNDA4KiovXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVTcGVhcm1hbnMoYXJyWCwgYXJyWSkge1xuICAgICAgICAgICAgLy8gc2ltcGxlIGVycm9yIGhhbmRsaW5nIGZvciBpbnB1dCBhcnJheXMgb2Ygbm9uZXF1YWwgbGVuZ3Roc1xuICAgICAgICAgICAgaWYgKGFyclgubGVuZ3RoICE9PSBhcnJZLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBudW1iZXIgb2Ygb2JzZXJ2YXRpb25zXG4gICAgICAgICAgICBsZXQgbiA9IGFyclgubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyByYW5rIGRhdGFzZXRzXG4gICAgICAgICAgICBsZXQgeFJhbmtlZCA9IHJhbmtBcnJheShhcnJYKSxcbiAgICAgICAgICAgICAgICB5UmFua2VkID0gcmFua0FycmF5KGFyclkpO1xuXG4gICAgICAgICAgICAvLyBzdW0gb2YgZGlzdGFuY2VzIGJldHdlZW4gcmFua3NcbiAgICAgICAgICAgIGxldCBkc3EgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkc3EgKz0gTWF0aC5wb3coeFJhbmtlZFtpXSAtIHlSYW5rZWRbaV0sIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb21wdXRlIGNvcnJlY3Rpb24gZm9yIHRpZXNcbiAgICAgICAgICAgIGxldCB4VGllcyA9IGNvdW50VGllcyhhcnJYKSxcbiAgICAgICAgICAgICAgICB5VGllcyA9IGNvdW50VGllcyhhcnJZKTtcbiAgICAgICAgICAgIGxldCB4Q29ycmVjdGlvbiA9IDAsXG4gICAgICAgICAgICAgICAgeUNvcnJlY3Rpb24gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgdGllTGVuZ3RoIGluIHhUaWVzKSB7XG4gICAgICAgICAgICAgICAgeENvcnJlY3Rpb24gKz0geFRpZXNbdGllTGVuZ3RoXSAqIHRpZUxlbmd0aCAqIChNYXRoLnBvdyh0aWVMZW5ndGgsIDIpIC0gMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhDb3JyZWN0aW9uIC89IDEyLjA7XG4gICAgICAgICAgICBmb3IgKGxldCB0aWVMZW5ndGggaW4geVRpZXMpIHtcbiAgICAgICAgICAgICAgICB5Q29ycmVjdGlvbiArPSB5VGllc1t0aWVMZW5ndGhdICogdGllTGVuZ3RoICogKE1hdGgucG93KHRpZUxlbmd0aCwgMikgLSAxKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeUNvcnJlY3Rpb24gLz0gMTIuMDtcblxuICAgICAgICAgICAgLy8gZGVub21pbmF0b3JcbiAgICAgICAgICAgIGxldCBkZW5vbWluYXRvciA9IG4gKiAoTWF0aC5wb3cobiwgMikgLSAxKSAvIDYuMDtcblxuICAgICAgICAgICAgLy8gY29tcHV0ZSByaG9cbiAgICAgICAgICAgIGxldCByaG8gPSBkZW5vbWluYXRvciAtIGRzcSAtIHhDb3JyZWN0aW9uIC0geUNvcnJlY3Rpb247XG4gICAgICAgICAgICByaG8gLz0gTWF0aC5zcXJ0KChkZW5vbWluYXRvciAtIDIgKiB4Q29ycmVjdGlvbikgKiAoZGVub21pbmF0b3IgLSAyICogeUNvcnJlY3Rpb24pKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJobztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBDb21wdXRlcyB0aGUgcmFuayBhcnJheSBmb3IgYXJyLCB3aGVyZSBlYWNoIGVudHJ5IGluIGFyciBpc1xuICAgICAgICAgKiBhc3NpZ25lZCBhIHZhbHVlIDEgdGhydSBuLCB3aGVyZSBuIGlzIGFyci5sZW5ndGguXG4gICAgICAgICAqXG4gICAgICAgICAqIFRpZWQgZW50cmllcyBpbiBhcnIgYXJlIGVhY2ggZ2l2ZW4gdGhlIGF2ZXJhZ2UgcmFuayBvZiB0aGUgdGllcy5cbiAgICAgICAgICogTG93ZXIgcmFua3MgYXJlIG5vdCBpbmNyZWFzZWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJhbmtBcnJheShhcnIpIHtcblxuICAgICAgICAgICAgLy8gcmFua2luZyB3aXRob3V0IGF2ZXJhZ2luZ1xuICAgICAgICAgICAgbGV0IHNvcnRlZCA9IGFyci5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYiAtIGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJhbmtzID0gYXJyLnNsaWNlKCkubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5pbmRleE9mKHYpICsgMVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNvdW50cyBvZiBlYWNoIHJhbmtcbiAgICAgICAgICAgIGxldCBjb3VudHMgPSB7fTtcbiAgICAgICAgICAgIHJhbmtzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICBjb3VudHNbeF0gPSAoY291bnRzW3hdIHx8IDApICsgMTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBhdmVyYWdlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIHJhbmtzID0gcmFua3MubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHggKyAwLjUgKiAoKGNvdW50c1t4XSB8fCAwKSAtIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiByYW5rcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBDb3VudHMgdGhlIG51bWJlciBvZiB0aWVzIGluIGFyciwgYW5kIHJldHVybnNcbiAgICAgICAgICogYW4gb2JqZWN0IHdpdGhcbiAgICAgICAgICogYSBrZXkgZm9yIGVhY2ggdGllIGxlbmd0aCAoYW4gZW50cnkgbiBmb3IgZWFjaCBuLXdheSB0aWUpIGFuZFxuICAgICAgICAgKiBhIHZhbHVlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG51bWJlciBvZiBrZXktd2F5IChuLXdheSkgdGllc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY291bnRUaWVzKGFycikge1xuICAgICAgICAgICAgbGV0IHRpZXMgPSB7fSxcbiAgICAgICAgICAgICAgICBhcnJTb3J0ZWQgPSBhcnIuc2xpY2UoKS5zb3J0KCksXG4gICAgICAgICAgICAgICAgY3VyclZhbHVlID0gYXJyU29ydGVkWzBdLFxuICAgICAgICAgICAgICAgIHRpZUxlbmd0aCA9IDE7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYXJyU29ydGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyclNvcnRlZFtpXSA9PT0gY3VyclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZUxlbmd0aCsrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWVMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGllc1t0aWVMZW5ndGhdID09PSB1bmRlZmluZWQpIHRpZXNbdGllTGVuZ3RoXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVzW3RpZUxlbmd0aF0rKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyVmFsdWUgPSBhcnJTb3J0ZWRbaV07XG4gICAgICAgICAgICAgICAgICAgIHRpZUxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpZUxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGllc1t0aWVMZW5ndGhdID09PSB1bmRlZmluZWQpIHRpZXNbdGllTGVuZ3RoXSA9IDA7XG4gICAgICAgICAgICAgICAgdGllc1t0aWVMZW5ndGhdKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGllcztcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7Tm9ybWFsaXplcn0gZnJvbSBcIi4vbW9kdWxlcy9ub3JtYWxpemVyXCI7XG5pbXBvcnQge0xlYWRlckJpbm5lcn0gZnJvbSBcIi4vbW9kdWxlcy9sZWFkZXJCaW5uZXJcIjtcbmltcG9ydCB7X30gZnJvbSAndW5kZXJzY29yZSdcbmltcG9ydCB7Y3JlYXRlR3JhcGgsIG1zdCwgZXF1YWxQb2ludHN9IGZyb20gXCIuL21vZHVsZXMva3J1c2thbC1tc3RcIjtcbmltcG9ydCB7T3V0bHlpbmd9IGZyb20gXCIuL21vZHVsZXMvb3V0bHlpbmdcIjtcbmltcG9ydCB7U2tld2VkfSBmcm9tIFwiLi9tb2R1bGVzL3NrZXdlZFwiO1xuaW1wb3J0IHtTcGFyc2V9IGZyb20gXCIuL21vZHVsZXMvc3BhcnNlXCI7XG5pbXBvcnQge0NsdW1weX0gZnJvbSBcIi4vbW9kdWxlcy9jbHVtcHlcIjtcbi8vIGltcG9ydCB7U3RyaWF0ZWR9IGZyb20gXCIuL21vZHVsZXMvc3RyaWF0ZWRcIjtcbi8vIGltcG9ydCB7Q29udmV4fSBmcm9tIFwiLi9tb2R1bGVzL2NvbnZleFwiO1xuLy8gaW1wb3J0IHtTa2lubnl9IGZyb20gXCIuL21vZHVsZXMvc2tpbm55XCI7XG5pbXBvcnQge1N0cmluZ3l9IGZyb20gXCIuL21vZHVsZXMvc3RyaW5neVwiO1xuaW1wb3J0IHtNb25vdG9uaWN9IGZyb20gXCIuL21vZHVsZXMvbW9ub3RvbmljXCI7XG5cbihmdW5jdGlvbiAod2luZG93KSB7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZSBhIHNjYWdub3N0aWNzbmQgb2JqZWN0XG4gICAgICogQHBhcmFtIGlucHV0UG9pbnRzICAgeypbXVtdfSBzZXQgb2YgcG9pbnRzIGZyb20gdGhlIHNjYXR0ZXIgcGxvdFxuICAgICAqIEByZXR1cm5zIHsqW11bXX1cbiAgICAgKi9cbiAgICB3aW5kb3cuc2NhZ25vc3RpY3NuZCA9IGZ1bmN0aW9uIChpbnB1dFBvaW50cywgb3B0aW9ucz17fSkge1xuICAgICAgICBsZXQgZGltcyA9IGlucHV0UG9pbnRzWzBdLmxlbmd0aDtcbiAgICAgICAgLy9DbG9uZSBpdCB0byBhdm9pZCBtb2RpZnlpbmcgaXQuXG4gICAgICAgIGxldCBwb2ludHMgPSBpbnB1dFBvaW50cy5tYXAoZT0+ZS5zbGljZSgpKTtcbiAgICAgICAgLy9BZGQgb25lIHN0ZXAgdG8gcGFzcyB0aGUgZGF0YSBvdmVyIGlmIHRoZXJlIGlzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9pbnRzW2ldLmRhdGEgPSBpbnB1dFBvaW50c1tpXS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub3JtYWxpemVkUG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICAgIGlmKG9wdGlvbnMuaXNOb3JtYWxpemVkID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZXIgPSBuZXcgTm9ybWFsaXplcihwb2ludHMpO1xuICAgICAgICAgICAgbm9ybWFsaXplZFBvaW50cyA9IG5vcm1hbGl6ZXIubm9ybWFsaXplZFBvaW50cztcbiAgICAgICAgICAgIG91dHB1dFZhbHVlKFwibm9ybWFsaXplZFBvaW50c1wiLCBub3JtYWxpemVkUG9pbnRzKTtcbiAgICAgICAgICAgIG91dHB1dFZhbHVlKFwibm9ybWFsaXplclwiLCBub3JtYWxpemVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBiaW5UeXBlID0gb3B0aW9ucy5iaW5UeXBlO1xuICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IHRoZSBvdXRseWluZyBzY29yZSBhbmQgb3V0bHlpbmcgc2NvcmUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgbGV0IG91dGx5aW5nVXBwZXJCb3VuZCA9IG9wdGlvbnMub3V0bHlpbmdVcHBlckJvdW5kO1xuICAgICAgICBsZXQgb3V0bHlpbmdDb2VmZmljaWVudCA9IG9wdGlvbnMub3V0bHlpbmdDb2VmZmljaWVudDtcblxuICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IGZpbmRpbmcgbnVtYmVyIG9mIGJpbnMgYW5kIGJpbm5lcnMqKioqKiovXG4gICAgICAgIGxldCBzaXRlcyA9IG51bGw7XG4gICAgICAgIGxldCBiaW5zID0gbnVsbDtcbiAgICAgICAgbGV0IGJpbm5lciA9IG51bGw7XG4gICAgICAgIGxldCBiaW5TaXplID0gbnVsbDtcbiAgICAgICAgbGV0IGJpblJhZGl1cyA9IDA7XG4gICAgICAgIGxldCBzdGFydEJpbkdyaWRTaXplID0gb3B0aW9ucy5zdGFydEJpbkdyaWRTaXplO1xuXG4gICAgICAgIGlmKG9wdGlvbnMuaXNCaW5uZWQ9PT11bmRlZmluZWQpey8vT25seSBkbyB0aGUgYmlubmluZyBpZiBuZWVkZWQuXG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50QSA9IG9wdGlvbnMuaW5jcmVtZW50QT9vcHRpb25zLmluY3JlbWVudEE6IDI7XG4gICAgICAgICAgICBsZXQgaW5jcmVtZW50QiA9IG9wdGlvbnMuaW5jcmVtZW50Qj9vcHRpb25zLmluY3JlbWVudEI6IDA7XG4gICAgICAgICAgICBsZXQgZGVjcmVtZW50QSA9IG9wdGlvbnMuZGVjcmVtZW50QT9vcHRpb25zLmRlY3JlbWVudEE6IDEvMjtcbiAgICAgICAgICAgIGxldCBkZWNyZW1lbnRCID0gb3B0aW9ucy5kZWNyZW1lbnRCP29wdGlvbnMuZGVjcmVtZW50QjogMDtcblxuICAgICAgICAgICAgaWYoc3RhcnRCaW5HcmlkU2l6ZT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgc3RhcnRCaW5HcmlkU2l6ZSA9IDIwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmlucyA9IFtdO1xuICAgICAgICAgICAgLy9EZWZhdWx0IG51bWJlciBvZiBiaW5zXG4gICAgICAgICAgICBsZXQgbWluTnVtT2ZCaW5zID0gMzA7XG4gICAgICAgICAgICBsZXQgbWF4TnVtT2ZCaW5zID0gMjAwO1xuICAgICAgICAgICAgbGV0IG1pbkJpbnMgPSBvcHRpb25zLm1pbkJpbnM7XG4gICAgICAgICAgICBsZXQgbWF4QmlucyA9IG9wdGlvbnMubWF4QmlucztcbiAgICAgICAgICAgIGlmKG1pbkJpbnMpe1xuICAgICAgICAgICAgICAgIG1pbk51bU9mQmlucyA9bWluQmlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKG1heEJpbnMpe1xuICAgICAgICAgICAgICAgIG1heE51bU9mQmlucyA9IG1heEJpbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0Rvbid0IGRvIHRoZSBiaW5uaW5nIGlmIHRoZSB1bmlxdWUgc2V0IG9mIHZhbHVlcyBhcmUgbGVzcyB0aGFuIG1pbiBudW1iZXIuIEp1c3QgcmV0dXJuIHRoZSB1bmlxdWUgc2V0LlxuICAgICAgICAgICAgbGV0IHVuaXF1ZUtleXMgPSBfLnVuaXEobm9ybWFsaXplZFBvaW50cy5tYXAocD0+cC5qb2luKCcsJykpKTtcbiAgICAgICAgICAgIGxldCBncm91cHMgPSBfLmdyb3VwQnkobm9ybWFsaXplZFBvaW50cywgcD0+cC5qb2luKCcsJykpO1xuICAgICAgICAgICAgaWYodW5pcXVlS2V5cy5sZW5ndGg8bWluTnVtT2ZCaW5zKXtcbiAgICAgICAgICAgICAgICB1bmlxdWVLZXlzLmZvckVhY2goa2V5PT57XG4gICAgICAgICAgICAgICAgICAgIGxldCBiaW4gPSBncm91cHNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy9UYWtlIHRoZSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludCBpbiB0aGUgZ3JvdXAgdG8gYmUgdGhlIGJpbiBsZWFkZXIgKHRoZXkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgcG9pbnRzIGFjdHVhbGx5PT4gc28ganVzdCB0YWtlIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgICAgICAgICAgICAgIGJpbi5zaXRlID0gYmluWzBdLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJpbnMucHVzaChiaW4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZG97XG4gICAgICAgICAgICAgICAgICAgIC8vU3RhcnQgd2l0aCBiaW5TaXplIHggYmluU2l6ZSB4IGJpblNpemUuLi4gYmlucywgYW5kIHRoZW4gaW5jcmVhc2UgaXQgYXMgYmluU2l6ZSA9IGJpblNpemUgKiBpbmNyZW1lbnRBICsgaW5jcmVtZW50QiBvciBiaW5TaXplID0gYmluU2l6ZSAqIGRlY3JlbWVudEEgKyBkZWNyZW1lbnRCLlxuICAgICAgICAgICAgICAgICAgICBpZihiaW5TaXplPT09bnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5TaXplID0gc3RhcnRCaW5HcmlkU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoYmlucy5sZW5ndGg+bWF4TnVtT2ZCaW5zKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpblNpemUgPSBiaW5TaXplKmRlY3JlbWVudEErZGVjcmVtZW50QjtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2UgaWYoYmlucy5sZW5ndGg8bWluTnVtT2ZCaW5zKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpblNpemUgPSBiaW5TaXplKmluY3JlbWVudEEgKyBpbmNyZW1lbnRCO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKGJpblR5cGU9PT1cImhleGFnb25cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAvLyBUaGlzIHNlY3Rpb24gdXNlcyBoZXhhZ29uIGJpbm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBzaG9ydERpYWdvbmFsID0gMS9iaW5TaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmluUmFkaXVzID0gTWF0aC5zcXJ0KDMpKnNob3J0RGlhZ29uYWwvMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpbm5lciA9IG5ldyBCaW5uZXIoKS5yYWRpdXMoYmluUmFkaXVzKS5leHRlbnQoW1swLCAwXSwgWzEsIDFdXSk7Ly9leHRlbnQgZnJvbSBbMCwgMF0gdG8gWzEsIDFdIHNpbmNlIHdlIGFscmVhZHkgbm9ybWFsaXplZCBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmlucyA9IGJpbm5lci5oZXhiaW4obm9ybWFsaXplZFBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKCFiaW5UeXBlIHx8IGJpblR5cGU9PT1cImxlYWRlclwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2VjdGlvbiB1c2VzIGxlYWRlciBiaW5uZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpblJhZGl1cyA9IE1hdGguc3FydChkaW1zKk1hdGgucG93KDEvKGJpblNpemUqMiksIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbm5lciA9IG5ldyBMZWFkZXJCaW5uZXIobm9ybWFsaXplZFBvaW50cywgYmluUmFkaXVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbnMgPSBiaW5uZXIubGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH13aGlsZShiaW5zLmxlbmd0aCA+IG1heE51bU9mQmlucyB8fCBiaW5zLmxlbmd0aCA8IG1pbk51bU9mQmlucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXRlcyA9IGJpbnMubWFwKGQ9PmQuc2l0ZSk7IC8vPT5zaXRlcyBhcmUgdGhlIHNldCBvZiBjZW50ZXJzIG9mIGFsbCBiaW5zXG4gICAgICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IHRoZSBiaW5uaW5nIGFuZCBiaW5uaW5nIHJlc3VsdHMqKioqKiovXG4gICAgICAgICAgICBvdXRwdXRWYWx1ZShcImJpbm5lclwiLCBiaW5uZXIpO1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUoXCJiaW5zXCIsIGJpbnMpO1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUoXCJiaW5TaXplXCIsIGJpblNpemUpO1xuICAgICAgICAgICAgb3V0cHV0VmFsdWUoXCJiaW5SYWRpdXNcIiwgYmluUmFkaXVzKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHNpdGVzID0gbm9ybWFsaXplZFBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dFZhbHVlKFwiYmlubmVkU2l0ZXNcIiwgc2l0ZXMpO1xuXG4gICAgICAgIC8qKioqKipUaGlzIHNlY3Rpb24gaXMgYWJvdXQgdGhlIHNwYW5uaW5nIHRyZWUgYW5kIHNwYW5uaW5nIHRyZWUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgLy9TcGFubmluZyB0cmVlIGNhbGN1bGF0aW9uXG4gICAgICAgIGxldCB0ZXRyYWhlZHJhQ29vcmRpbmF0ZXMgPSBbc2l0ZXNdO1xuICAgICAgICBsZXQgd2VpZ2h0cyA9IG9wdGlvbnMuZGlzdGFuY2VXZWlnaHRzO1xuICAgICAgICBsZXQgZ3JhcGggPSBjcmVhdGVHcmFwaCh0ZXRyYWhlZHJhQ29vcmRpbmF0ZXMsIHdlaWdodHMpO1xuICAgICAgICBsZXQgbXN0cmVlID0gbXN0KGdyYXBoKTtcbiAgICAgICAgLy9Bc3NpZ25pbmcgdGhlIG91dHB1dCB2YWx1ZXNcbiAgICAgICAgb3V0cHV0VmFsdWUoXCJncmFwaFwiLCBncmFwaCk7XG4gICAgICAgIG91dHB1dFZhbHVlKFwibXN0XCIsIG1zdHJlZSk7XG5cbiAgICAgICAgLyoqKioqKlRoaXMgc2VjdGlvbiBpcyBhYm91dCB0aGUgb3V0bHlpbmcgc2NvcmUgYW5kIG91dGx5aW5nIHNjb3JlIHJlc3VsdHMqKioqKiovXG4gICAgICAgICAgICAvL1RPRE86IE5lZWQgdG8gY2hlY2sgaWYgb3V0bHlpbmcgbGlua3MgYXJlIHJlYWxseSBjb25uZWN0ZWQgdG8gb3V0bHlpbmcgcG9pbnRzXG4gICAgICAgIGxldCBvdXRseWluZyA9IG5ldyBPdXRseWluZyhtc3RyZWUsIG91dGx5aW5nVXBwZXJCb3VuZCxvdXRseWluZ0NvZWZmaWNpZW50KTtcbiAgICAgICAgbGV0IG91dGx5aW5nU2NvcmUgPSBvdXRseWluZy5zY29yZSgpO1xuICAgICAgICBvdXRseWluZ1VwcGVyQm91bmQgPSBvdXRseWluZy51cHBlckJvdW5kO1xuICAgICAgICBsZXQgb3V0bHlpbmdMaW5rcyA9IG91dGx5aW5nLmxpbmtzKCk7XG4gICAgICAgIGxldCBvdXRseWluZ1NpdGVzID0gb3V0bHlpbmcucG9pbnRzKCkubWFwKHA9PnAuam9pbignLCcpKTtcbiAgICAgICAgbGV0IG91dGx5aW5nQmlucyA9IGJpbnMuZmlsdGVyKGI9PiBvdXRseWluZ1NpdGVzLmluZGV4T2YoYi5zaXRlLmpvaW4oJywnKSk+PTApIDtcblxuICAgICAgICAvL0FkZCBvdXRseWluZyBwb2ludHMgZnJvbSB0aGUgYmluIHRvIGl0LlxuICAgICAgICBsZXQgb3V0bHlpbmdQb2ludHMgPSBbXTtcbiAgICAgICAgb3V0bHlpbmcucG9pbnRzKCkuZm9yRWFjaChwPT57XG4gICAgICAgICAgICBiaW5zLmZvckVhY2goYj0+e1xuICAgICAgICAgICAgICAgIGlmKGVxdWFsUG9pbnRzKHAsIGIuc2l0ZSkpe1xuICAgICAgICAgICAgICAgICAgICBvdXRseWluZ1BvaW50cyA9IG91dGx5aW5nUG9pbnRzLmNvbmNhdChiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0VmFsdWUoXCJvdXRseWluZ0JpbnNcIiwgb3V0bHlpbmdCaW5zKTtcbiAgICAgICAgb3V0cHV0VmFsdWUoXCJvdXRseWluZ1Njb3JlXCIsIG91dGx5aW5nU2NvcmUpO1xuICAgICAgICBvdXRwdXRWYWx1ZShcIm91dGx5aW5nVXBwZXJCb3VuZFwiLCBvdXRseWluZ1VwcGVyQm91bmQpO1xuICAgICAgICBvdXRwdXRWYWx1ZShcIm91dGx5aW5nTGlua3NcIiwgb3V0bHlpbmdMaW5rcyk7XG4gICAgICAgIG91dHB1dFZhbHVlKFwib3V0bHlpbmdQb2ludHNcIiwgb3V0bHlpbmdQb2ludHMpO1xuXG5cbiAgICAgICAgLyoqKioqKlRoaXMgc2VjdGlvbiBpcyBhYm91dCB0aGUgc2tld2VkIHNjb3JlIGFuZCBza2V3ZWQgc2NvcmUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgbGV0IG5vT3V0bHlpbmdUcmVlID0gbXN0cmVlO1xuICAgICAgICBsZXQgc2tld2VkID0gbmV3IFNrZXdlZChub091dGx5aW5nVHJlZSk7XG4gICAgICAgIG91dHB1dFZhbHVlKFwic2tld2VkU2NvcmVcIiwgc2tld2VkLnNjb3JlKCkpO1xuXG4gICAgICAgIC8qKioqKipUaGlzIHNlY3Rpb24gaXMgYWJvdXQgdGhlIHNwYXJzZSBzY29yZSBhbmQgc3BhcnNlIHNjb3JlIHJlc3VsdHMqKioqKiovXG4gICAgICAgIGxldCBzcGFyc2UgPSBuZXcgU3BhcnNlKG5vT3V0bHlpbmdUcmVlKTtcbiAgICAgICAgb3V0cHV0VmFsdWUoXCJzcGFyc2VTY29yZVwiLCBzcGFyc2Uuc2NvcmUoKSk7XG5cbiAgICAgICAgLyoqKioqKlRoaXMgc2VjdGlvbiBpcyBhYm91dCB0aGUgY2x1bXB5IHNjb3JlIGFuZCBjbHVtcHkgc2NvcmUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgbGV0IGNsdW1weSA9IG5ldyBDbHVtcHkobm9PdXRseWluZ1RyZWUpO1xuICAgICAgICBvdXRwdXRWYWx1ZShcImNsdW1weVwiLCBjbHVtcHkpO1xuICAgICAgICBvdXRwdXRWYWx1ZShcImNsdW1weVNjb3JlXCIsIGNsdW1weS5zY29yZSgpKTtcblxuXG4gICAgICAgIC8vIC8qKioqKipUaGlzIHNlY3Rpb24gaXMgYWJvdXQgdGhlIHN0cmlhdGVkIHNjb3JlIGFuZCBzdHJpYXRlZCBzY29yZSByZXN1bHRzKioqKioqL1xuICAgICAgICAvLyBsZXQgc3RyaWF0ZWQgPSBuZXcgU3RyaWF0ZWQobm9PdXRseWluZ1RyZWUpO1xuICAgICAgICAvLyBvdXRwdXRWYWx1ZShcInN0cmlhdGVkU2NvcmVcIiwgc3RyaWF0ZWQuc2NvcmUoKSk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8qKioqKipUaGlzIHNlY3Rpb24gaXMgYWJvdXQgdGhlIGNvbnZleCBodWxsIGFuZCBjb252ZXggaHVsbCByZXN1bHRzKioqKioqL1xuICAgICAgICAvLyBsZXQgY29udmV4ID0gbmV3IENvbnZleChub091dGx5aW5nVHJlZSwgMS9vdXRseWluZy51cHBlckJvdW5kKTtcbiAgICAgICAgLy8gbGV0IGNvbnZleEh1bGwgPSBjb252ZXguY29udmV4SHVsbCgpO1xuICAgICAgICAvLyBvdXRwdXRWYWx1ZShcImNvbnZleEh1bGxcIiwgY29udmV4SHVsbCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vXG4gICAgICAgIC8vIC8qKioqKipUaGlzIHNlY3Rpb24gaXMgYWJvdXQgdGhlIGNvbmNhdmUgaHVsbCBhbmQgY29uY2F2ZSBodWxsIHJlc3VsdHMqKioqKiovXG4gICAgICAgIC8vIGxldCBjb25jYXZlSHVsbCA9IGNvbnZleC5jb25jYXZlSHVsbCgpO1xuICAgICAgICAvLyBvdXRwdXRWYWx1ZShcImNvbmNhdmVIdWxsXCIsIGNvbmNhdmVIdWxsKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gLyoqKioqKlRoaXMgc2VjdGlvbiBpcyBhYm91dCB0aGUgY29udmV4IHNjb3JlIGFuZCBjb252ZXggc2NvcmUgcmVzdWx0cyoqKioqKi9cbiAgICAgICAgLy8gbGV0IGNvbnZleFNjb3JlID0gY29udmV4LnNjb3JlKCk7XG4gICAgICAgIC8vIG91dHB1dFZhbHVlKFwiY29udmV4U2NvcmVcIiwgY29udmV4U2NvcmUpO1xuICAgICAgICAvL1xuICAgICAgICAvL1xuICAgICAgICAvLyAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IHRoZSBza2lubnkgc2NvcmUgYW5kIHNraW5ueSBzY29yZSByZXN1bHRzKioqKioqL1xuICAgICAgICAvLyBsZXQgc2tpbm55ID0gbmV3IFNraW5ueShjb25jYXZlSHVsbCk7XG4gICAgICAgIC8vIGxldCBza2lubnlTY29yZSA9IHNraW5ueS5zY29yZSgpO1xuICAgICAgICAvLyBvdXRwdXRWYWx1ZShcInNraW5ueVNjb3JlXCIsIHNraW5ueVNjb3JlKTtcbiAgICAgICAgLy9cbiAgICAgICAgLyoqKioqKlRoaXMgc2VjdGlvbiBpcyBhYm91dCB0aGUgc3RyaW5neSBzY29yZSBhbmQgc3RyaW5neSBzY29yZSByZXN1bHRzKioqKioqL1xuICAgICAgICBsZXQgc3RyaW5neSA9IG5ldyBTdHJpbmd5KG5vT3V0bHlpbmdUcmVlKTtcbiAgICAgICAgbGV0IHYxcyA9IHN0cmluZ3kuZ2V0QWxsVjFzKCk7XG4gICAgICAgIGxldCB2MkNvcm5lcnMgPSBzdHJpbmd5LmdldEFsbFYyQ29ybmVycygpO1xuICAgICAgICAvLyBsZXQgb2J0dXNlVjJDb3JuZXJzID0gc3RyaWF0ZWQuZ2V0QWxsT2J0dXNlVjJDb3JuZXJzKCk7XG4gICAgICAgIGxldCBzdHJpbmd5U2NvcmUgPSBzdHJpbmd5LnNjb3JlKCk7XG4gICAgICAgIG91dHB1dFZhbHVlKFwidjFzXCIsIHYxcyk7XG4gICAgICAgIG91dHB1dFZhbHVlKFwic3RyaW5neVNjb3JlXCIsIHN0cmluZ3lTY29yZSk7XG4gICAgICAgIG91dHB1dFZhbHVlKFwidjJDb3JuZXJzXCIsIHYyQ29ybmVycyk7XG4gICAgICAgIC8vIG91dHB1dFZhbHVlKFwib2J0dXNlVjJDb3JuZXJzXCIsIG9idHVzZVYyQ29ybmVycyk7XG5cblxuICAgICAgICAvKioqKioqVGhpcyBzZWN0aW9uIGlzIGFib3V0IHRoZSBtb25vdG9uaWMgc2NvcmUgYW5kIG1vbm90b25pYyBzY29yZSByZXN1bHRzKioqKioqL1xuICAgICAgICBsZXQgbW9ub3RvbmljID0gbmV3IE1vbm90b25pYyhub091dGx5aW5nVHJlZS5ub2Rlcy5tYXAobj0+bi5pZCkpO1xuICAgICAgICBsZXQgbW9ub3RvbmljU2NvcmUgPSBtb25vdG9uaWMuc2NvcmUoKTtcbiAgICAgICAgb3V0cHV0VmFsdWUoXCJtb25vdG9uaWNTY29yZVwiLCBtb25vdG9uaWNTY29yZSk7XG5cbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY2Fnbm9zdGljc25kO1xuICAgICAgICBmdW5jdGlvbiBvdXRwdXRWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgd2luZG93LnNjYWdub3N0aWNzbmRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbn0pKHdpbmRvdyk7Il0sIm5hbWVzIjpbImdsb2JhbCIsIl8iLCJkaXN0YW5jZSIsInF1YW50aWxlIiwibWF4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0NBQUE7Ozs7O0NBS0EsQ0FBQyxXQUFXOzs7Ozs7OztHQVFWLElBQUksSUFBSSxHQUFHLE9BQU8sSUFBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJO2FBQ3RELE9BQU9BLGNBQU0sSUFBSSxRQUFRLElBQUlBLGNBQU0sQ0FBQyxNQUFNLEtBQUtBLGNBQU0sSUFBSUEsY0FBTTthQUMvRCxJQUFJO2FBQ0osRUFBRSxDQUFDOzs7R0FHYixJQUFJLGtCQUFrQixHQUFHLElBQUksQ0FBQyxDQUFDLENBQUM7OztHQUdoQyxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLFFBQVEsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0dBQzlELElBQUksV0FBVyxHQUFHLE9BQU8sTUFBTSxLQUFLLFdBQVcsR0FBRyxNQUFNLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQzs7O0dBRzFFLElBQUksSUFBSSxHQUFHLFVBQVUsQ0FBQyxJQUFJO09BQ3RCLEtBQUssR0FBRyxVQUFVLENBQUMsS0FBSztPQUN4QixRQUFRLEdBQUcsUUFBUSxDQUFDLFFBQVE7T0FDNUIsY0FBYyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUM7Ozs7R0FJN0MsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLE9BQU87T0FDN0IsVUFBVSxHQUFHLE1BQU0sQ0FBQyxJQUFJO09BQ3hCLFlBQVksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDOzs7R0FHakMsSUFBSSxJQUFJLEdBQUcsVUFBVSxFQUFFLENBQUM7OztHQUd4QixJQUFJLENBQUMsR0FBRyxTQUFTLEdBQUcsRUFBRTtLQUNwQixJQUFJ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QUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUU7S0FDbEQsU0FBUyxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDbkMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7U0FDdkMsTUFBTSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxNQUFNLENBQUM7S0FDbEMsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRTtPQUMzQyxJQUFJLFVBQVUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztPQUM1QyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxVQUFVLEVBQUUsR0FBRyxDQUFDLEVBQUUsT0FBTyxLQUFLLENBQUM7TUFDaEU7S0FDRCxPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7Ozs7R0FJRixDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUcsU0FBUyxHQUFHLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRTtLQUNqRCxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztLQUNuQyxJQUFJLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUN2QyxNQUFNLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLE1BQU0sQ0FBQztLQUNsQyxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFO09BQzNDLElBQUksVUFBVSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO09B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QUM7SUFDbEMsRUFBRSxJQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7R0FRVCxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLElBQUksR0FBRyxTQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0tBQ3BELElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3RFLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUUsT0FBTyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDeEMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7Ozs7O0dBS0YsQ0FBQyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0tBQ3BDLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN2RixDQUFDOzs7O0dBSUYsQ0FBQyxDQUFDLElBQUksR0FBRyxTQUFTLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0tBQ2pDLElBQUksS0FBSyxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxPQUFPLENBQUMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ3RFLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxLQUFLLEVBQUUsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFD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TUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Q0FDL0M7Q0FDQSxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRztDQUNwQyxZQUFZLENBQUMsQ0FBQyxJQUFJLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztDQUNwQyxTQUFTLENBQUMsQ0FBQztDQUNYLFFBQVEsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsR0FBR0MsVUFBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDbEQsUUFBUSxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztDQUNsQyxRQUFRLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO0NBQ2xDLFFBQVEsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7Q0FDdEMsUUFBUSxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztDQUNoRCxRQUFRLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHO0NBQzVCLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHQSxVQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQy9CLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHQSxVQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQy9CLFlBQVksTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztDQUNyRSxZQUFZLFdBQVcs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UyxDQUFDO0NBQzdCLFNBQVM7Q0FDVCxLQUFLO0NBQ0wsQ0FBQzs7QUFFRCxDQUFPLFNBQVMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUU7Q0FDL0IsSUFBSSxJQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7Q0FDdkIsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtDQUN2QyxRQUFRLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDNUIsUUFBUSxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUM1QixZQUFZLFVBQVUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQzlCLFNBQVM7Q0FDVCxLQUFLO0NBQ0w7Q0FDQTtDQUNBLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztDQUNuRjs7Q0MzREE7QUFDQSxBQUdBO0NBQ0E7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0EsQ0FBTyxTQUFTLGFBQWEsQ0FBQyxLQUFLLEVBQUU7Q0FDckMsSUFBSSxJQUFJLGFBQWEsR0FBRyxFQUFFLENBQUM7Q0FDM0IsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSTtDQUN2QixRQUFRLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQzNDLFFBQVEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtDQUN2QyxZQUFZLGFBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7Q0FDMUMsU0FBUztDQUNULFFBQVEsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN6QyxRQUFRLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0NBQzNDLFFBQVEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsRUFBRTtDQUN2QyxZQUFZLGFBQWEsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7Q0FDMUMsU0FBUztDQUNULFFBQVEsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN6QyxLQUFLLENBQUMsQ0FBQztDQUNQO0NBQ0EsSUFBSSxJQUFJLGFBQWEsR0FBR0EsVUFBQyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztDQUMvQyxJQUFJLE9BQU8sYUFBYSxDQUFDO0NBQ3pCLENBQUM7O0NBRUQ7Q0FDQTtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0EsQ0FBTyxTQUFTLHVCQUF1QixDQUFDLElBQUksRUFBRTtDQUM5QyxJQUFJLElBQUksYUFBYSxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7Q0FDbEQ7Q0FDQSxJQUFJLElBQUksS0FBSyxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUM7O0NBRTVELElBQUksSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUk7Q0FDckMsUUFBUSxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7Q0FDeEI7Q0FDQSxRQUFRLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNuRDtDQUNBLFFBQVEsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUk7Q0FDOUIsWUFBWSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtDQUNoRCxnQkFBZ0IsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDekMsYUFBYSxNQUFNO0NBQ25CLGdCQUFnQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUN6QyxhQUFhO0NBQ2IsU0FBUyxDQUFDLENBQUM7Q0FDWCxRQUFRLE9BQU8sTUFBTSxDQUFDO0NBQ3RCLEtBQUssQ0FBQyxDQUFDO0NBQ1AsSUFBSSxPQUFPLFVBQVUsQ0FBQztDQUN0QixDQUFDO0NBQ0Q7Q0FDQTtDQUNBO0NBQ0E7QUFDQSxDQUFPLFNBQVMseUJBQXlCLENBQUMsSUFBSSxFQUFFO0NBQ2hELElBQUksSUFBSSxhQUFhLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNsRDtDQUNBLElBQUksSUFBSSxRQUFRLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztDQUMvRCxJQUFJLE9BQU8sUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztDQUMxRCxDQUFDO0NBQ0Q7Q0FDQTtDQUNBO0NBQ0E7QUFDQSxDQUFPLFNBQVMsaUJBQWlCLENBQUMsSUFBSSxFQUFFO0NBQ3hDLElBQUksSUFBSSxhQUFhLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNsRDtDQUNBLElBQUksSUFBSSxLQUFLLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztDQUM1RCxJQUFJLE9BQU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztDQUN6RCxDQUFDOztDQUVEO0NBQ0E7Q0FDQTtDQUNBO0FBQ0EsQ0FBTyxTQUFTLFdBQVcsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFOztDQUVqRCxJQUFJLFNBQVMsUUFBUSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFO0NBQ2xELFFBQVEsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7Q0FDMUUsS0FBSzs7Q0FFTCxJQUFJLElBQUksS0FBSyxHQUFHLEVBQUUsQ0FBQztDQUNuQixJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO0NBQ3JCLElBQUksS0FBSyxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUM7Q0FDckI7Q0FDQSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJO0NBQzVCLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLElBQUk7Q0FDeEIsWUFBWSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUU7Q0FDNUMsZ0JBQWdCLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0NBQy9DLGFBQWE7Q0FDYixTQUFTLENBQUMsQ0FBQztDQUNYLEtBQUssQ0FBQyxDQUFDOztDQUVQO0NBQ0EsSUFBSSxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSTtDQUM1QixRQUFRLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtDQUMvQyxZQUFZLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUMxQixZQUFZLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtDQUNuRCxnQkFBZ0IsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQzlCLGdCQUFnQixJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7Q0FDN0IsZ0JBQWdCLElBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztDQUM3QixnQkFBZ0IsSUFBSSxJQUFJLEdBQUdDLFVBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0NBQ3JELGdCQUFnQixJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztDQUNwRCxnQkFBZ0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxFQUFFO0NBQ3BELG9CQUFvQixLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztDQUMzQyxpQkFBaUI7Q0FDakIsYUFBYTtDQUNiLFNBQVM7Q0FDVCxLQUFLLENBQUMsQ0FBQzs7Q0FFUDtDQUNBLElBQUksU0FBUyxVQUFVLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRTtDQUNyQyxRQUFRLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7Q0FDbEMsUUFBUSxLQUFLLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtDQUM5QyxZQUFZLElBQUksVUFBVSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtDQUM1QyxnQkFBZ0IsT0FBTyxJQUFJLENBQUM7Q0FDNUIsYUFBYTtDQUNiLFNBQVM7Q0FDVCxRQUFRLE9BQU8sS0FBSyxDQUFDO0NBQ3JCLEtBQUs7Q0FDTCxJQUFJLE9BQU8sS0FBSyxDQUFDO0NBQ2pCLENBQUM7O0FBRUQsQ0FBTyxTQUFTQSxVQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUU7Q0FDeEMsSUFBSSxJQUFJLGVBQWUsR0FBRyxDQUFDLENBQUM7Q0FDNUIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0NBQ2xCLFFBQVEsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Q0FDM0MsWUFBWSxJQUFJLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3JELFlBQVksSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Q0FDckMsZ0JBQWdCLGVBQWUsSUFBSSxJQUFJLENBQUM7Q0FDeEMsYUFBYTtDQUNiLFNBQVM7Q0FDVCxLQUFLLE1BQU07Q0FDWCxRQUFRLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0NBQzNDLFlBQVksSUFBSSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNyRCxZQUFZLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0NBQ3JDLGdCQUFnQixlQUFlLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNyRCxhQUFhO0NBQ2IsU0FBUztDQUNULEtBQUs7Q0FDTDtDQUNBO0NBQ0EsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0NBQ3hGLENBQUM7O0FBRUQsQ0FBTyxTQUFTLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO0NBQ3RDLElBQUksS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Q0FDekMsUUFBUSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7Q0FDL0IsWUFBWSxPQUFPLEtBQUssQ0FBQztDQUN6QixTQUFTO0NBQ1QsS0FBSztDQUNMLElBQUksT0FBTyxJQUFJLENBQUM7Q0FDaEIsQ0FBQzs7QUFFRCxDQUFPLFNBQVMsV0FBVyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7Q0FDM0MsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtDQUM1QyxRQUFRLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUMvQixRQUFRLElBQUksV0FBVyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsRUFBRTtDQUN4QyxZQUFZLE9BQU8sSUFBSSxDQUFDO0NBQ3hCLFNBQVM7Q0FDVCxLQUFLO0NBQ0wsSUFBSSxPQUFPLEtBQUssQ0FBQztDQUNqQixDQUFDOztBQUVELENBQU8sU0FBUyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRTtDQUNuQyxJQUFJLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQztDQUNsRixTQUFTLFdBQVcsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztDQUNqRixDQUFDOztBQUVELENBQU8sU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRTtDQUNwQyxJQUFJLElBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7Q0FDOUIsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtDQUMxQyxRQUFRLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUM1QixRQUFRLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUU7Q0FDdEMsWUFBWSxPQUFPLElBQUksQ0FBQztDQUN4QixTQUFTO0NBQ1QsS0FBSztDQUNMLElBQUksT0FBTyxLQUFLLENBQUM7Q0FDakIsQ0FBQzs7QUFFRCxDQUFPLFNBQVMsUUFBUSxDQUFDLEVBQUUsRUFBRTtDQUM3QixJQUFJLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7Q0FDdEIsQ0FBQzs7Q0FFRDtDQUNBO0NBQ0E7Q0FDQTtDQUNBO0FBQ0EsQ0FBTyxTQUFTLEdBQUcsQ0FBQyxLQUFLLEVBQUU7Q0FDM0IsSUFBSSxJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUMsS0FBSztDQUM5QixRQUFRLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDcEMsUUFBUSxhQUFhLEdBQUcsRUFBRTtDQUMxQixRQUFRLE1BQU0sR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDOztDQUVuQztDQUNBLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sS0FBSztDQUNqQyxRQUFRLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0NBQ2xDLEtBQUssQ0FBQyxDQUFDOztDQUVQO0NBQ0E7Q0FDQSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLO0NBQ3pCLFFBQVEsT0FBTyxFQUFFLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQ3RDLEtBQUssQ0FBQyxDQUFDOztDQUVQLElBQUksT0FBTyxLQUFLLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7Q0FDOUMsUUFBUSxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFLENBQUM7O0NBRS9CLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtDQUNuRSxZQUFZLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDbkQsWUFBWSxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0NBQ3JDLFNBQVM7Q0FDVCxLQUFLOztDQUVMLElBQUksT0FBTztDQUNYLFFBQVEsS0FBSyxFQUFFLFFBQVE7Q0FDdkIsUUFBUSxLQUFLLEVBQUUsYUFBYTtDQUM1QixLQUFLO0NBQ0wsQ0FBQzs7Q0FFRDtDQUNBLFNBQVMsV0FBVyxHQUFHO0NBQ3ZCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUM7Q0FDckIsQ0FBQzs7Q0FFRCxTQUFTLElBQUksQ0FBQyxFQUFFLEVBQUU7Q0FDbEIsSUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQztDQUNsQixJQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0NBQ3hCLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7Q0FDbkIsQ0FBQzs7Q0FFRCxXQUFXLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxVQUFVLEVBQUUsRUFBRTtDQUM5QyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFO0NBQzFCLFFBQVEsSUFBSSxPQUFPLEdBQUcsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7Q0FDbkMsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQztDQUNsQyxLQUFLO0NBQ0wsRUFBQzs7Q0FFRDtDQUNBO0NBQ0EsV0FBVyxDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBVSxFQUFFLEVBQUU7Q0FDM0MsSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssU0FBUyxFQUFFO0NBQ3ZDLFFBQVEsT0FBTyxTQUFTLENBQUM7Q0FDekIsS0FBSzs7Q0FFTCxJQUFJLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDO0NBQzFDLElBQUksT0FBTyxPQUFPLEtBQUssT0FBTyxDQUFDLE9BQU8sRUFBRTtDQUN4QyxRQUFRLE9BQU8sR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0NBQ2xDLEtBQUs7Q0FDTCxJQUFJLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQztDQUN2QixFQUFDOztDQUVELFdBQVcsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsRUFBRTtDQUM5QyxJQUFJLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQzFDLElBQUksSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O0NBRTFDLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLEtBQUssRUFBRTtDQUN2RTtDQUNBLFFBQVEsT0FBTztDQUNmLEtBQUs7O0NBRUwsSUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRTtDQUNqQyxRQUFRLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0NBQzlCLEtBQUssTUFBTSxJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRTtDQUMxQyxRQUFRLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0NBQzlCLEtBQUssTUFBTTtDQUNYLFFBQVEsS0FBSyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7Q0FDOUIsUUFBUSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7Q0FDdEIsS0FBSztDQUNMLEVBQUM7O0NBRUQ7Q0FDQSxXQUFXLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFZO0NBQ3pDLElBQUksSUFBSSxhQUFhLEdBQUcsRUFBRSxDQUFDO0NBQzNCLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxLQUFLO0NBQzdDLFFBQVEsYUFBYSxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztDQUNqQyxLQUFLLENBQUMsQ0FBQztDQUNQLElBQUksT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztDQUM3QyxFQUFDO0NBQ0Q7O2lCQUFnQixoQkMvUm9xRCxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEFBQWtaLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQUFBbXhOLElBQXdVLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUE0N0osSUFBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUE0a0IsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztDQ0lqNWdCO0NBQ0E7Q0FDQTtBQUNBLENBQU8sTUFBTSxRQUFRLENBQUM7Q0FDdEIsSUFBSSxXQUFXLENBQUMsSUFBSSxFQUFFLE9BQU8s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
