<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scagnostics 3D</title>
    <link href="css/styles.css" rel="stylesheet"/>
    <script src="lib/d3.js"></script>
    <script src="lib/d3-3d.min.js"></script>
    <script src="build/js/scagnostics3d.min.js"></script>

</head>
<body>
<!--<svg id="normalizedsvg"-->
     <!--style="overflow: visible; margin-top:0px;"></svg>-->
<svg id="scagsvg"
     style="overflow: visible; margin-top:0px;"></svg>
<script>
    let data = null;
    let data3d = null;
    let svgWidth = 1000;
    let svgHeight = 1000;
    let duration = 1000;
    let scagsvg = d3.select("#scagsvg").attr("width", svgWidth).attr("height", svgHeight),
        // normalizedsvg = d3.select("#normalizedsvg").attr("width", svgWidth).attr("height", svgHeight),
        margins = {left: 20, top: 20, right: 20, bottom: 20},
        padding = 10,
        contentWidth = +scagsvg.attr("width") - margins.left - margins.right - 2 * padding,
        contentHeight = +scagsvg.attr("height") - margins.top - margins.bottom - 2 * padding;
    drawContentBound(scagsvg);
    function drawContentBound(svg) {
        let x = margins.left;
        let y = margins.top;
        let rectWidth = +svg.attr("width") - margins.left - margins.right;
        let rectHeight = +svg.attr("height") - margins.top - margins.bottom;
        svg.append("rect").attr("x", x).attr("y", y).attr("width", rectWidth).attr("height", rectHeight).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "#ddd");
    }
    let scaleX = d3.scaleLinear().domain([0, 1]).range([-contentWidth / 4, contentWidth / 4]),
        scaleY = d3.scaleLinear().domain([0, 1]).range([-contentHeight / 4, contentHeight / 4]),
        scaleZ = d3.scaleLinear().domain([0, 1]).range([-contentHeight / 4, contentHeight / 4]),
        scaleR = d3.scaleLinear().domain([0, 1]).range([0, contentHeight]);
    let origin = [contentWidth / 2, contentHeight / 2], xLine = [], yLine = [], zLine = [], beta = 0, alpha = 0,
        startAngle = 0;

    let mx, my, mouseX, mouseY;
    let yScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .scale(contentHeight / 2)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let xScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .scale(contentHeight / 2)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let zScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .scale(contentHeight / 2)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let point3d = d3._3d()
        .x(d => scaleX(d[0]))
        .y(d => scaleY(d[1]))
        .z(d => scaleZ(d[2]))
        .origin(origin)
        .scale(1)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let line3d = d3._3d()
        .shape('LINE')
        .x(d => scaleX(d[0]))
        .y(d => scaleY(d[1]))
        .z(d => scaleZ(d[2]))
        .origin(origin)
        .scale(1)
        .rotateY(startAngle)
        .rotateX(-startAngle);

    // /***********SOIL DATA*******************/
    // d3.csv("../data/Soil_Profile1.csv", function (error, rawData) {
    //     if (error) throw error;
    //     data = rawData.filter(function (d) {
    //         //Valid ID
    //         return validGridId(d["Grid ID"]);
    //     });
    //     let currentColumnNames = ['Ni Concentration', 'Si Concentration', 'Ca Concentration'];
    //     let points = data.map(function (d) {
    //         var result = [];
    //         currentColumnNames.forEach(c => {
    //             result.push((d[c].indexOf('<LOD') != -1) ? 0 : +d[c]);
    //         });
    //         result.data = d['Grid ID'];
    //         return result;
    //     });
    //     //Filter NaN points
    //     points = points.filter(x => isValidPoint(x));
    //     draw(points);
    //
    //     function isValidPoint(d) {
    //         let result = true;
    //         for (let i = 0; i < d.length; i++) {
    //             if (typeof d[i] !== 'number') {
    //                 result = false;
    //                 break;
    //             }
    //         }
    //         return result;
    //     }
    //
    //     function validGridId(id) {
    //         let re = /^[A-Z]\d\d$/g;
    //         return id != null && id.match(re) != null;
    //     }
    //
    // });
    /***********RANDOM DATA*******************/
    let randomX = d3.randomNormal(contentWidth / 2, 50),
        randomY = d3.randomNormal(contentHeight / 2, 50),
        randomZ = d3.randomNormal(contentHeight /2, 50),
        points = d3.range(100).map(function () {
            return [randomX(), randomY(), randomZ()];
        });
    draw(points);
    function draw(points){
        // let scagOptions ={
        //     startBinGridSize: 20,
        //     minBins: 10,
        //     maxBins: 200
        // }
        let scagOptions = {};
        let scag = scagnostics3d(points, scagOptions);

        //Process the drag
        scagsvg = scagsvg.call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g').attr('transform', `translate(${margins.left}, ${margins.top})`);
        //Process yLine
        d3.range(-5, 6, 1).forEach(d => {
            xLine.push([d * 0.1, -0.5, -0.5]);
            yLine.push([-0.5, -d * 0.1, -0.5]);
            zLine.push([-0.5, -0.5, d * 0.1]);
        });
        let binColor = d3.scaleSequential(d3.interpolateLab("#fff", "steelblue"))
            .domain(d3.extent(scag.bins.map(p => p.length)));

        let axesData = [yScale3d([yLine]), xScale3d([xLine]), zScale3d([zLine])];
        let pointsData = point3d(scag.normalizedPoints);
        let leaderPoints = scag.bins.map((d, i) => {
            let ret = [d.x, d.y, d.z];
            ret.data = {};
            ret.data.id = "leader_" + i;
            ret.data.size = d.length;
            ret.data.binRadius = scag.binRadius;
            return ret
        });


        let leadersData = point3d(leaderPoints);

        let graphLines = scag.graph.links.map((l, i)=>{
            let ret = [l.source, l.target];
            ret.data = {}
            ret.data.id = 'graphLine_' + i;
            return ret;
        });
        let graphLinesData = line3d(graphLines);

        let mstLines = scag.mst.links.map((l, i)=>{
            let ret = [l.source, l.target];
            ret.data = {}
            ret.data.id = 'mstLine_' + i;
            return ret;
        });
        let mstLinesData = line3d(mstLines);

        drawAxes(axesData, scagsvg);
        drawPoints(pointsData, scagsvg, duration);
        drawLeaders(leadersData, scagsvg, duration);
        // drawLines(graphLinesData, scagsvg,'graphLines', duration);
        let mstLineOptions = {'stroke': 'green', 'strokeWidth': 1}
        drawLines(mstLinesData, scagsvg,'mstLines', duration, mstLineOptions);



        function dragStart() {
            mx = d3.event.x;
            my = d3.event.y;
        }

        function dragged() {
            mouseX = mouseX || 0;
            mouseY = mouseY || 0;
            beta = (d3.event.x - mx + mouseX) * Math.PI / 230;
            alpha = (d3.event.y - my + mouseY) * Math.PI / 230 * (-1);
            let axesData = [
                yScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([yLine]),
                xScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([xLine]),
                zScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([zLine])
            ]
            let pointsData = point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(scag.normalizedPoints);
            let leadersData = point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(leaderPoints);
            let graphLinesData = line3d.rotateY(beta+startAngle).rotateX(alpha-startAngle)(graphLines);
            let mstLinesData = line3d.rotateY(beta+startAngle).rotateX(alpha-startAngle)(mstLines);

            drawAxes(axesData, scagsvg);
            drawPoints(pointsData, scagsvg, 0);
            drawLeaders(leadersData, scagsvg, 0);
            // drawLines(graphLinesData, scagsvg, 'graphLines', 0);
            drawLines(mstLinesData, scagsvg, 'mstLines', 0, mstLineOptions);
        }

        function dragEnd() {
            mouseX = d3.event.x - mx + mouseX;
            mouseY = d3.event.y - my + mouseY;
        }
        function drawLines(data, svg, classType, duration, lineOptions={}){
            if(!lineOptions) lineOptions = {};
            let stroke = lineOptions.stroke;
            let strokeWidth = lineOptions.strokeWidth;
            if(stroke===undefined){
                stroke = 'black';
            }
            if(strokeWidth===undefined){
                strokeWidth = 0.5;
            }
            let lines = svg.selectAll(`line.${classType}`).data(data, d=>d.data.id);
            lines
                .enter()
                .append('line')
                .attr('class', `_3d ${classType}`)
                .merge(lines)
                .attr('stroke', stroke)
                .attr('stroke-width', strokeWidth)
                .attr('x1', d=>d[0].projected.x)
                .attr('y1', d=>d[0].projected.y)
                .attr('x2', d=>d[0].projected.x)
                .attr('y2', d=>d[0].projected.y)
                .transition().duration(duration)
                .attr('x2', d=>d[1].projected.x)
                .attr('y2', d=>d[1].projected.y);
            lines.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }
        function drawAxes(data, svg) {
            /*y-Scale*/
            let yScale = svg.selectAll('path.yScale').data(data[0]);
            yScale
                .enter()
                .append('path')
                .attr('class', '_3d yScale')
                .merge(yScale)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .attr('d', yScale3d.draw);
            yScale.exit().remove();
            /*y-Scale text*/
            let yText = svg.selectAll('text.yText').data(data[0][0]);
            yText
                .enter()
                .append('text')
                .attr('class', "_3d yText")
                .attr('dx', '.3em')
                .merge(yText)
                .each(d => {
                    d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
                })
                .attr('x', d => d.projected.x)
                .attr('y', d => d.projected.y)
                .text(d => {
                    let val = d[1] + 0.5
                    if (val === 0) {
                        return ''
                    } else if (val === 1) {
                        return 'y'
                    } else {
                        return (val).toFixed(1);
                    }
                });
            yText.exit().remove();
            /*x-Scale*/
            let xScale = svg.selectAll('path.xScale').data(data[1]);
            xScale
                .enter()
                .append('path')
                .attr('class', '_3d xScale')
                .merge(xScale)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .attr('d', xScale3d.draw);
            xScale.exit().remove();
            /*y-Scale text*/
            let xText = svg.selectAll('text.xText').data(data[1][0]);
            xText
                .enter()
                .append('text')
                .attr('class', "_3d xText")
                .attr('dx', '.3em')
                .merge(xText)
                .each(d => {
                    d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
                })
                .attr('x', d => d.projected.x)
                .attr('y', d => d.projected.y)
                .text(d => {
                    let val = d[0] + 0.5
                    if (val === 0) {
                        return ''
                    } else if (val === 1) {
                        return 'x'
                    } else {
                        return (val).toFixed(1);
                    }
                });
            xText.exit().remove();
            /*z-Scale*/
            let zScale = svg.selectAll('path.zScale').data(data[2]);
            zScale
                .enter()
                .append('path')
                .attr('class', '_3d zScale')
                .merge(zScale)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .attr('d', zScale3d.draw);
            zScale.exit().remove();
            /*y-Scale text*/
            var zText = svg.selectAll('text.zText').data(data[2][0]);
            zText
                .enter()
                .append('text')
                .attr('class', "_3d zText")
                .attr('dx', '.3em')
                .merge(zText)
                .each(d => {
                    d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
                })
                .attr('x', d => d.projected.x)
                .attr('y', d => d.projected.y)
                .text(d => {
                    let val = d[2] + 0.5
                    if (val === 0) {
                        return ''
                    } else if (val === 1) {
                        return 'z'
                    } else {
                        return (val).toFixed(1);
                    }
                });
            zText.exit().remove();

            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }

        function drawPoints(data, svg, duration) {
            let points = svg.selectAll('circle.points').data(data, d => d.data);
            points
                .enter()
                .append('circle')
                .attr('class', '_3d points')
                .attr('opacity', 0)
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y)
                .merge(points)
                .transition().duration(duration)
                .attr('r', 1)
                .attr('stroke', 'black')
                .attr('fill', 'grey')
                .attr('opacity', 1)
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y);
            points.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }

        function drawLeaders(data, svg, duration) {
            let leaders = svg.selectAll('circle.leaders').data(data, d => d.data.id);
            leaders
                .enter()
                .append('circle')
                .attr('class', '_3d leaders')
                .attr('opacity', 0)
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y)
                .merge(leaders)
                .transition().duration(duration)
                .attr('r',d=> scaleR(d.data.binRadius))
                .attr('stroke', 'black')
                .attr('fill', d=>binColor(d.data.size))
                .attr('opacity', 0.5)
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y);
            leaders.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }
    }

</script>
</body>
</html>