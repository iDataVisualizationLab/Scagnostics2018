<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="lib/d3.js"></script>
    <script src="lib/d3-3d.min.js"></script>
    <style type="text/css">
        button {
            position: absolute;
            right: 10px;
            top: 10px;
        }
    </style>
</head>
<body>
<svg width="960" height="500"></svg>
<button>update</button>
<script>
    var origin = [480, 300], j = 10, scale = 20,
        scatter = [],
        yLine = [],
        xLine = [],
        xGrid = [],
        beta = 0,
        alpha = 0,
        key = function (d) {
            return d.id
        },
        startAngle = Math.PI / 4;
    var svg = d3.select('svg').call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g');
    var color = d3.scaleOrdinal(d3.schemeCategory20);
    var mx, my, mouseX, mouseY;
    var grid3d = d3._3d()
        .shape('GRID', 20)
        .origin(origin)
        .rotateY(startAngle)
        .rotateX(-startAngle)
        .scale(scale);
    var point3d = d3._3d()
        .x(d => d.x)
        .y(d => d.y)
        .z(d => d.z)
        .origin(origin)
        .rotateY(startAngle)
        .rotateX(-startAngle)
        .scale(scale);
    var yScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .rotateY(startAngle)
        .rotateX(-startAngle)
        .scale(scale);
    var xScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .rotateX(startAngle)
        .rotateY(-startAngle)
        .scale(scale);
    //Process data
    function processData(data, tt){
        /*-------------GRID-------------*/
        var xGrid = svg.selectAll('path.grid').data(data[0], key);
        xGrid
            .enter()
            .append('path')
            .attr('class', '_3d grid')
            .merge(xGrid)
            .attr('stroke', 'black')
            .attr('stroke-width', 0.3)
            .attr('fill', d=> d.ccw ? 'green': 'red')
            .attr('fill-opacity', 0.9)
            .attr('d', grid3d.draw);
        xGrid.exit().remove();
        /*-------------POINT------------*/
        var points = svg.selectAll('circle').data(data[1], key);
        points.enter()
            .append('circle')
            .attr('class', '_3d')
            .attr('opacity', 0)
            .attr('cx', posPointX)
            .attr('cy', posPointY)
            .merge(points)
            .transition().duration(tt)
            .attr('r', 3)
            .attr('stroke', d=> d3.color(color(d.id)).darker(3))
            .attr('fill', d=>color(d.id))
            .attr('opacity', 1)
            .attr('cx', posPointX)
            .attr('cy', posPointY);
        points.exit().remove();
        /*-------------y-Scale------------*/
        var yScale = svg.selectAll('path.yScale').data(data[2]);
        yScale
            .enter()
            .append('path')
            .attr('class', '_3d yScale')
            .merge(yScale)
            .attr('stroke', 'black')
            .attr('stroke-width', .5)
            .attr('d', yScale3d.draw);
        yScale.exit().remove();
        /*------------y-Scale Text---------*/
        var yText = svg.selectAll('text.yText').data(data[2][0]);
        yText
            .enter()
            .append('text')
            .attr('class', '_3d yText')
            .attr('dx', '.3em')
            .merge(yText)
            .each(d=>{
                d.centroid = {x: d.rotated.x, y: d.rotated.y, z:d.rotated.z};
            })
            .attr('x', d=>d.projected.x)
            .attr('y', d=>d.projected.y)
            .text(d=> d[1]<0 ? d[1]: '');
        yText.exit().remove();

        /*-----------x-Scale---------------*/
        var xScale = svg.selectAll('path.xScale').data(data[3]);
        xScale
            .enter()
            .append('path')
            .attr('class', '_3d xScale')
            .merge(xScale)
            .attr('stroke', 'black')
            .attr('stroke-width', 0.5)
            .attr('d', xScale3d.draw);
        xScale.exit().remove();
        /*------------x-Scale Text----------*/
        var xText = svg.selectAll('text.xText').data(data[3][0]);
        xText
            .enter()
            .append('text')
            .attr('class', '_3d xText')
            .attr('dx', '.3em')
            .merge(xText)
            .each(d=>{
                d.centroid = {x: d.rotated.x, y: d.rotated.y, z:d.rotated.z};
            })
            .attr('x', d=>d.projected.x)
            .attr('y', d=>d.projected.y)
            .text(d=>d[0]<0?d[0]:'');
        xText.exit().remove();
        d3.selectAll('._3d').sort(d3._3d().sort)

    }
    function posPointX(d){
        return d.projected.x;
    }
    function posPointY(d){
        return d.projected.y;
    }
    function init(){
        var cnt = 0;
        xGrid = [], scatter = [], yLine = [];
        for (var z = -j; z< j; z++){
            for(var x = -j; x< j; x++){
                xGrid.push([x, 1, z]);
                scatter.push({x:x, y:d3.randomUniform(0, -10)(), z: z, id: 'point_'+cnt++});
            }
        }
        d3.range(-1, 11, 1).forEach(d=>{
            yLine.push([-j, -d, -j]);
            xLine.push([-d, -j, -j]);
        });
        var data = [
            grid3d(xGrid),
            point3d(scatter),
            yScale3d([yLine]),
            xScale3d([xLine])
        ];
        processData(data, 1000);
    }
    function dragStart(){
        mx = d3.event.x;
        my = d3.event.y;
    }
    function dragged(){
        mouseX = mouseX || 0;
        mouseY = mouseY || 0;
        beta = (d3.event.x - mx + mouseX)*Math.PI/230;
        alpha = (d3.event.y - my + mouseY)*Math.PI/230 *(-1);
        var data = [
            grid3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(xGrid),
            point3d.rotateY(beta+startAngle).rotateX(alpha-startAngle)(scatter),
            yScale3d.rotateY(beta+startAngle).rotateX(alpha - startAngle)([yLine]),
            yScale3d.rotateY(beta+startAngle).rotateX(alpha-startAngle)([xLine])
        ];
        processData(data, 0);
    }
    function dragEnd() {
        mouseX = d3.event.x - mx + mouseX;
        mouseY = d3.event.y - my + mouseY;
    }
    d3.selectAll('button').on('click', init);
    init();
</script>
</body>
</html>