<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scagnostics 3D</title>
    <link href="css/styles.css" rel="stylesheet"/>
    <script src="lib/d3.js"></script>
    <script src="lib/d3-3d.min.js"></script>
    <script src="build/js/scagnostics3d.min.js"></script>

</head>
<body>
<!--<svg id="normalizedsvg"-->
<!--style="overflow: visible; margin-top:0px;"></svg>-->
<svg id="scagsvg"
     style="overflow: visible; margin-top:0px;"></svg>
<div id="controlButtons"></div>
<div id="msg"></div>
<script>
    let data = null;
    let svgWidth = 1000;
    let svgHeight = 1000;
    let duration = 1000;
    let dataPointRadius = 2;
    let dataPointOpacity = 0.9;
    let binOpacity = 0.8;
    let scagsvg = d3.select("#scagsvg").attr("width", svgWidth).attr("height", svgHeight),
        margins = {left: 20, top: 20, right: 20, bottom: 20},
        padding = 10,
        contentWidth = +scagsvg.attr("width") - margins.left - margins.right - 2 * padding,
        contentHeight = +scagsvg.attr("height") - margins.top - margins.bottom - 2 * padding;
    drawContentBound(scagsvg);

    function drawContentBound(svg) {
        let x = margins.left;
        let y = margins.top;
        let rectWidth = +svg.attr("width") - margins.left - margins.right;
        let rectHeight = +svg.attr("height") - margins.top - margins.bottom;
        svg.append("rect").attr("x", x).attr("y", y).attr("width", rectWidth).attr("height", rectHeight).attr("stroke", "black").attr("stroke-width", 1).attr("fill", "#ddd");
    }

    //<editor-fold desc="section about animating the display">
    let origPoints = null;
    let bins = null;
    let triangulations = null;//line
    let mst = null;//line
    let outlyingLinks = null;//line
    let outlyingPoints = null;//circle
    let noOutlyingTree = null;//path
    let noOutlyingPoints = null;//circle
    let runtGraph = null;
    let v2Corners = null;//circle
    let obtuseV2Corners = null;//path
    let noOutlyingTriangulations = null;//path
    let convexHull = null;//path
    let concaveHull = null;//path
    let v1s = null;//circle
    let animateTime = 10;

    function selectElements() {
        origPoints = scagsvg.selectAll('circle.origPoints');
        bins = scagsvg.selectAll('circle.bins');
        triangulations = scagsvg.selectAll('line.graphLines');//line
        mst = scagsvg.selectAll('line.mstLines');//line
        outlyingLinks = scagsvg.selectAll('line.outlyingLines');//line
        v2Corners = scagsvg.selectAll('circle.v2Corners');//circle
        v1s = scagsvg.selectAll('circle.v1Corners');//circle
        convexHull = scagsvg.selectAll('line.convexHullLines');
        concaveHull = scagsvg.selectAll('path.concaveHullFaces');
    }

    //This method is called in string (creating the button using JS) so though it is displayed as unused => it is used.
    function toggleDisplay(selection) {
        if (+d3.select(selection.node()).style("opacity") != 10e-6) {
            selection.transition().duration(1000).style("opacity", 10e-6).style("display", "none");
        } else {
            animateNodes(selection, animateTime, 10e-6, .8);
            selection.style("display", "inline");
        }
    }

    function animateNodes(selection, time, fromOpacity, toOpacity, onEnd) {
        recurseDisplay(selection, 0, time, fromOpacity, toOpacity, onEnd);

        function recurseDisplay(selection, i, time, fromOpacity, toOpacity) {
            let nodes = selection.nodes();
            let length = nodes.length;
            if (i < length) {
                d3.select(nodes[i]).style("opacity", fromOpacity).transition().duration(time).style("opacity", toOpacity);
                i = i + 1;
                //recurse
                setTimeout(() => {
                    recurseDisplay(selection, i, time, fromOpacity, toOpacity, onEnd);
                }, time);
            } else {
                if (onEnd) {
                    onEnd();
                }
            }
        }
    }

    let theOptions = ["origPoints", "bins", "triangulations", "mst", "outlyingLinks"
        //, "outlyingPoints", "noOutlyingTree", "noOutlyingPoints"
        , "v2Corners",
        //"obtuseV2Corners",
        // "noOutlyingTriangulations",
        "convexHull",
        "concaveHull",
        "v1s"
    ];

    function createControlButtons(theContainer, theOptions) {
        let controlButtons = d3.select("#" + theContainer);
        theOptions.forEach(option => {
            controlButtons.append("button")
                .attr("onclick", `toggleDisplay(${option})`)
                .html("Toggle " + option);

        });
    }

    createControlButtons("controlButtons", theOptions);
    //</editor-fold>

    let scaleX = d3.scaleLinear().domain([0, 1]).range([-contentWidth / 4, contentWidth / 4]),
        scaleY = d3.scaleLinear().domain([0, 1]).range([-contentHeight / 4, contentHeight / 4]),
        scaleZ = d3.scaleLinear().domain([0, 1]).range([-contentHeight / 4, contentHeight / 4]),
        scaleR = d3.scaleLinear().domain([0, 1]).range([0, contentHeight]);
    let origin = [contentWidth / 2, contentHeight / 2], xLine = [], yLine = [], zLine = [], beta = 0, alpha = 0,
        startAngle = Math.PI / 4;

    //<editor-fold desc="Section about 3d objects">
    let mx, my, mouseX, mouseY;
    let yScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .scale(contentHeight / 2)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let xScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .scale(contentHeight / 2)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let zScale3d = d3._3d()
        .shape('LINE_STRIP')
        .origin(origin)
        .scale(contentHeight / 2)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    var grid3d = d3._3d()
        .shape('GRID', 11)
        .origin(origin)
        .rotateY(startAngle)
        .rotateX(-startAngle)
        .scale(contentHeight / 2);
    let point3d = d3._3d()
        .x(d => scaleX(d[0]))
        .y(d => scaleY(d[1]))
        .z(d => scaleZ(d[2]))
        .origin(origin)
        .scale(1)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let line3d = d3._3d()
        .shape('LINE')
        .x(d => scaleX(d[0]))
        .y(d => scaleY(d[1]))
        .z(d => scaleZ(d[2]))
        .origin(origin)
        .scale(1)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    let triangle3d = d3._3d()
        .shape('TRIANGLE')
        .x(d => scaleX(d[0]))
        .y(d => scaleY(d[1]))
        .z(d => scaleZ(d[2]))
        .origin(origin)
        .scale(1)
        .rotateY(startAngle)
        .rotateX(-startAngle);
    //</editor-fold>


    // /***********SOIL DATA*******************/
    // d3.csv("../data/Soil_Profile1.csv", function (error, rawData) {
    //     if (error) throw error;
    //     data = rawData.filter(function (d) {
    //         //Valid ID
    //         return validGridId(d["Grid ID"]);
    //     });
    //     let currentColumnNames = ['Ni Concentration', 'Si Concentration', 'Ca Concentration'];
    //     let points = data.map(function (d) {
    //         var result = [];
    //         currentColumnNames.forEach(c => {
    //             if (d[c] !== "") {
    //                 result.push((d[c].indexOf('<LOD') != -1) ? 0 : +d[c]);
    //             } else {
    //                 result.push('NaN');
    //             }
    //         });
    //         result.data = d['Grid ID'];
    //         return result;
    //     });
    //     //Filter NaN points
    //     points = points.filter(x => isValidPoint(x));
    //     draw(points);
    //
    //     function isValidPoint(d) {
    //         let result = true;
    //         for (let i = 0; i < d.length; i++) {
    //             if (typeof d[i] !== 'number') {
    //                 result = false;
    //                 break;
    //             }
    //         }
    //         return result;
    //     }
    //
    //     function validGridId(id) {
    //         let re = /^[A-Z]\d\d$/g;
    //         return id != null && id.match(re) != null;
    //     }
    //
    // });

    // /***********RANDOM DATA*******************/
    // let randomX = d3.randomNormal(contentWidth / 2, 50),
    //     randomY = d3.randomNormal(contentHeight / 2, 50),
    //     randomZ = d3.randomNormal(contentHeight / 2, 50),
    //     points = d3.range(100).map(function () {
    //         return [randomX(), randomY(), randomZ()];
    //     });
    // draw(points);

    // /***********CLUMPY 2 CLUSTERS*******************/
    // let randomX = muy => d3.randomNormal(muy, 50),
    //     randomY = muy => d3.randomNormal(muy, 50),
    //     randomZ = muy => d3.randomNormal(muy, 50),
    //     clusters1 = d3.range(70).map(function () {
    //         return [randomX(contentHeight / 3)(), randomY(contentHeight / 3)(), randomZ(contentHeight / 3)()];
    //     }),
    //     clusters2 = d3.range(30).map(function () {
    //         return [randomX(2 * contentHeight / 3)(), randomY(2 * contentHeight / 3)(), randomZ(2 * contentHeight / 3)()];
    //     }),
    //     points = clusters1.concat(clusters2);
    // draw(points);

    // /***********CLUMPY 2 CLUSTERS CLOSER DISTANCE*******************/
    // let randomX = muy => d3.randomNormal(muy, 25),
    //     randomY = muy => d3.randomNormal(muy, 25),
    //     randomZ = muy => d3.randomNormal(muy, 25),
    //     clusters1 = d3.range(70).map(function () {
    //         return [randomX(contentHeight / 3)(), randomY(contentHeight / 3)(), randomZ(contentHeight / 3)()];
    //     }),
    //     clusters2 = d3.range(30).map(function () {
    //         return [randomX(2 * contentHeight / 3)(), randomY(2 * contentHeight / 3)(), randomZ(2 * contentHeight / 3)()];
    //     }),
    //     points = clusters1.concat(clusters2);
    // draw(points);

    // /***********STRIATED 2 LINES with noise (-1, 1)*******************/
    // let x1 = t=>1+t, y1 = t=>3-1.3*t, z1 = t=>1-t;
    // let x2 = s=>-100-s, y2 = s=>-100+1.3*s, z2 = s=>-10+s;
    // let noise = d3.randomUniform(-2, 2);
    // let line1 = d3.range(50).map(()=>{
    //    let t = d3.randomUniform(10, 50)();
    //    return [x1(t), y1(t)+noise(), z1(t)];
    // });
    // let line2 = d3.range(50).map(()=>{
    //     let s = d3.randomUniform(10, 50)();
    //     return [x2(s), y2(s)+noise(), z2(s)];
    // });
    // let points = line1.concat(line2);
    // draw(points);

    // /***********STRIATED 2 LINES with noise (-5, 5)*******************/
    // let x1 = t=>1+t, y1 = t=>3-1.3*t, z1 = t=>1-t;
    // let x2 = s=>-100-s, y2 = s=>-100+1.3*s, z2 = s=>-10+s;
    // let noise = d3.randomUniform(-5, 5);
    // let line1 = d3.range(50).map(()=>{
    //     let t = d3.randomUniform(10, 50)();
    //     return [x1(t)+noise(), y1(t)+noise(), z1(t)+noise()];
    // });
    // let line2 = d3.range(50).map(()=>{
    //     let s = d3.randomUniform(10, 50)();
    //     return [x2(s), y2(s)+noise(), z2(s)];
    // });
    // let points = line1.concat(line2);
    // draw(points);

    // /************STRIATED 2 PLANES***********************/
    // let x1 = (y1, z1) => 2 * y1 + 3 * z1 - 5;
    // let x2 = (y2, z2) => 2 * y2 + 3 * z2 + 5;
    // let noise = d3.randomUniform(-0.001, 0.001);
    // // let noise = ()=>0;
    // let plane1 = d3.range(50).map(() => {
    //     let yr = d3.randomUniform(0, 1);
    //     let zr = d3.randomUniform(0, 1);
    //     let y = yr();
    //     let z = zr();
    //     let x = x1(y, z);
    //     return [x, y, z];
    // });
    // let plane2 = d3.range(50).map(() => {
    //     let yr = d3.randomUniform(0, 1);
    //     let zr = d3.randomUniform(0, 1);
    //     let y = yr();
    //     let z = zr();
    //     let x = x2(y, z);
    //     return [x+noise(), y+noise(), z+noise()];
    // });
    // let points = plane1.concat(plane2);
    // draw(points);

    /***********Stringy LINE with noise (-0.1, 0.1)*******************/
    let noise = d3.randomUniform(-0.05, 0.05);
    // let noise = () => 0;
    let points = d3.range(100).map((x) => {
        return [x + noise(), Math.sin(x * Math.PI / 20) + noise(), Math.cos(x * Math.PI / 20) + noise()];
    });
    draw(points);


    function draw(points) {
        // let scagOptions ={
        //     startBinGridSize: 10,
        //     minBins: 10,
        //     maxBins: 200
        // }
        let scagOptions = {};
        scag = scagnostics3d(points, scagOptions);

        //Process the drag
        scagsvg = scagsvg.call(d3.drag().on('drag', dragged).on('start', dragStart).on('end', dragEnd)).append('g').attr('transform', `translate(${margins.left}, ${margins.top})`);
        //Process yLine
        d3.range(-5, 6, 1).forEach(d => {
            xLine.push([d * 0.1, -0.5, -0.5]);
            yLine.push([-0.5, -d * 0.1, -0.5]);
            zLine.push([-0.5, -0.5, d * 0.1]);
        });
        let grid = [];
        xLine.forEach(xVal => {
            zLine.forEach(zVal => {
                grid.push([xVal[0], 0.5, zVal[2]]);
            });
        });

        let binColor = d3.scaleSequential(d3.interpolateLab("#fff", "steelblue"))
            .domain(d3.extent(scag.bins.map(b => b.length)));

        let normalizedPoints = scag.normalizedPoints.map((d, i) => {
            if (d.id === undefined) {
                d.id = 'origPoints_' + i;
            }
            return d;
        });

        let leaderPoints = scag.bins.map((d, i) => {
            let ret = [d.x, d.y, d.z];
            if (ret.id === undefined) {
                ret.id = "leader_" + i;
            }
            if (ret.data === undefined) {
                ret.data = {};
            }
            ret.data.size = d.length;
            ret.data.binRadius = scag.binRadius;
            return ret
        });

        let graphLines = scag.graph.links.map((l, i) => {
            let ret = [l.source, l.target];
            if (ret.id === undefined) {
                ret.id = 'graphLine_' + i;
            }
            return ret;
        });

        let mstLines = scag.mst.links.map((l, i) => {
            let ret = [l.source, l.target];
            if (ret.id === undefined) {
                ret.id = 'mstLine_' + i;
            }
            return ret;
        });

        // let mstLines = scag.mst.links.map((l, i) => {
        //     let ret = [l.source, l.target];
        //     if (ret.id === undefined) {
        //         ret.id = 'mstLine_' + i;
        //     }
        //     return ret;
        // });

        let outlyingLines = scag.outlyingLinks.map((l, i) => {
            let ret = [l.source, l.target];
            if (ret.id === undefined) {
                ret.id = 'outlyingLine_' + i;
            }
            return ret;
        });

        let v2CornersPoints = scag.v2Corners.map((d, i) => {
            let ret = d[0];
            if (ret.id === undefined) {
                ret.id = 'v2Corners_' + i;
            }
            return ret;
        });

        let v1CornersPoints = scag.v1s.map((d, i) => {
            let ret = d;
            if (ret.id === undefined) {
                ret.id = 'v1Corners_' + i;
            }
            return ret;
        });

        let convexHullLines = [];
        scag.convexHull.map((t, i) => {
            let l1 = [t[0], t[1]];
            l1.id = 'convexHull_l1_' + i;

            let l2 = [t[1], t[2]];
            l2.id = 'convexHull_l2_' + i;

            let l3 = [t[2], t[0]];
            l3.id = 'convexHull_l3_' + i;

            convexHullLines.push(l1);
            convexHullLines.push(l2);
            convexHullLines.push(l3);
        });


        let concaveHullFaces = scag.concaveHull.map((d, i) => {
            let ret = d;
            if (ret.id === undefined) {
                ret.id = 'concaveHullFace_' + i;
            }
            return ret;
        });

        let convexHullLinesOptions = {'stroke': 'blue', 'stroke-width': 2, 'opacity': 1.0}
        let concaveHullFacesOptions = {
            'stroke': 'purple', 'stroke-width': 0.3, 'fill-opacity': 0.9, 'fill': function (d) {
                return d.ccw ? 'lightgrey' : '#717171';
            }
        };
        let origPointsOptions = {'stroke': 'black', 'fill': 'grey', 'opacity': dataPointOpacity, 'r': dataPointRadius};
        let binsOptions = {
            'stroke': 'black',
            'fill': d => binColor(d.data.size),
            'opacity': binOpacity,
            // 'r': d => scaleR(d.data.binRadius)
            'r': 3
        };
        let graphLineOptions = {'stroke': 'black', 'stroke-width': 1, 'opacity': 1.0};
        let mstLineOptions = {'stroke': 'black', 'stroke-width': 3};
        let noOutlyingMstLineOptions = {'stroke': 'green', 'stroke-width': 3};
        let outlyingLineOptions = {'stroke': 'red', 'stroke-width': 3};
        let v2CornersOptions = {
            'stroke': 'black',
            'fill': 'yellow',
            'opacity': dataPointOpacity,
            'r': dataPointRadius + 2
        };
        let v1CornersOptions = {
            'stroke': 'black',
            'fill': 'orange',
            'opacity': dataPointOpacity,
            'r': dataPointRadius + 2
        };
        rotateAndDraw(alpha, beta, duration);
        //Select elements after drawing
        selectElements();//Select the elements after drawing for toggling purpose

        //Displaying messages
        let msgContainer = "msg";
        displayScagScores(scag, msgContainer);


        function rotateAndDraw(alpha, beta, duration) {
            let xGridData = grid3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(grid);
            let axesData = [
                yScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([yLine]),
                xScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([xLine]),
                zScale3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)([zLine])
            ];
            let pointsData = point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(normalizedPoints);
            let leadersData = point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(leaderPoints);
            let graphLinesData = line3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(graphLines);
            let mstLinesData = line3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(mstLines);
            let outlyingLinesData = line3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(outlyingLines);
            let v2CornersPointsData = point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(v2CornersPoints);
            let v1CornersPointsData = point3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(v1CornersPoints);
            let convexHullLinesData = line3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(convexHullLines);
            let concaveHullFacesData = triangle3d.rotateY(beta + startAngle).rotateX(alpha - startAngle)(concaveHullFaces);
            drawAxes(axesData, scagsvg);
            drawXGrid(xGridData, scagsvg);
            drawCircles(pointsData, scagsvg, 'origPoints', duration, origPointsOptions);
            drawCircles(leadersData, scagsvg, 'bins', duration, binsOptions);
            drawLines(graphLinesData, scagsvg, 'graphLines', duration, graphLineOptions);
            drawLines(mstLinesData, scagsvg, 'mstLines', duration, mstLineOptions);
            drawLines(outlyingLinesData, scagsvg, 'outlyingLines', duration, outlyingLineOptions);
            drawCircles(v2CornersPointsData, scagsvg, 'v2Corners', duration, v2CornersOptions);
            drawCircles(v1CornersPointsData, scagsvg, 'v1Corners', duration, v1CornersOptions);
            drawLines(convexHullLinesData, scagsvg, 'convexHullLines', duration, convexHullLinesOptions);
            drawTriangles(concaveHullFacesData, scagsvg, 'concaveHullFaces', duration, concaveHullFacesOptions);
        }

        //<editor-fold desc="This section is drag processing">
        function dragStart() {
            mx = d3.event.x;
            my = d3.event.y;
        }

        function dragged() {
            mouseX = mouseX || 0;
            mouseY = mouseY || 0;
            beta = (d3.event.x - mx + mouseX) * Math.PI / 230;
            alpha = (d3.event.y - my + mouseY) * Math.PI / 230 * (-1);
            rotateAndDraw(alpha, beta, 0);
        }

        function dragEnd() {
            mouseX = d3.event.x - mx + mouseX;
            mouseY = d3.event.y - my + mouseY;
        }

        //</editor-fold>

        function drawLines(data, svg, classType, duration, lineOptions = {}) {
            let stroke = lineOptions.stroke;
            let strokeWidth = lineOptions['stroke-width'];
            let opacity = lineOptions.opacity;
            if (stroke === undefined) stroke = 'black';

            if (strokeWidth === undefined) strokeWidth = 0.5;
            if (opacity === undefined) opacity = 1.0;

            let lines = svg.selectAll(`line.${classType}`).data(data, d => d.id);
            lines
                .enter()
                .append('line')
                .attr('class', `_3d ${classType}`)
                .merge(lines)
                .attr('stroke', stroke)
                .attr('stroke-width', strokeWidth)
                .attr('opacity', opacity)
                .attr('x1', d => d[0].projected.x)
                .attr('y1', d => d[0].projected.y)
                .attr('x2', d => duration ? d[0].projected.x : d[1].projected.x)
                .attr('y2', d => duration ? d[0].projected.y : d[1].projected.y)
                .transition().duration(duration)
                .attr('x2', d => d[1].projected.x)
                .attr('y2', d => d[1].projected.y);
            lines.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }

        function drawXGrid(data, svg) {
            /*x-Grid*/
            let xGrid = svg.selectAll('path.grid').data(data);
            xGrid
                .enter()
                .append('path')
                .attr('class', '_3d grid')
                .merge(xGrid)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.3)
                .attr('fill', function (d) {
                    // return d.ccw ? 'lightgrey' : '#717171';
                    return 'lightgrey';
                })
                .attr('fill-opacity', 0.9)
                .attr('d', grid3d.draw);
            xGrid.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }

        function drawTriangles(data, svg, classType, duration, triangleOptions = {}) {
            let stroke = triangleOptions.stroke;
            let strokeWidth = triangleOptions['stroke-width'];
            let fill = triangleOptions.fill;
            let fillOpacity = triangleOptions['fill-opacity'];
            if (stroke === undefined) stroke = 'black';
            if (strokeWidth === undefined) strokeWidth = 0.3;
            if (fill === undefined) fill = 'lightgrey';
            if (fillOpacity === undefined) fillOpacity = 0.9;
            /*Triangle*/
            let triangles = svg.selectAll(`path.${classType}`).data(data, d => d.id);

            triangles
                .enter()
                .append('path')
                .attr('class', `_3d ${classType}`)
                .merge(triangles)
                .attr('stroke', stroke)
                .attr('stroke-width', strokeWidth)
                .transition().duration(duration)
                .attr('fill', fill)
                .attr('fill-opacity', fillOpacity)
                .attr('d', triangle3d.draw);
            triangles.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }

        function drawAxes(data, svg) {
            /*y-Scale*/
            let yScale = svg.selectAll('path.yScale').data(data[0]);
            yScale
                .enter()
                .append('path')
                .attr('class', '_3d yScale')
                .merge(yScale)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .attr('d', yScale3d.draw);
            yScale.exit().remove();
            /*y-Scale text*/
            let yText = svg.selectAll('text.yText').data(data[0][0]);
            yText
                .enter()
                .append('text')
                .attr('class', "_3d yText")
                .attr('dx', '.3em')
                .merge(yText)
                .each(d => {
                    d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
                })
                .attr('x', d => d.projected.x)
                .attr('y', d => d.projected.y)
                .text(d => {
                    let val = d[1] + 0.5
                    if (val === 0) {
                        return ''
                    } else if (val === 1) {
                        return 'y'
                    } else {
                        return (val).toFixed(1);
                    }
                });
            yText.exit().remove();
            /*x-Scale*/
            let xScale = svg.selectAll('path.xScale').data(data[1]);
            xScale
                .enter()
                .append('path')
                .attr('class', '_3d xScale')
                .merge(xScale)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .attr('d', xScale3d.draw);
            xScale.exit().remove();
            /*y-Scale text*/
            let xText = svg.selectAll('text.xText').data(data[1][0]);
            xText
                .enter()
                .append('text')
                .attr('class', "_3d xText")
                .attr('dx', '.3em')
                .merge(xText)
                .each(d => {
                    d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
                })
                .attr('x', d => d.projected.x)
                .attr('y', d => d.projected.y)
                .text(d => {
                    let val = d[0] + 0.5
                    if (val === 0) {
                        return ''
                    } else if (val === 1) {
                        return 'x'
                    } else {
                        return (val).toFixed(1);
                    }
                });
            xText.exit().remove();
            /*z-Scale*/
            let zScale = svg.selectAll('path.zScale').data(data[2]);
            zScale
                .enter()
                .append('path')
                .attr('class', '_3d zScale')
                .merge(zScale)
                .attr('stroke', 'black')
                .attr('stroke-width', 0.5)
                .attr('d', zScale3d.draw);
            zScale.exit().remove();
            /*y-Scale text*/
            var zText = svg.selectAll('text.zText').data(data[2][0]);
            zText
                .enter()
                .append('text')
                .attr('class', "_3d zText")
                .attr('dx', '.3em')
                .merge(zText)
                .each(d => {
                    d.centroid = {x: d.rotated.x, y: d.rotated.y, z: d.rotated.z};
                })
                .attr('x', d => d.projected.x)
                .attr('y', d => d.projected.y)
                .text(d => {
                    let val = d[2] + 0.5
                    if (val === 0) {
                        return ''
                    } else if (val === 1) {
                        return 'z'
                    } else {
                        return (val).toFixed(1);
                    }
                });
            zText.exit().remove();

            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }

        function drawCircles(data, svg, classType, duration, circleOptions = {}) {
            let opacity = circleOptions.opacity;
            let r = circleOptions.r;
            let fill = circleOptions.fill;
            let stroke = circleOptions.stroke;

            if (opacity === undefined) opacity = 1.0;
            if (r === undefined) r = 1;
            if (fill === undefined) fill = 'black';
            if (stroke === undefined) stroke = 'black';


            let circles = svg.selectAll(`circle.${classType}`).data(data, d => d.id);

            circles
                .enter()
                .append('circle')
                .attr('class', `_3d ${classType}`)
                .attr('opacity', 10e-6)
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y)
                .attr('id', d => d.id)
                .merge(circles)
                .transition().duration(duration)
                .attr('r', r)
                .attr('stroke', stroke)
                .attr('fill', fill)
                .attr('opacity', opacity)
                .attr('cx', d => d.projected.x)
                .attr('cy', d => d.projected.y);
            circles.exit().remove();
            //Resort all the 3d elements
            svg.selectAll('._3d').sort(d3._3d().sort);
        }
    }

    function displayScagScores(scag, msgContainer) {
        let msg = "Scagnostics";
        //Binning
        msg += "<br/>0. Bin size: " + scag.binSize + "x" + scag.binSize + " bins" + ", num of bins: " + scag.bins.length;
        //Outlying
        msg += "<br/>1. Outlying score: " + scag.outlyingScore + ", outlying edge cut point: " + scag.outlyingUpperBound;
        //Skewed
        msg += "<br/>2. Skewed score: " + scag.skewedScore;
        //Sparse
        msg += "<br/>3. Sparse score: " + scag.sparseScore;
        //Clumpy
        msg += "<br/>4. Clumpy score: " + scag.clumpyScore;
        //Striated
        msg += "<br/>5. Striated score: " + scag.striatedScore;
        //Convex
        msg += "<br/>6. Convex score: " + scag.convexScore;
        //Skinny
        msg += "<br/>7. Skinny score: " + scag.skinnyScore;
        //Stringy
        msg += "<br/>8. Stringy score: " + scag.stringyScore;
        //Monotonic
        msg += "<br/>9. Monotonic score: " + scag.monotonicScore;
        //Set the scagnostics message
        d3.select("#" + msgContainer).html(msg);
    }
</script>
</body>
</html>